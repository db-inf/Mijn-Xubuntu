= Truuks en commando's in Xubuntu
:description:  handige commando's die te moeilijk en met tevelen zijn om te onhtouden

- https://docs.asciidoctor.org/asciidoc/latest/syntax-quick-reference/[AsciiDoc syntax]

- DE site voor kernel modules en hardware drivers: https://www.kernel.org/doc/Documentation/

- OPGELET : bash doet geen globbing (path expansion) tussen '' of "" of bij name=value* (wel bij reeks=(value*), geen $variable-expansie tussen ''

== TODO bash regex ==
- als rechterlid van [[ string =~ regex ]], dat NIET tss. "" staat (is anders literal, geen regex)
- regex NIET tussen "", dus escape spaties als '\ '
- array BASH_REMATCH[] bevat na uitvoeren gematchte subgroepen

== andere docs ===
=== _Xubuntu.adoc ===
=== _Xubuntu composekey multikey combinaties.adoc ===
=== _bash readline keys.txt ===
=== _ffmpeg truuks en commandos.adoc ===
=== _Tex-LaTex.adoc ===
=== _Wine-PlayOnLinux.adoc ===
=== _POLwineprefix 2.11 Win7x86PROGS.txt ===
=== _VirtualBox.adoc ===
=== _Xpra.adoc ===
=== _Dragon.adoc ===
=== _SW10 installatie.txt ===

== NOODGEVALLEN ==

=== bootlog van andere linux op andere partitie zien ===

# journalctl -D /mnt/var/log/journal/
	- log wordt helaas pas geschreven als bootproces ver genoeg komt
	- zie sectie "linux logs" en sectie "journalctl"

=== Magic Alt Sysrq ===

- zie "https://www.kernel.org/doc/Documentation/admin-guide/sysrq.rst"
- zie "https://askubuntu.com/questions/11002/alt-sysrq-reisub-doesnt-reboot-my-laptop"

- zonder alt-sysrq (b.v.vanop afstand of in VM) :
	# echo "x" > /proc/sysrq-trigger
		- x : een van de sysrq codeletters
		- lijkt alleen te werken in een console (Alt-Ctrl-1 t.e.m. 6, Alt-Ctrl-7 is de Ubuntu GUI), niet in Ubuntu GUI terminal venster
		- de meeste commandos doen niets, hoogstens omschrijven ze zichzelf
		- veilig om te proberen :
			- h : help, werkt (maar zegt heel weinig)
			- s : sync alle gemounte bestandssystemen
			- m : dump kernel memory info to (your console: doet het niet) naar syslog
			- p : dump the current registers and flags .
			- t : dump list of current tasks to (your console: doet het niet) naar syslog
			- w : dump tasks that are in uninterruptable (blocked) state
		- onveilig, eerst veel leren :
			0 b : reboot without sync or umount
			0 e : send SIGTERM to all processes except init (zowat de Alt-F4 van windows: vraagt proces om af te sluiten)
			0 i : send SIGKILL to all processes except init (vraag proces om abort of zoiets)
			0 f : call oom_kill to kill a memory hog process (process dat out-of-memory geeft)
			0 r : zet keyboord 'raw' mode off and sets it to XLATE ???
			0 u : remount alle gemounte filesystems readonly
	- zo veilig mogelijk reboot forceren
		- op voorwaarde dat die letters echt werken
		- als dat in 1 string mag, nog bevestiging van zoeken
			# echo "reisub" > /proc/sysrq-trigger

- huidige status van welke Alt+Sysrq ge kunt doen :
	$ cat /proc/sys/kernel/sysrq
	>>> 176 <<<
	- 176 is 128+32+16
		 0 - disable sysrq completely
		 1 - enable all functions of sysrq
		>1 - bitmask of allowed sysrq functions :
			  2 =   0x2 - enable control of console logging level
			  4 =   0x4 - enable control of keyboard (SAK, unraw)
			  8 =   0x8 - enable debugging dumps of processes etc.
			 16 =  0x10 - enable sync command
			 32 =  0x20 - enable remount read-only
			 64 =  0x40 - enable signalling of processes (term, kill, oom-kill)
			128 =  0x80 - allow reboot/poweroff
			256 = 0x100 - allow nicing of all RT tasks

- direct meer toelaten of verbieden :
	$ sudo -i
		- gewoon "sudo echo ... > ..." werkt niet, want redirect gebeurt terug buiten sudo
	# echo "bitmask" >/proc/sys/kernel/sysrq
	OF
	$ echo "bitmask" | sudo tee /proc/sys/kernel/sysrq

- blijvend meer toelaten of verbieden :
	- Alt+sysrq wordt in Ubuntu gecontroleerd door /etc/sysctl.conf (NIET WIJZIGEN, wordt bij upgrade toch vervangen) en /etc/sysctl.d/*.conf :
	$ grep kernel.sysrq /etc/sysctl.d/*.conf
	>>>
		/etc/sysctl.d/10-magic-sysrq.conf:#   debugging dumps of processes: kernel.sysrq = 10
		/etc/sysctl.d/10-magic-sysrq.conf:kernel.sysrq = 176
		/etc/sysctl.d/99-sysctl.conf:#kernel.sysrq=1
	<<<
	- in /etc/sysctl.d/ een .conf bestand bij zetten dat na 10-magic-sysrq.conf sorteert, met de gewenste toelatingen

== PRODUCTIVITEIT ==

- zie ook "_Xubuntu ComposeKey multikey combinaties.txt"

=== Hele scherm zoomen, panning volgt muis ===

- In xfce4 Window Manager Tweaks/Accessibility een toets kiezen voor 'key used to grab and move windows', b.v. Alt (niet shift, want dan werkt b.v. selecteren met shift ingedrukt niet meer), en dan zoomt het hele scherm met Alt+scrollwiel

=== panel sneltoetsen ===

- xkb-plugin-11 Keyboard Layouts
	. Shift+CapsLock : wissel keyboard layout (toegevoegd om tss. qwerty en draadloos azerty te wisselen)

=== window manager sneltoetsen ===
(zelf ingesteld, Super = rechter Windows-toets)
	. Super+num		toggle resize window naar scherm-helft of kwadrant, 0 mini, 5 maxi
	. Super+end		venster naar achtergrond
	. Super+omhoog	toggle oprollen tot titelbalk (shade)
	. Super+omlaag	toggle volle hoogte
	. Super+omhoog	toggle volle breedte
	. Super+d		toggle desktop
	. Alt+tab		schakelen tussen vensters
	. Super+tab		schakelen tussen vensters van zelfde programma
	. Shift+Alt+Ctrl+pijl verplaats naar workspace
	. Alt+F8		toggle sticky venster (zichtbaar op elke workspace)

=== window manager tweaks ===

- key used to grab and move windows (ook grab window edge/corners and resize window)
	. 'alt' kiezen in accessibility tab
	. alt + muisklik : grab en verplaats het venster
	. alt + averechtse muisklik : grab en verplaats dichtst bijzijnde vensterrand of -hoek = resize)

=== launcher sneltoetsen (settings/keyboard) ===
- sommige toest-combinaties worden niet gedetecteerd door betreffende dialoog van Settings/Keyboard (xfce4-keyboard-settings), maar zijn wel als "/commands/custom/" +tekst-string in te stellen in "Settings/Settings/ Editor/xfce4-keyboard-shortcuts"
	- enkel in nieuwe entry, van bestaande entries kunt ge enkel het commando wijzigen, niet de toetscombo
	- bijhorende opdracht ingeven als "Type" String

- mijn "Super"-toets : linkse "Windows"-toets
	. Super+k		Toon launcher sneltoetsen (settings/keyboard)
	. alt+ctrl+l	vergrendel scherm (paswoord ingeven)
	. alt+ctrl+t	terminal emulator
	. alt+ctrl+F1-6	console 1-6
	. alt+ctrl+F7	X grafische terminal
	. Print			schermafdruk met dialoog voor bestemming (default ingesteld als -s /media/ramdisk)
	. Alt+Print		afdruk actief venster naar XnViewMP
		- Alt+Print enkel als nieuwe toetscombo "/commands/custom/<Alt>Print" in te stellen via "Settings/Settings/ Editor/xfce4-keyboard-shortcuts")
	. Super+d		desktop (toggle on/off)
	. Super+t		terminal emulator
	. Super+shft+t	transparante terminal emulator
	. Super+a		application menu popup (application finder)
	. Super+q		'quick' run (application finder compact)
		opdracht	opdracht uitvoeren
		>opdracht	opdracht uitvoeren in bash zonder terminal (maar mét aliases)
		<opdracht	opdracht uitvoeren in bash in terminal met output, geen prompt
		?opdracht	manpage van opdracht (-a : all sections)
		??opdracht	info van opdracht
		$texscript	texdoc van (la)tex script
		/pad		filemanager openen in '/pad'
		~/pad		filemanager openen in '~/pad'
		http://		open url in browser
		https://	open url in browser
		file://		open url in browser
	. Super+LAlt	whisker application menu popup
	. Super+e		editor (geany)
	. Super+shft+e	andere editor (mousepad)
	. Super+f		filemanager (spacefm)
	. Super+shft+f	andere filemanager (thunar)
	. Super+b		browser (firefox)
	. Super+m		mail (thunderbird)
	. Super+p		pc monitor aanzetten (script beeldpc)
	. Super+o		tv uitvoer aanzetten (script beeldtv)
	. Super+c		calculator
	. Super+w		'word' (libreoffice writer)
	. Super+x		'excel' (libreoffice calc)
	. Super+g		Goldendict woordenboek
	. Super+z		nzbget met webinterface
	. Super+n		toggle notifications on/off (o.a. Skype en e-mail popups + piep)
	. Super+/		xman man-page lezer (/ == ?)
	. Super+v		volume controle
	. Super+shft+v	volume controle tab 'playback'
	. Super+,		"amixer -q set Master 8%-" (, == <), alsa-volume lager
	. Super+.		"amixer -q set Master 8%+" (. == >), alsa-volume hogger


=== bash shell sneltoetsen ===

- zie ook "_bash readline keys.txt"

	. ctrl+d	op prompt: exit
	. ctrl+d	bij lezen invoer van stdin, aan begin van nieuwe lijn : end-of-file
	. ctrl+c	huidige bash job/script een SIGINT sturen, meeste opdrachten breken dan af
	. ctrl+z	job/script stoppen met SIGSTOP: koppelt de job los van de terminal, zodat ze geen in- of uitvoer meer krijgt, en daarom ineens helemaal wordt gepauzeerd, zonder zijn resources vrij te geven. Eerste exit geeft boodschap dat er nog jobs zijn, 2de exit sluit ze af.
		- zie ook sectie "bash jobs"

=== xfce terminal sneltoetsen ===
	. Ctrl+u	clears from cursor to beginning of line
	. Ctrl+k	clears from cursor to end of line
	. Esc+bkspc	clears one word to the left of the cursor
	. Esc+d		clears one word to the right of the cursor
	. Ctrl+lft/rgt jumps to the beginning of the previous/next word
	- Ctrl+l	scroll prompt tot bovenaan terminal, terugscrollen blijft mogelijk
		- OPM : mijn alias cls="echo -ne '\033c'" doet een echte clear van screen én scrollbuffer

=== numeriek toetsenbord gebruiken als muis ===

- is X-feature, zie https://en.wikipedia.org/wiki/Mouse_keys

- driver laden :
	$ setxkbmap -option keypad:pointerkeys
	- activeren/deactiveren : LeftCtrl + LeftShift + NumLock (standaard: R-Alt + L-Shift + NumLock)

- cursor besturen :
	7 8 9
	4   6
	1 2 3
- muisknoppen besturen
	/ * - : selecteer 'gewone', middelste of 'averechtse' (blijvend)
	5 + :  klik of dubbelklik
	0 . :  press of release

=== Xubuntu panel herstarten om veranderingen te laten zien ===
	$ xfce4-panel -r

=== Automatisch uitvoeren bij opstarten ===

- .desktop bestanden in o.a. ~/.config/autostart, /etc/xdg/autostart/ en /etc/xdg/xdg-xubuntu/autostart/
	- schakel autostart uit door "Hidden=true" in de betreffende .desktop te zetten

- die in ~/.config/autostart worden gemaakt/gewijzigd in "Settings/session and startup"

- zie ook "https://specifications.freedesktop.org/autostart-spec/autostart-spec-latest.html"

=== mimetype van bestanden ===

- zie ook sectie "mimetype default applications"
- zie ook "/etc/mime.types" voor mimetypes bekend bij de distri

- opvragen, b.v.:
	$ xdg-mime query filetype "mijnbestand.txt"
	>>> text/plain <<<

- mimetypes gedefiniëerd door xml-bestanden (zie verder) in subdirs van (in volgorde van dalende voorrand)
		~/.local/share/mime/ 	: voor 1 gebruiker
		/usr/local/share/mime/	: voor alle gebruikers, eigen beheer
		/usr/share/mime/ 		: voor alle gebruikers, beheerd door distri
	- minstens sinds Ubuntu 12.04
	- mime-xml's vertalen naar afgeleide config-bestanden in de rest van de directory tree :
		$ [sudo] update-mime-database ???/share/mime
		- o.a. ???/share/applications/mimeinfo.cache
	- WIJZIG ENKEL IN ???/share/mime/packages

- Er is ook, maar niet duidelijk wie dat nog gebruikt, /etc/mime.types : mimetype en evt. extensies die daarmee verbonden zijn
	- eigen mime types in "~/.mime.types" hebben voorrang

- xml-bestanden definiëren mimetypes a.d.h.v.
	- globbing patterns voor bestandsnamen, en omschrijvingen
	- herkenning bestanden aan magic bytes in bestand, vb. :
		~~ <magic priority="80">	<match value='Content-Type: text/x-zim-wiki' type="string" offset="0"/> </magic> ~~
	- in blok <mime-info>...</mime-info>
		- herkenning bestanden aan extensie :
			~~ <glob pattern="*.extensie"/> ~~
			- meerdere glob-tags toegestaan
			>>> mijn-type.xml
				<?xml version="1.0" encoding="UTF-8"?>
				<mime-info xmlns="http://www.freedesktop.org/standards/shared-mime-info">
				  <mime-type type="application/x-mijnmimetype">
					<comment>new mime type</comment>
					<glob pattern="*.xyz"/>
				  </mime-type>
				</mime-info>
			<<<
	- als globbing niet volstaat om type vast te stellen, maar het (begin van) het bestand gelezen moet worden om een kenmerkende sleutel te vinden: een magic key definieren, zie [https://docs.oracle.com/cd/E19253-01/819-0918/6n3aglfe9/index.html#mimetypes-16], b.v.
	>>>
		<magic priority="50">
			<match offset="0" type="string" value="\x89PNG" />
		</magic>
	<<<
	- NIET VERGETEN: Update the MIME database for your changes to take effect:
		$ update-mime-database ~/.local/share/mime

- zie [https://docs.oracle.com/cd/E19253-01/819-0918/mimetypes-0/index.html]
- zie [https://help.gnome.org/admin/system-admin-guide/stable/mime-types-custom-user.html.en]

==== mimetype default applications ====

- zie ook sectie "mimetype van bestanden"
- zie ook sectie "xfce applications menu"

- opvragen, b.v. :
	$ xdg-mime query default text/plain
	>>> mousepad.desktop <<<
	OF
	$ xdg-mime query default $(xdg-mime query filetype "mijnbestand.odt")
	>>> libreoffice6.4-writer.desktop <<<
	- debuggen, b.v. jpeg :
		$ env XDG_UTILS_DEBUG_LEVEL=10 xdg-mime query default image/jpeg

- default toepassing vastleggen met desktop-bestand in (in volgorde van dalende voorrand)
		~/.local/share/applications/ 	: voor 1 gebruiker
		/usr/local/share/applications/ 	: voor alle gebruikers, eigen beheer
		/usr/share/applications/		: voor alle gebruikers, beheerd door distri
	- b.v. met diverse vaste parameters, en 1 bestandsnaam (plaatshouder %f, voor alle bestandsnamen %F) als laatste
	>>> mijntoepassing.desktop
		[Desktop Entry]
		Type=Application
		MimeType=application/x-mijnmimetype
		Name=mijntoepassing
		Exec=mijntoepassing parameters %f
	<<<

- Update the application database:
	$ [sudo] update-desktop-database ???/share/applications

- bestand kan nu geopend worden met
	$ xdg-open mijnbestand
		- programma's zoals Firefox gebruiken xdg-open
	OF
	$ gio open mijnbestand
	OF
	$ gvfs-open mijnbestand
	OF
	$ mimeopen mijnbestand
		- vraagt nog werk, opent b.v. jpg in browser, txt in xterm met vim (zonder die te kunnen starten), ...
	- als het een tekstbestand is dat met less bekeken wordt, en $LESSEDIT is ingesteld als xdg-open, kan het bestand met zijn standaardtoepassing geopend worden vanuit less met 'v' : zie "_Xubuntu.adoc" sectie "lessedit"

- Startmenu/Settings/Mimetype editor
	- spacefm "contextmenu/Open/Set as default" wijzigt dit ook
- in "~/.config/mimeapps.list"
- in de bestanden ./applications/default.lst en ./applications/mimeinfo.cache op het pad in de environment variabele XDG_DATA_DIRS, in die volgorde, b.v.:
	. $XDG_DATA_DIRS=/usr/share/xubuntu:/usr/share/xfce4:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop:/usr/share

=== Snel openen ===

- exo-open - Open URLs and launch preferred applications
	$ exo-open directory
	- opent directory in filemanager, ook b.v. "exo-open ." of "exo-open ~"
	$ exo-open mailto:user@server
	- opent mailto-url in e-mail programma
	$ exo-open mailto:user@server?attach=bestand
	- opent mailto-url in e-mail programma, met attachment
	$ exo-open http://url
	$ exo-open url
	- opent url in browser
	$ exo-open bestand
	- opent bestand in geassocieerd programma
- gelijkaardige programma's, maar bepalen hun geassocieerd programma op een andere manier:
	$ xdg-open (bestand | url | map)
	$ gvfs-open (bestand | url | map)
	0 gnome-open (bestand | url | map)
	$ mimeopen bestand
		[-a, --ask] : kies (in terminal) a.d.h.v. mimetype van bestand welke van het lijstje toepassingen het bestand moet openen
		[-d, --default] : kies (in terminal) a.d.h.v. mimetype van bestand welke van het lijstje toepassingen in het vervolg als default bestand en andere met zelfde mimetype moet openen
		[-M, --magic-only] : Do not check for extensions, globs or inode type, only look at the content of the file. This is particularly useful if for some reason you don't trust the name or the extension a file has.

=== xfce applications menu ===

- Gemakkelijk menu-items toevoegen door .desktop bestanden te schrijven in ~/.local/share/applications. De 'Categories' bepalen in welk submenus het komt. Eigen submenu met Categories=X
	- ZIE https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-1.1.html
	- ZIE https://specifications.freedesktop.org/menu-spec/menu-spec-1.0.html#category-registry

- environment variable instellen in Exec= van een .desktop (à la bash 'var=waarde opdracht') lukt alleen door er de opdracht 'env' voor te zetten

- bestanden ~/.local/share/applications/userapp-%OMSCHRIJVING%-%HASH%Y.desktop worden automatisch aangemaakt, o.a. door Thunar's "openen met", en krijgen een lijntje bij in /home/dirk/.config/mimeapps.list
	- zie ook sectie "mimetype default applications"
	- voor "Send to, Mail Recipient" helaas een nieuwe, voor elk bestandstype en voor elke keer; Af en toe opkuisen

- spec in https://specifications.freedesktop.org/menu-spec/menu-spec-latest.html; menu's worden beheerd en gewijzigd met xdg-desktop-menu, een (command line tool for (un)installing desktop menu items). Blijken niet voorzien op de menus die Xubuntu per user bijhoudt in ~/.config/menus en ~/.local/share/applications.
	- Mogelijk moet daar voor Xfce een lijntje bij in (ZIE "https://wiki.archlinux.org/index.php/xdg-menu#Adding_desktop_entries_from_other_directories"; voor archlinux heet dat betreffende bestand /etc/xdg/menus/arch-applications.menu)
		- /etc/xdg/menus/xfce-applications.menu
		- /etc/xdg/xdg-xubuntu/menus/xfce-applications.menu

- de GUI-menu-editor van Xubuntu is menulibre, te vinden onder Setup/Menu Editor. Gebruik die heel zorgvuldig, of ge maakt er een zootje van.
	. documentatie op https://wiki.smdavis.us/menulibre-docs (is redelijk waardeloos)
	. hoofdmenu komt in xfce-hoofdmenu
		/home/dirk/.config/menus/xfce-applications.menu
	. menulibre submenus komen in bestanden
		/home/dirk/.local/share/desktop-directories/menulibre-%SUBMENU%.directory
		/home/dirk/.config/menus/applications-merged/user-menulibre-%SUBMENU%.menu
	. menulibre menuentries komen in bestanden /home/dirk/.local/share/applications/menulibre-%ENTRY%.desktop
	. .directory en .desktop bestanden mogen waar echt nodig met de hand beperkt wat gewijzigd worden, .menu enkel ZEER beperkt, daar kunt ge niks zinnigs mee doen dat ge niet beter in menulibre zelf doet.
		. zie https://developer.gnome.org/integration-guide/stable/desktop-files.html.en voor beschrijving van menu organisatie
		. zie https://developer.gnome.org/desktop-entry-spec/ voor beschrijving van .desktop snelkoppelingen en .directory.
	. submenu en entry aanmaken door, met het juiste hoofd/submenu geselecteerd, op de '+' bovenaan rechts van het applicatiemenu te klikken (dus niet de gnome-'+' van maximize). VOORAL NIET VERGETEN op het einde naast die '+' op het gnome-save ⍗ (pijltje naar beneden in een rechthoek) te klikken, MAAR EERST een naam opgeven voor het submenu/menuentry, of ge krijgt een nietszeggende bestandsnaam die ge achteraf niet terugvindt.
	. nieuwe icons als bestandsnaam opgeven, of vooraf van bestand installeren naar de iconfolders met
		. xdg-icon-resource install
	. volgorde van menuentries/submenus wijzigen met pijlen onder de lijst van alle menu-items

=== Xubuntu startmenu whisker ===

- De instellingen staan in /home/dirk/.config/xfce4/panel/whiskermenu-1.rc
- whisker neemt voor het overige het xfce applications menu over

=== Searchplugins Firefox wijzigen ===

0 zijn xml-bestanden in ~/.mozilla/firefox/4kbxx5f4.default/searchplugins
	- tegenwoordig niet meer zo simpel als kopieren naar die directory, staan direct en enkel in search.json.mozlz4
- worden gecached in ~/.mozilla/firefox/4kbxx5f4.default/search.json.mozlz4

OFWEL
- search plugin maken met de hand, met andere xml's als voorbeeld
	- zie "/media/sdata/dirk/backups/Firefox = mijn searchengine plugins.zip":
		- de index.html openen via ZipWebServer
		- zoals daarin beschreven de plugin kiezen
OFWEL
- search plugin laten maken door b.v. Ready2Search http://ready.to/search/en/
	- resultaat niet installeren, maar eerst bewaren om op maat te maken (o.a. icon checken door het even in een html te plakken met <img src="data:...">)
- Firefox : schermafdrukje maken van volgorde searchplugins
- Firefox : alle vensters sluiten
- cache hernoemen (of ineens verwijderen) naar b.v. search.json.mozlz4~
- Firefox : terug opstarten, maakt search.json.mozlz4 terug aan vanuit bron-xml's
- Firefox : volgorde van search plugins terug instellen zoals voorheen

=== spacefm op maat maken ===

- persoonlijke configuratie wordt bewaard in verschillende generaties van ~/.config/spacefm/session; geregeld zelf backupje van maken tot mijn config wat stabiel is.
	- wschlk. een equivalent van Java's Properties (maar dan met secties zoals een .ini), met een parent met defaultinstellingen, en een

- van tijd geraken de kolom-breedtes overhoop, ik heb daarom een scriptje gemaakt :
	$ ~/bin/spacefmherstelconfig

- custom commandos hebben sleutel van de vorm cstm_########-xxxx=..., niet alles daarin is duidelijk, dus gewoon de custom actions van thunar (.config/Thunar/uca.xml) met de hand overbrengen naar spacefm.

- b.v. het "bulk rename" venster van thunar gebruiken :
	- rechtsklikken waar ge nieuw commando wilt in (popup) menu, bookmark, of taakbalkknop, of F2 met menu item highlighted
		- brengt u in 'design menu'
		- kies "New", "Command", een naam geven
		- Command : thunar --bulk-rename %F
		- Context : eerst onderaan voorwaarde (test) editen, dan pas add
			- multiple selected equals true
		- Menu item, icon : All icons, "menu-editor"
	  en klaar is kees. De rename-kracht van thunar, maar zonder de crashes van thunar die zijn bestandenlijst probeert te hersorteren terwijl de bestanden hun nieuwe namen krijgen.

- custom commands toevoegen/wijzigen met [Insert]/[F4]
	- toegevoegde commands zijn gebonden aan menu item waarop de insert gedaan wordt: als dat menu item niet getoond wordt, dan ook het nieuwe toegevoegde commando niet, ongeacht zijn eigen 'context'
	- de command editor toont de %xxx subsituties die gebruikt kunnen worden
		- zie file:///usr/share/doc/spacefm/spacefm-manual-en.html#designmode-props-command
	- daarnaast kunnen ook spacefms eigen shell variabelen $fm_xxx gebruikt worden
		- zie file:///usr/share/doc/spacefm/spacefm-manual-en.html#exvar
		- die WIJZIGEN HEEFT GEEN EFFECT op spacefm; ge kunt dus b.v. geen file selecteren door de list van selected files te wijzigen
	- spacefm's %x substituties verdragen geen quotes errond, enkel noch dubbel: spacefm wil dat zelf regelen. Maar de equivalente shell variabelen van spacefm kunnen wel tss. quotes, b.v. ... -e "tweak -l \"$fm_file\"" ...
	- de toestand van spacefm veranderen (b.v. tabs openen, bestanden selecteren) gaat via spacefm socket : "spacefm --socket-cmd set ..." of "spacefm -s set ..."
		- zie file:///usr/share/doc/spacefm/spacefm-manual-en.html#sockets-invoc-help
		- zie "spacefm -s help"

- zie ook _Xubuntu.adoc sectie "vuilnisbak toelaten"

=== fonts zoeken ===

- https://fonts.google.com/
	- heel goede selectiemogelijkheden (type, breedte, dikte, ...)
	- custom tekst in te stellen voor alle voorbeelden :
		>>> zowat alle letters die ik nodig heb:
			ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzáéíóúýàèìòùỳäëïöüÿâêîôûŷñçÇ ?!:;,.'"`‘’“”()[]{}/\&%*~^|#@<-+÷×=>0123456789®©$€£¥¢
		<<<

- https://www.fontsquirrel.com
	- heel populair

- zie ook http://hivelogic.com/articles/top-10-programming-fonts/

=== fonts installeren ===

- zie ook _Xubuntu.adoc sectie "ATM4 font collectie"

- fontbestanden op de schijf zetten:
	- persoonlijk : kopiëer naar (directories onder) ~/.local/share/fonts (deprecated: ~/.fonts)
	- voor iedereen : kopieer naar /usr/local/share/fonts
	- systeemfonts : staan in /usr/share/fonts, gegroepeerd in directories

- gebruik van fonts configureren:
	- zie "man fonts.conf"
	- zie [https://wiki.archlinux.org/title/font_configuration#Fontconfig_configuration]
	- "Fontconfig gathers all its configurations in a central file (/etc/fonts/fonts.conf).", maar de configuratie-instructies gebeuren hier:
		- persoonlijk : ~/.config/fontconfig/fonts.conf en ~/.config/fontconfig/conf.d/ (of $XDG_CONFIG_HOME/fontconfig/... als die envvar is ingesteld)
			- worden geladen door
			>>> /etc/fonts/conf.d/50-user.conf
					<include ignore_missing="yes" prefix="xdg">fontconfig/conf.d</include>
					<include ignore_missing="yes" prefix="xdg">fontconfig/fonts.conf</include>
					<!-- the following elements will be removed in the future -->
					<include ignore_missing="yes" deprecated="yes">~/.fonts.conf.d</include>
					<include ignore_missing="yes" deprecated="yes">~/.fonts.conf</include>
			<<<
		- voor iedereen :
			- /etc/fonts/fonts.conf en /etc/fonts/conf.d/ (worden door systeem overschreven)
			- /etc/font/local.conf (specifiek voor deze installatie)
				- wordt geladen door
				>>> /etc/fonts/conf.d/51-local.conf
					<include ignore_missing="yes">local.conf</include>
				<<<
		- "There are presets installed in the directory /usr/share/fontconfig/conf.avail [EN OOK /etc/fonts/conf.avail/]. They can be enabled by creating symbolic links to them, both per-user and globally, as described in /etc/fonts/conf.d/README"
			- die symlinks kunnen in ~/.config/fontconfig/conf.d/ of in /etc/fonts/conf.d/
		- OPM: er is ook een /etc/fonts/conf.avail/ met veel meer in dan /usr/share/fontconfig/conf.avail/

- activeren zonder heropstart :
	$ sudo fc-cache -f -v
	- zonder sudo kan, voor eigen gebruiker alleen, maar dan wordt /var/cache/fontconfig niet opgekuist

- lijst van alle geinstalleerde fonts en hun padnamen
	$ fc-list | grep DejaVu
	>>>
		...
		/usr/share/fonts/truetype/dejavu/DejaVuSans-BoldOblique.ttf: DejaVu Sans:style=Bold Oblique
	<<<

- font bekijken op lettertypenaam (zoals getoond door fc-list)
	$ xfd -fa "DejaVu Sans:style=Oblique"
		- of elk van de andere stijlnamen die fc-list toont
	$ xfd -fn "Abadi MT Condensed"
		- gebruikt gewoon andere functiecall dan -fa, maar nog niet gevonden hoe ge hierbij bold of italic of zo opgeeft

- font bekijken op bestandsnaam, ook niet-geinstalleerd (o.a. .pfb en .ttf)
	$ display /home/dirk/.fonts/truetype/ATM4/ABAC.TTF
		- is progr. van ImageMagick
	OF met eigen proggie, b.v. font gedownload naar /media/ramdisk
	$ java  -Dsun.java2d.debugfonts=true -Dsun.java2d.fontpath=append:/media/ramdisk -jar ~/Documents/java/UTIL/Font2DTest.jar

- font alias bekijken voor een font (alleen bestandsnaam, geen pad), b.v.
	$ fc-match fixed
	>>> DejaVuSans.ttf: "DejaVu Sans" "Book" <<<
	$ fc-match monospaced
	>>> MONSPACN.TTF: "Monospaced" "Regular" <<<
	$ fc-match monospace
	>>> DejaVuSansMono.ttf: "DejaVu Sans Mono" "Book" <<<
	$ fc-match serif
	>>> DejaVuSerif.ttf: "DejaVu Serif" "Book" <<<
	$ fc-match sans
	>>> DejaVuSans.ttf: "DejaVu Sans" "Book" <<<

=== muisknoppen configureren ===

- zie "https://help.ubuntu.com/community/ManyButtonsMouseHowto"
- zie "https://help.ubuntu.com/community/MouseCustomizations"

- zoek de muis-id in
	$ xinput list
	- b.v. mijn Medion-muis is id=12

- achterhalen hoe de knoppen genummerd zijn, b.v. voor muis met id=12 :
	$ xinput test 12
	- elke muishandeling wordt nu getoond in terminal
	- b.v. knoppen Medion-muis (als linkshandig ingesteld) :
		1 : rechts
		2 : scrollwiel
		3 : links
		4 : scroll naar boven (geen release, alleen press, en ook neg. motion as 3)
		5 : scroll naar onder (geen release, alleen press, en ook neg. motion as 3)
		8 : zijknop links
		9 : zijknop rechts
		motion as 0 : naar links-rechts bewegen (altijd positief)
		motion as 1 : naar voren-achter bewegen (altijd positief)

- knoppen wisselel, b.v. :
	 $ xinput set-button-map 12 3 2 1 4 5 6 7 8 9

=== viewframe van rijksarchief maximaliseren ===
- viewer van search.arch.be is browser popup; om die te maximaliseren in zijn browservenster, in de url van de viewer voor het gedigitaliseerde document :
	- een blader-knop van de viewer naar het url-veld of de tab van de browser slepen
	OF (met de hand)
	- layout/lightbox/ tussenvoegen voor eadid/
	- achteraan de url de parameters ?layout=lightbox&tmpl=component toevoegen

=== x-progs configureren ===

- opties toevoegen aan ~/.Xresources (of dat bestand maken)
	- zie (https://www.oreilly.com/library/view/x-window-system/9780937175149/Chapter09.html)
	- voorbeelden in /etc/X11/app-defaults, /usr/share/X11/app-defaults, /usr/X11/lib/app-defaults, of ...
	- er staat al een ~/.Xdefaults, wschlk. beheerd door systeem, dus afblijven
	- configuratie-opties syntax : naam.Class.resource: waarde
		- naam is voor de programma's zelf de programmanaam, andere namen zijn ook mogelijk
		- resource-namen te vinden in resp. man-pages vam die progs
		- "naam." en of ".Class." kunnen vervangen worden door wildcard '*'
		- "naam" of "Class" kunnen vervangen worden door wildcard '?'
	- om die opties effectief te maken, d.w.z. in de X-server laden, zonder terug inoggen:
		$ xrdb -load ~/.Xdefaults && xrdb -merge ~/.Xresources
	- lettertypes: (moeilijk, niet mee knoeien)
		- prefix "x:" voor X11-fonts, te kiezen met b.v. xfontsel, vb:
			"xxx*font: -bitstream-bitstream charter-----normal--17-120-*-*-*-*-ascii-*"
		- default, of met optioneel prefix "xft:" voor ttf fonts, vb:
			"xxx*font: Anka/Coder Narrow
			- voor xterm en xman moet er een regular en een bold versie van zijn
		- xterm luistert naar resource "Xft.dpi: 96" (96 default; hoger = grotere letters)
			- xman niet
		- xterm kent zowel "x:"- als "xft:"-type fontresources ("xft:" is default en optioneel)
			- xman alleen gekende "x:"-fontresources

=== xterm gebruiken ===

- zie ook sectie "x-progs configureren"

- Cutting and pasting with Xterm
	- afh. van .XResource "xterm*selectToClipboard: " true of false wordt geselecteerde tekst in XA_CLIPBOARD of in XA_PRIMARY gezet; vanuit XA_PRIMARY kunt ge pasten met middelklik (of links+rechtsklik), vanuit XA_CLIPBOARD met Ctrl-V
		- xfce4-clipboard beheert enkel (geschiedenis van) XA_CLIPBOARD
		- van XA_PRIMARY naar XA_CLIPBOARD kan :
			$ xclip -o | xclip -selection clipboard
	- "Cutting text with xterm is pretty much the same as with gnome terminal. The difference being that any text you select, automatically gets placed into the [FOUT clipboard] PRIMARY."
		- Drag the mouse cursor along the text you wish to copy whilst holding down the LEFT mouse button.
		- double-clicking on a word will select that word (or if you’ve included my tweaks it’ll select a whole URL)
		- triple-clicking on a line will select that line
	- Pasting text is also pretty straightforward; just click the MIDDLE mouse button into an xterm window and the text in the clipboard will be pasted in.

- Scrolling using the mouse
	- met scrollwiel
	OF
	- klikken in scrollbalk:
		LEFT clicking on the scrollbar scrolls DOWN a bit
		MIDDLE clicking and HOLDING on the scrollbar drags the scroll window up and down
		RIGHT clicking scrolls UP a bit

=== reeks logs volgen ===
- volg met tail -F een reeks logs in kleine terminals, in meerdere rijen onder elkaar, 4 naast elkaar, geschikt :
	$ starty = 960; for log in *.log;do xfce4-terminal -T "${log:: -4}" --geometry=40x23+$((${log: -5:1}%4*300))+$(($starty+${log: -5:1}/4*480)) -x tail -F "$log" ;done
	- geometry afmeting in chars huidige font, positie in pixels
	- {log: -5:1} : in dit vb. zijn de logbestanden genummerd als *9.log, d.w.z. 1 cijfer op pos. 5 van het einde

== MOUNT  ==
ZIE OO: Filesystem Hierarchy Standard www.pathname.com/fhs/pub/fhs-2.3.html

- Een device zoals een schijf wordt voorgesteld door een bestand in /dev, b.v.:
	- /dev/sda voor HDD 0,
	- /dev/sda1 voor partitie 1 op HDD 0
	- /dev/nvme0n1 voor SSD 0
	- /dev/sr0 voor mijn DVD-lezer/schrijver
	- /dev/cdrom synoniem ('link') voor /dev/sr0
	- /dev/cdrw synoniem ('link') voor /dev/sr0
	- /dev/dvd synoniem ('link') voor /dev/sr0
	- /dev/dvdrw synoniem ('link') voor /dev/sr0

- Voor schijven is dat bestand een 'block device', te zien in b.v. detailweergave van filemanager Thunar, of met commando
	$ sudo lshw -c disk
Dat bestand kunnen we mounten of kopiëren ==>


=== unmount bij busy ===
	- b.v. fusermount: failed to unmount /media/ramdisk/nw: Device or resource busy
	- zoek open bestanden:
		$ lsof | grep "relevant deel van pad mountpoint"
		- geeft o.a. processen en process id die een bestand op dat pad open hebben
	- met nodige voorzicht en doorzicht die processen beëindigen (eerst natuurlijk zoeken of er nog ergens een terminal of toepassing openstaat voor dat proces);
	- enkel bij gebrek aan beter : kill of terminate proces in "Task Manager", of "$ kill procesnummer"

- zo veilig mogelijk alles unmounten :	zie sectie "Magic Alt Sysrq"

=== veilig verwijderen ===

- verwijderbare schijven/usb-sticks eerst unmounten, dan buffers wegschrijven, dan verwijderen
	$ sudo umount
	$ sync
	- verwijderen

- Thunar's eject zou sync moeten doen

=== readonly mounten mounten ===

- voor de veiligheid is het al eens nodig om read-only te mounten :
	# mount -o ro ...
	OF
	# mount -r ...
	-r, --read-only : Mount the filesystem read-only. A synonym is -o ro.

- als het bestandssysteem niet in orde is, wil hij echter dat op orde brengen, en dan zegt mount -r :
	>>> mount: /mnt: cannot mount ... read-only <<<
	- OPLOSSING :
		$ mount -o ro,norecovery ...

=== lijst van mounts: ===

- volledigste overzicht eerst:
	$ findmnt
	OF
	$ mount [-l]
	-l : toont filesystem labels (mits leestoegang)
	OF
	$ cat /etc/mtab
	- waarschijnlijk zelfde als "mount"
	OF
	$ lsblk
	- alle block devices met evt. mountpoint, geen tmpfs, loop device, fuse mount, ...

- welke bestanden/devices (zoals eigenlijke inhoud van een cd in een cd-device zoals /dev/cdrom) zijn verbonden aan loop device :
	$ losetup -l

- root krijgt meer te zien

=== mount point van een bestand ===
	$ stat -c %m -- bestand
	-c : custom format

=== is iets gemount op directory? ===
	$ mountpoint directory
	>>>
		directory is [not] a mountpoint
	<<<

=== bind mount ===

- met bind kunt ge een 2de directory-naam verbinden aan een 1ste directory-naam. De inhoud is zichtbaar op allebei, maar I/O gebeuren naar het bestandssysteem waarop de 1ste directory staat. B.v. tijdelijk opdrachten die naar/van een tmpfs zoals /media/ramdisk schrijven/lezen, eigenlijk laten schrijven/lezen naar een fysieke harde schijf :
	# mount -o bind /media/sdata/WERK/ramdiskOpHDD /media/ramdisk
		- maakt "/media/sdata/WERK/ramdiskOpHDD/" ook lees- en schrijfbaar via naam "/media/ramdisk/"
		- OPM: hetgeen al op /media/ramdisk stond, blijft daar (onbereikbaar) staan tot de bind verbroken wordt met umount;
	...
	# umount /media/ramdisk
	OF
	# umount /media/sdata/WERK/ramdiskOpHDD

- "-o rbind" i.p.v. "-o bind" om ook evt. bestaande of nieuwe mounts op subdirectories van de 1ste directory-naam ("/media/sdata/WERK/ramdiskOpHDD/" in het vb.) toegankelijk te maken via de 2de ("/media/ramdisk/")

=== tablet mounten als usb-schijf ===

- tablet aansluiten met usb-kabel en opstarten (om het even welke volgorde), zou vanzelf een toep. moeten opstarten om usb als opslag in te schakelen. Anders in Ubuntu terminal emulator:
	$ lsblk
	- laat de block-devices zien, met in de huidige configuratie 2 extra's: sdc (extsd van tablet) en sdd (interne sd van tablet)
	$ sudo mount /dev/sdc /mnt
	- zou nu read-write op /mnt moeten staan, anders 'mount -o remount,w ...'
	$ pkexec thunar
	- vermits de tablet geen 'dirk' heeft, alleen root

=== mount fat of ander oud bestandssysteem ===

- Dergelijke oude bestandssystemen hebben geen linux-stijl gebruikers-beveiliging; krijgen van mount de user en group van huidig process (bij mount dus root), en voor allen read, write en execute toestemming (chmod 777). Dat is onveilig, en kan ook lastig zijn bij kopiëren van bestanden naar een linux bestandssysteem (nemen die toegangsrechten mee). Daarom kan met b.v. mount en in fstab opgegeven worden welke gebruiker/groep eigenaar zijn van alle files en directories, en welke chmod-flags moeten worden uitgezet, b.v. uid=1000,gid=1000,fmask=113,dmask=002

=== ramdisk maken ===

	$ sudo mount -t tmpfs -o size=10M,user,exec,mode=777 tmpfs /mnt
	-t tmpfs : het moderne ramdisk systeem (bezet o.a. alleen geheugen wanneer nodig)
		- vervangt ramfs
	-o mode=777 : Set initial permissions of the root directory.
	-o [nr_inodes=10k] : expliciet aantal inodes om speciaal veel kleine of weinig grote bestanden te maken
	- tmpfs : dummy devicenaam, mag om het even wat zijn. Door findmnt getoond als SOURCE, door "mount" als "tmpfs on"
	[-o remount,size=100M] : kan zonder probleem vergroot worden met behoud van data

=== archief mounten (zie ook: bestand als virtuele schijf voorbereiden en mounten) ===

- archivemount installeren (USC)
	- mount via fuse (Filesystem in User SpacE), dus zonder sudo
	- leest om te mounten de volgende typen :
		- zip, tar, (tar.)gz, (tar.)bz2, (?tar.)compress, ustar, pax interchange, cpio
		- sommige, lang niet alle ISO9660 CD images (with or without RockRidge extensions)
	- schrijft (pas bij unmount) de gewijzigde bestanden terug naar een archief (originele hernoemd naar *.*.orig)
		- tar, (tar.)gz, (tar.)bz2
		- (?tar.) compress
		- andere formaten (b.v. zip) gewoon naar tar
	- voorlopig veiliger alternatief voor schrijven: unionfs (zit bij Xenial) :
		- !!! geany en zim schrijven niet naar bestaande bestanden in archivemount mountpoint, enkel naar nieuwe, maar doen alsof, zonder te (laten) weten dat het misloopt. Bij geany kan dit opgelost worden door in Preferences/Various "use_gio_unsafe_file_saving" uit te vinken.
			- mijn bugmelding : mail 19.02.2018 naar Andreas Landwehr (auteur archivemount)
			- mijn bugmelding : https://github.com/geany/geany/issues/1774
			- het loopt wschlk. mis doordat zowel "use_gio_unsafe_file_saving" als "use_atomic_file_saving" eerst schrijven naar een tijdelijk bestand (en dat lukt, in ), en als dat lukt, dat dan verplaatsen (mv, d.w.z. linux-rename inclusief pad) naar originele pad/bestandsnaam :
			>>> https://wiki.geany.org/config/all_you_never_wanted_to_know_about_file_saving
				Does not work on all file systems since rename or rename over an existing file is not supported on all file systems
			<<<

- mountpoint moet directory met schrijftoegang zijn, b.v. in ~ of op ramdisk
	- heb /media/zipmnt gemaakt, writable voor dirk, als standaard mountpoint voor archieven
	- indien mountpoint niet leeg (b.v. map met het archief zelf, en niets anders dat ge nodig hebt), mounten met "-o nonempty" :
		- originele inhoud is niet meer zichtbaar en dus ontoegankelijk
		- progs die een bestand in die directory al open hebben en houden, zoals b.v. archivemount zelf, houden wel hun toegang (tot dat open bestand)
		- kunnen dus archief van een directory in die directory zetten, en op die directory mounten alsof er niets gebeurd is

- mounten:
	$ mkdir /media/ramdisk/test && archivemount -o readonly /archief.tar.xz /media/ramdisk/test/
	- mount is default schrijfbaar, dan oppassen met grote archieven
	- herschrijven pas na unmount
	-o readonly : niet schrijfbaar
	-o subtree=pad/in/archief : vanaf daar pas te mounten, is altijd read-only
	-o uid=1000 :

- unmounten (en aanmaken van gewijzigd archief) :
	$ fusermount -u /media/ramdisk/test
	- "Before writing, the original archive is renamed with a '.orig' extension appended to it."
	- unmounten kan ook met umount, maar dan met sudo
	- fusermount zoekt info over de te unmounten mount in /etc/mtab

=== bestand als virtuele schijf voorbereiden en mounten ===

- bestand voorbereiden
	- ruimte maken, ofwel ineens op zijn plaats, ofwel als sparse (schijfblocks worden pas toegewezen als er een niet-0 naar geschreven wordt)
		OFWEL als SPARSE bestand met truncate
		$ truncate -s 8G bestand
			- Shrink or extend the size of each FILE to the specified size
			-s, --size=SIZE : units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).
			[-c, --no-create] : do not create any files
			[-r, --reference=RFILE] : base size on RFILE
		OFWEL als SPARSE bestand
		$ dd if=/dev/zero of=bestand bs=1024 seek=8M count=0
			- bs=1024 :  blocksize, zowel ibs (input) als obs (output)
				- OPGELET : zowel count als seek zijn in aantal blocks
			- seek=N : skip N obs-sized blocks at start of output; dus zo groot is het bestand al (maar sparse) voor count begint : bs=1024 x 8M = 8G
			- count=0 : schrijf 0 blocks
			- check plaatsbeslag :
				$ ls -ls bestand
					- in kB
				$ du bestand
					- in kB
				$ du -B 1 bestand
					- in bytes
		OFWEL niet-sparse (maar dan "mkfs -E nodiscard" om dat zo te houden)
		[$ dd if=/dev/zero of=bestand bs=1G count=10]
			- size en count in 'b' blocks van 512 bytes, 'c' 1-byte (char), 'w' 2-byte (word) of in 1024^n (K, M, G, ...; enkel k mag kleine letter)
			- beter grote bs en kleine count dan omgekeerd (b.v. bs=1 count=12G duurt eeuwen), maar (zeker voor /dev/zero) <= 1G (2G is te groot)
			>>>  info '(coreutils) dd invocation'
				The numeric-valued strings above (N and BYTES) can be followed by a multiplier: ‘b’=512, ‘c’=1, ‘w’=2, ‘xM’=M, or any of the standard block size suffixes like ‘k’=1024 (*note Block size::). Any block size you specify via ‘bs=’, ‘ibs=’, ‘obs=’, ‘cbs=’ should not be too large—values larger than a few megabytes are generally wasteful or (as in the gigabyte..exabyte case) downright counterproductive or error-inducing.
			<<<
	- bestandssysteem in maken
		- OFWEL gepartitioneerd
			- b.v. om te converteren naar virtuele schijf voor virtualbox
			- parted kan partitietabel direct in het bestand maken :
				# parted --script --align optimal bestand -- mklabel gpt mkpart mijnpartlabel ext4 0% 100% unit B print
				--script : na -- komt een hele reeks opdrachten, anders interactief (of via stdin)
				-- hierna komen de script-opdrachten, allemaal achter elkaar :
					- mklabel gpt :	maak gpt partitietabel
						alternatief : msdos e.a.
					- mkpart mijnpartlabel ext4 0% 100% :
						- mijnpartlabel :
							- met gpt-tabel : een partitielabel (=/= filesystem label)
							- met msdos-tabel : partitietype primary, logical of extended
						- ext4 : is maar een tag, moet nog "geformatteerd" worden (d.w.z. bestandssysteem maken)
							- alternatief : fat32, ...
						- 0% 100% : start en einde zonder risico om ons te misrekenen (parted is nogal een groffe opdracht, zou misschien voorbij bestandseinde kunnen schrijven)
							- alternatief : 4GB, -1s (in sectoren terugtellend van het einde, -1 is is exact laatste sector)
					- [name 1 mijnpartitielabel] : geef alsnog een partitielabel, nodig wanneer partitietabel =/= gpt, want dan hebben we partitietype nodig in mkpart-opdracht
						- 1 : partitienummer (telt vanaf 1)
					- [set 1 esp on] : zet flag om fat32 opstartpartitie voor EFI/ESP als dusdanig te markeren
						- 1 : partitienummer (telt vanaf 1)
					- [unit B] : gebruik 1 byte als eenheid voor volgende opdrachten
					- print : print de partitietabel
			- bestandssysteem maken :
				OFWEL direct in bestand, met offset zoals met de printopdracht van parted (zie hieronder "zonder partitietabel, direct in het bestand")
					- opgelet met eenheden offsets, hier is geen consistentie tss. programmas (1000^n =/= 1024^n, G, GB, GiB, ... en GB=/=GiB)
					- bestandssysteem mounten ook met offset
						# mount -o loop,offset=xxxxxxxx,...
				OFWEL via loopdevice, verbonden MET -P optie, en dan verder gewooon als voor device
					# losetup --show -Pf bestand
						>>> /dev/loop0 <<<
						--show  : toon de naam van loop-device waaraan "bestand" verbonden is
						-P, --partscan : Force the kernel to scan the partition table on a newly created loop device. Hiermee komt er ook /dev/loop#p# voor elke partitie in bestand :
							$ ls /dev/loop0*
							>>> /dev/loop0  /dev/loop0p1 <<<
						-f, --find : Find the first unused loop device. If a file argument is present, use the found device as loop device. Otherwise, just print its [first unused] name.
						[-o 2GiB] : offset in 1024^n (KiB, MiB, ...) of in 1000^n (KB, MB,...)
					- controle :
						$ lsblk
						- met losetup zonder optie -P komen partities niet in lsblk
					# mkfs.ext4 -L mijnfslabel /dev/loop0p1
						- e.a. opties
					# mount [opties] /dev/loop0p1 /mnt
					# umount /mnt
					# losetup -d /dev/loop0
						- als mount zelf loop-device zoekt voor bestand en ermee verbindt, dan koppelt umount de 2 ook los; maar als we zelf bestand verbinden met loop-device, moeten we ook zelf loskoppelen
			- converteren naar VirtualBox vdi-bestand :
				$ vboxmanage convertfromraw bestand bestand.vdi --format vdi
		- OFWEL direct in het bestand
			- voor eigen gebruik, zonder partitietabel is het gemakkelijker te mounten
			- niet nodig om bestand aan /dev/loop# te binden met losetup: direct naar bestand gaat ook (geen vergissingen met /dev/loop nr.; mkfs naar device vraagt sudo, naar eigen bestand niet)
			- ext4
				$ mkfs.ext4 [opties] bestand
					- bereidt ext4 bestandssysteem voor
					- defaults: zie 'cat /etc/mke2fs.conf'
					- andere geïnstalleerde bestandsystemen : zie
						$ cat /proc/filesystems
						- ext2 om zonder verdere opties
							- journaling-overhead van ext3 en ext4 te vermijden
							-  kleinere (128byte) inodes te gebruiken
						- ext3 : geen bijzondere voordelen t.o.v. ext4 (zie http://www.golinuxhub.com/2014/03/what-is-difference-between-ext3-and.html)
						- ext4 is efficienter met grote bestanden :
							- Multiblock Allocator
							- 'extent' is range blocks dat aan bestand toegewezen is, i.p.v. zoals ext3 elk toegewezen block apart in een index bij te houden
					- maakt zonder opties niet-sparse bestand sparse
						[-E nodiscard] : Do not attempt to discard blocks at mkfs time (default is discard)
				- voorbeeld :
					$ mkfs.ext4 -I 128 -N 1048576 -m 0 -L label -O ^huge_file bestand
					>>>
						mke2fs 1.42.13 (17-May-2015)
						Discarding device blocks: done
						Creating filesystem with 2097151 4k blocks and 1048576 inodes
						Filesystem UUID: a0a5c864-9000-4a89-9446-9636e46e6392
						Superblock backups stored on blocks:
							32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632
						Allocating group tables: done
						Writing inode tables: done
						Creating journal (1024 blocks): done
						Writing superblocks and filesystem accounting information: done
					<<<
					[-E optie,optie,...] : extended opties, komma-gescheiden, zoals
						[-E ...,root_owner[=uid:gid]] : Specify the numeric user and group ID of the root directory. If no UID:GID is specified, use the user and  group ID of the user running mke2fs
							- best nakijken bij gebruik, desnoods mounten en na geslaagde mount chown op mountpoint doen, dat werkt zeker (enkel bij geslaagde, anders werkt chown op mountpoint zelf)
						[-E ...,nodiscard] : om virtueel schijfbestand NIET SPARSE te maken, discard is default
						[-E ...,offset=4294967296] : offset van 4GB vanaf start van device of bestand
							- OPGELET : in tegenstelling tot mount en losetup, aanvaardt mkfs.ext4 geen k,m,g of K,G,M suffix voor offset)
							- mke2fs maakt het bestandssysteem %filesize% groot vanaf offset
							>>> man mkfs.ext4
								If fs-size is omitted, mke2fs will create the file system based on the device size.
							<<<
								maar neemt hele huidige grootte van "bestand" in rekening; mkfs doet dan bestand met offset groeien, waardoor deze bug onschadelijk is
							- dienstig voor virtual machine administratie, of om b.v ruimte voor andere partitie of partitietabel o.i.d. te laten.
					[-I 128] : kleinst toegelaten inode-size (moet 2^n zijn), default 256
					-N 1048576 : aantal inodes (is ruwweg max. aantal bestanden en directories op filesysteem)
					[-m 0\ : percentage aantal blocken die gereserveerd moeten worden voor root en systeemutilities (zie ook "tune2fs -r 999" voor exact aantal gereserveerde blocks)
					[-L label] : volume label voor file system
					-O ^huge_file : geen (de '^') bestanden > 2TB
					[-O ^has_journal] geen journal
					[-J size=4] : journaalgroottte in MB (min. blocksize * 1024, typisch 32k blokken)
						- OPGELET : klein journal maakt filesystem zeer traag (zelfs met "mount -o data=writeback") met b.v. cryfs, dat veel metadata maakt omdat het data verspreidt over veel directories en bestanden
				- achteraf label geven :
					# tune2fs -L mijnlabel bestand
					- werkt niet met offset; misschien (read-only?) mounten en i.p.v. op bestand uitvoeren op juiste /dev/loop#
			- ntfs:
				- mkfs.ntfs == mkntfs
				- kent geen offset, dus voor virtuele schijf met losetup en offset aan /dev/loopX binden
				- kan voor bestandssysteem in regulier bestand geen sectorgrootte, sectors per trac en aantal heads afleiden van de hardware, moeten dus expliciet opgegeven worden, b.v.
					# mkfs.ntfs -vFfITc 4096 -s 4096 -H 1 -S 1 -p 0 -L mijnlabel /dev/loop#
					OF
					$ mkfs.ntfs -vFfITc 4096 -s 4096 -H 1 -S 1 -p 0 -L mijnlabel imagebestand
					-v : verbose
					-F : force (nodig omdat bestand zelf geen block device is)
					-f : fast, initialiseert sectors niet met zeroes
					-I, --no-indexing : Disable content indexing on the volume
					[-T, --zero-time] : Fake the time to be 00:00:00 UTC, Jan 1, 1970 instead of the current system time.
					-c 4096 : clustersize (zal wel best == hardware cluster size zijn)
					-s 4096 : sector size ("")
					-H 1 : 1 head
					-S 1 : 1 sector per track
					-p 0 : partition start in sector 0 (nodig omdat we geen partitietabel hebben)
						- OPM: is me nog niet gelukt om -p > 0 te doen werken als offset in imagebestand met b.v. meer dan 1 partitie. In dat geval misschien gewoon elke partitie met -p 0 aanmaken, en dan aaneen plakken; zie ook sectie "bestanden sparse concateneren". Mount met offset werkt in ieder geval goed
					-L label

- mounten
	- NA MOUNTEN 1ste keer :
		- vuilbak voorbereiden
			- op FUSE bestandssystemen onderstaande gewoon als user uitvoeren, zelfs root heeft hier geen toegang toe, dus vuilbak voor alleen user zelf volstaat; t.b.v. sommige programmas ook als .Trash-1000 (link)
			$ mkdir /mnt/.Trash /mnt/.Trash/1000
			$ chmod +t /mnt/.Trash
			$ ln -sr /mnt/.Trash/1000 /mnt/.Trash-1000
	# mount -o optie,optie,... bestand /mnt
		- opties :
			exec : Permit execution of binaries under mountpoint
			noatime : geen accesstimes schrijven voor elke bestandstoegang, minder risico op verneuken
			ro : readonly
			norecovery of noload : Don't load the journal on mounting (en dus GEEN HERSTEL van evt. fouten)
			data={journal|ordered*|writeback} : metadata is always journaled, data als volgt :
				- journal : data to journal, then to file system
				- ordered : data directly to file system, then it's metadata to the journal
				- writeback : data may be written to filesystem after it's metadata committed to journal (rumoured as highest-throughput). Bewaart integriteit filesystem op zich, maar na crash + recovery uit journal kunnen de oude data nog in gecrasht bestand staan
			offset=4G : geeft offset door naar impliciete 'losetup'
			- suffix K,M,G of k,m,g voor 1024^n, suffix KB,MB,GB voor 1000^n
			loop : meestal impliciet, doet "losetup -f bestand" (find een /dev/loop#), en mount /dev/loop# op mnt
	# umount /mnt
		- doet impliciete "losetup -d /dev/loop#"

- sparse bestand kopiëren
	- zie ook sectie "bestanden sparse concateneren"
	- werkt zowel voor sparse bronbestand, als voor niet-sparse bronbestand met 0-blocks
	OFWEL
	$ rsync -S bronbestand sparsebestand
		-S, --sparse : handle sparse files efficiently
		- kan ineens voor directories gebruikt worden :
			$ rsync -rS bronmap doelmap
			- OPGELET: bronmap zonder eind-'/'
	OFWEL
	$ dd conv=sparse if=bronbestand of=sparsebestand
		- zou snelste zijn op locale machine
		- enkel bestand per bestand
		- OPGELET: met expliciete blocksize bekijkt "dd" het sparse-zijn per die blocksize, niet per block van het bestandssysteem
		- HEEFT KUREN bij append
	OFWEL
	$ cp --sparse=always bronbestand sparsebestand
		- OPGELET: zou niet altijd de juiste blocksize gebruiken voor het doel-bestandssysteem, en bekijkt dan zoals "dd" het sparse-zijn per die blocksize, niet per block van het bestandssysteem

- bestanden verwijderen voor sparse virtuele schijf
	- OPGELET : shred is nutteloos op ext3 of ext4 met data=journal mode (is gelukkig niet de default)
	- Fast shredding by overwriting everything with 0s in a single iteration
		$ shred -zn 0 --remove=wipe bestand
		--remove[=HOW] : truncate and remove file after overwriting
			=unlink : standard unlink call
			=wipe : also first  obfuscate bytes in the name.
			=wipesync : (default) wipe, and also sync each obfuscated byte to disk; can be expensive.
		-z, --zero : add a final overwrite with zeros to hide shredding
		-n, --iterations=N : overwrite N times with random values instead of the default (3)
	- Secure shredding using 3 iterations with random numbers and a last one writing 0-s
		$ shred -z -u  bestand

- ongebruikte ruimte vrij maken (kopiëren als sparse)
	OFWEL
	0 ongebruikte bytes op 0 zetten :
		- filsys MOET GEMOUNT, op b.v. /mnt
		[# mount bestand /mnt]
		$ dd if=/dev/zero of=/mnt/nullen
		- disadvantage of dd in this context is that it destroys any sparseness that exists: free blocks that were originally represented as holes in the image file are replaced with actual blocks containing zeroes (NIET in VBox, die 0-blocks in virtuele schijf effectief NIET naar fysieke schijf schrijft)
		$ sync /mnt/nullen
		- sync zorgt dat de geschreven nullen effectief op de schijf gezet worden, vooraleer we met de volgende opdracht (rm) zeggen dat dit niet meer nodig is
		$ rm /mnt/nullen
	OFWEL
	- alleen ongebruikte blocks die niet-0 bevatten, op 0 zetten :
		- filesys NIET of RO gemount, moet wel aan /dev/loop# hangen (b.v. door dus RO te mounten)
			OFWEL
			# losetup -f --show bestand
				>>> /dev/loop#
				- b.v. /dev/loop0
				-f, --find : Find the first unused loop device. If a file argument is present, use the found device as loop device. Otherwise, just print its name.
				--show : Display the name of the assigned loop device if the -f option and a file argument are present
				[-o, --offset offset] : 999K,M,G, ... offset bestandssysteem vanaf begin bestand, in 1024^n (KB,MB, ... voor 1000^n), t.b.v. b.v. partitietabel, andere partities, en VM-beheer
			OFWEL (WERKT NIET voor zerofree)
			# mount -o ro bestand /mnt
			- check aan welk loopdevice bestand verbonden is :
			$ losetup -l
			- maak ongebruikte blokken 0
		- voor de zekerheid bestandssysteem controleren, voor en na
			OFWEL voor ext2, ext3, ext4
			# e2fsck -nfC 0 /dev/loop#
				-f : force checking even if clean
				-n : Open the filesystem read-only, and assume an answer of `no' to all questions
				-C fd : If the file descriptor specified is 0, e2fsck will print a completion bar as it goes about its business.
			OFWEL voor alle ondersteunde bestandssystemen, op loop-device
			- OPM: options to filesystem-specific fsck's are not standardized; the following options are supported by most filesystem checkers:
			# fsck -nC /dev/loop#
				-n : (for some filesystem-specific checkers only) avoid attempting to repair any problems, but simply report such problems to stdout
				-C [fd] : Display completion/progress bars; neemt optioneel file descriptor argument, moet dus laatste optie in een "-opq..." optiestring zijn
				[-r [fd]] : Report certain statistics for fsck when it completes; opgelet, dubbelt met fs-specifieke optie -r : interactive
				- doel-argument fsck kan device name, mount point, ext2 label of UUID specifier zijn
			OFWEL voor alle ondersteunde bestandssystemen, op mountpoint
			- werkt niet met offset in b.v virtual disk van een VM, of partitie in een meer-partitie virtual disk
			# fsck -nC /mnt
		- ongebruikte blokken met 0 overschrijven als ze nog niet 0 zijn
			# zerofree /dev/loop#
			- finds  the unallocated, blocks with non-zero value content in an ext2, ext3 or ext4 filesystem (e.g. /dev/hda1) and fills  them  with zeroes (or another octet of your choice).
			[-n] : Perform a dry run  (do not modify the file-system)
			[-v] : verbose; show the number of blocks (-n : that would be) modified by zerofree, the number of free blocks and the total number of blocks on the filesystem
		- nog eens controleren
			# fsck -rC /dev/loop#
	- filesys loskoppelem van /dev/loop#
		OFWEL (naargelang de hierboven gebruikte methode)
		# losetup -d /dev/loop#
		OFWEL
		# umount /mnt
	- sparse maken of blocks met enkel 0 dealloceren (op NIET GEMOUNT fs)
		OFWEL inline
			$ fallocate -vd bestand
				-d, --dig-holes : Detect and dig holes. Makes sparse in-place. Minimum size of hole depends on fs block size.
				[-v, --verbose] : Enable verbose mode
				- al tegengekomen dat fallocate rapporteert dat gaten gemaakt zijn, zonder dat disk usage verandert.
				- Supported for  XFS, ext4, Btrfs and tmpfs
		OFWEL dupliceren naar nieuw, sparse, bestand (zie "sparse bestand kopiëren" hierboven)
			$ rsync -S bestand bestandNEW
			OF
			$ cp --sparse=always bestand bestandNEW

- tussen het bestand en de /dev/loop? (of tussen de /dev/loop? en de mount??) kunnen nog filters gezet worden, b.v. compressie

=== Virtualbox Virtual Drive mounten in Linux ===

- ZIE _VirtualBox.adoc

=== UEFI-bootable usb-stick maken van UEFI-bootable iso (live cd) ===
	- met b.v. gparted USB-stick formatteren in FAT32, flags eps en boot
	# mount cd.iso /cdrom
	# mount /dev/s%USBSTICK% /mnt
	# rsync -rltD -AXxiv /cdrom/ /mnt/
	-rltD : -a --no-o --no-g --no-p, want FAT/NTFS kent geen linux -o (owner), -g (group) of -p (permissions), zouden fouten geven

== CD-DVD ==

=== toegang krijgen tot de bestanden van een cd of dvd, via de standaardmap /cdrom of een andere map (die moet bestaan) ===
	. nu geconfigureerd om cds en dvds automatisch te mounten naar een automatisch aangemaakte map in /media/dirk
kort	$ sudo mount /dev/sr0 /cdrom
voll.	$ sudo mount -o loop,ro /dev/sr0 /cdrom
	- optie "ro" om read-only te mounten; wordt zonder "ro" ook read-only gemount, maar met waarschuwing
	- optie "loop" is kort voor "loop=/dev/loop0", waarbij 0 automatisch gekozen wordt uit de vrije /dev/loop*-devices: de image-file wordt geassocieerd met het device dev/loop0, en dat device wordt dan gemount; mount blijkt ook te werken zonder de optie loop

=== image mounten naar b.v. de gebruikelijke map /cdrom in het file system ===

- kort
	$ sudo mount bronpad/cdimage.iso /cdrom
- volledig
	$ sudo mount -o loop,ro ...

=== image maken van (bootable of niet) cd of dvd ===

- moet misschien gemount zijn, maar ik denk het niet

	$ dd if=/dev/sr0 of=doelpad/cdimage.iso bs=2K
	- de blocksize bs=2K of bs=2048 is waarschijnlijk niet nodig, maar komt overeen met de data-inhoud van 1 mode-1-cd-sector, zal dus sneller gaan; mode-2 cds hebben 2336 bytes per sector
	- if=/dev/cdrom e.a. synoniemen werkt ook

=== algemene image of dvd-video image maken van directory ===

	$ genisoimage -V LABEL -lJr -iso-level 3 -o output_image.iso bronpad [bronmap2]...
		-V : max. 32 chars
		-l : Allow  full 31-character filenames (mag van iso9660, alleen MS-DOS houdt het bij 8.3)
		-J : Generate Joliet directory records (o.a. 64-char unicode namen) in addition to regular ISO9660 filenames.
		-r : Rockridge extensions, sterk aanbevolen voor Joliet
			- is ook nodig om meer dan 6 directories diep te gaan
		- bronpad# : inhoud van elk komt in de root van de iso
		-iso-level 3 : Set the ISO9660 conformance level. Valid numbers are 1 to 4.
			- With level 1, files may only consist of one section and filenames are restricted to 8.3 characters.
			- With level 2, files may only consist of one section.
			- With level 3, no restrictions (other than ISO-9660:1988) do apply.
			- With  all ISO9660 levels from 1 to 3, all filenames are restricted to uppercase letters, numbers and underscores. Filenames are limited to 31 characters, directory nesting is limited to 8 levels, and pathnames are limited to 255 characters.
			- Level 4 : not official, genisoimage maps it to ISO-9660:1999, which is ISO9660 version 2. An enhanced volume descriptor with version number and file structure version number set to 2 is emitted. Directory nesting is not limited to 8 levels, there is no need for a file to contain a dot and the dot has no special meaning, filenames do not have version numbers, and filenames can be up to 207 characters long, or 197 characters if Rock Ridge is used.
		[-f] : Follow symbolic links when generating the filesystem. When this option is not in use, symbolic links will be entered using Rock Ridge if enabled, otherwise they will be ignored.
		[-m] shell-wildcard-pattern : exclude files volgens pattern
			- tussen "", voorkomt shell globbing
			- met wildcard : toegepast op volledig bronpad
			- zonder wild card : toegepast op naam van file of directory
			- mag herhaald, b.v. -m "*.bak" m "/mnt/overbodig*"
		[-no-bak] : Exclude  backup files files on the ISO9660 filesystem; that is, filenames that contain the characters `~' or `#' or end in .bak. These are typically backup files for Unix text editors.
		[-dvd-video] : Generate a DVD-Video compliant UDF filesystem. This is done by sorting the order of the content of the appropriate files and by adding padding between the files if needed. Note that the sorting only works if the DVD-Video filenames include uppercase characters only. Note that in order to get a DVD-Video compliant filesystem image, you need to prepare a DVD-Video compliant directory tree. This requires a directory VIDEO_TS (all caps) in the root directory of the resulting DVD, and usually another directory AUDIO_TS. VIDEO_TS needs to include all needed files (filenames must be all caps) for a compliant DVD-Video filesystem.
	- minimale ISO, maar met alle tekststrings zelfgekozen, en sparse :
		$ cp --sparse=always <(genisoimage -iso-level 1 -no-pad -sysid "32char system" -V "128char volname" -volset "128 char volume set" -publisher "128char publisher" -p "128char preparer" -A "128char application" -copyright "37char copyright filename" -abstract "37char abstract filename" -biblio "37char bibliographic filename" BESTAND8.3... ) sparse.iso
		- offsets: (zie https://wiki.osdev.org/ISO_9660) (zie "DOCS/_Info/Programmeren/file formats/ISO cd image iso9660.pdf" blz. 44)
			- 0x0000-0x7FFF zeroes
			- 0x8000 1ste volume descriptor (0x01 "CD001" 0x0100) met de strings (alle uitgevuld met spaties)
				- voor de meeste van deze velden heeft genisoimage een default, b.v. "LINUX" voor system
				- 0x8008 "32char system"
				- 0x8028 "32char volname"
				- 0x8048 binair directory record for root directory
				- 0x80BE "128char volume set"
				- 0x813E "128char publisher"
				- 0x81BE "128char preparer"
				- 0x823E "128char application"
				- 0x82BE "37char copyright filename" (in root directory)
				- 0x82E3 "37char abstract filename" (in root directory)
				- 0x8308 "37char bibliographic filename" (in root directory)
				- 0x832D 70 bytes: 4 ASCII tijdstamps in decimale notatie, met binaire data tussen en na :
					- volume creation
					- volume modification
					- volume expiration
					- volume effective
				>>>
					Offset 	Size 	Datatype 	Description
					0 	4 	strD 	Year from 1 to 9999.
					4 	2 	strD 	Month from 1 to 12.
					6 	2 	strD 	Day from 1 to 31.
					8 	2 	strD 	Hour from 0 to 23.
					10 	2 	strD 	Minute from 0 to 59.
					12 	2 	strD 	Second from 0 to 59.
					14 	2 	strD 	Hundredths of a second from 0 to 99.
					16 	1 	int8 	Time zone offset from GMT in 15 minute intervals, starting at interval -48 (west) and running up to interval 52 (east). So value 0 indicates interval -48 which equals GMT-12 hours, and value 100 indicates interval 52 which equals GMT+13 hours.
				<<<
				- 0x8373 512char Application Used Contents, not defined by ISO 9660
				- 0x8570 reserved (653 zeroes, tot 0x8800)
			- 0x8800 afsluitende volume descriptor (0xFF "CD001" en zeroes)
			- 0xB800 dirstructuur (tot 47 bestanden per 0x800 byte)
			- 0xC000 1ste bestand
				- lege bestanden hebben alleen een dir entry, geen bestandssector
				- offset met enkel root dir, met <= 47 bestanden

=== (X)Ubuntu Live CD uitpakken naar schijf of usb-stick ===

- OPGELET: /dev/sd## vervangen door JUISTE devicenaam van de met gparted als FAT32-geformateerde en als boot,esp ge-flagde usb-stick (b.v. /dev/sdc) of (NOG NIET GEPROBEERD) de devicenaam van de 1ste FAT32-partitie van een schijf (b.v. /dev/sdb1):
	0$ sudo dd if=/path-to-xubuntu-live-cd.iso of=/dev/sd## bs=4M; sync
	- OPM: mijn methode werkt ook:
	. Xubuntu Live CD ISO gemount naar /mnt
	. /mnt gekopieerd naar 1ste (FAT32) partitie van interne schijf of USB schijf/stick. Die was vanuit XUbuntu met gparted-flags gemerkt als boot,esp (EFI system partition), wat misschien nodig is om hem in UEFI boot override te krijgen, maar dat heb ik niet getest.
		$ cd /mnt
		$ rsync -a . /media/doelschijf
			- OPM: duurt een tijdje, want casper/filesystem.squashfs is 1GB groot
			- OPM: FAT32 ondersteunt geen symbolic links, dus daar komen een paar foutmeldingen over:
				rsync: symlink "/media/dirk/2GB/ubuntu" -> "." failed: Operation not permitted (1)
				rsync: symlink "/media/dirk/2GB/dists/stable" -> "xenial" failed: Operation not permitted (1)
				rsync: symlink "/media/dirk/2GB/dists/unstable" -> "xenial" failed: Operation not permitted (1)
	. terminal geopend op de kopie, en gecheckt met
		$ cd /media/doelschijf
		$ md5sum -c md5sum.txt
			OPM: geeft lange lijst met OKs, en als laatste lijn nog een WARNING als er een fout tussen zat, dus ge moet niet die hele lijst overlopen

== LIJST-OPDRACHTEN ==

- wildcard voor shell globbing NOOIT beginnen met * (want dan wordt bestand dat met - begint, b.v. "-R", als optie beschouwd, dikwijls "recursive") :
	./* : veel beter

- In all shells, globs are sorted by default

=== opdrachten ===
	$ info

=== mappen en bestanden ===
	$ ls
	- detail: -l
	- ook verborgen: -a
	- wildcard * matcht geen '/', */* wel (maar ook maar juist dat: 1 niveau van subdir)
	- alle submappen : wildcard ** als globstar opstaat (shopt -s globstar)

=== mappen en bestanden in volgorde van tijd ===
	$ find -printf "%TY-%Tm-%Td %TT %p\n" | sort -n

=== mounts ===
	OFWEL
	$ findmnt
	OFWEL
	$ mount

=== ruimtegebruik en vrije ruimte op gemounte bestandssystemen ===
	$ df -k [file]
	- "disk free" : report file system disk space usage
	[file] report file system disk space usage for file systems containing file arguments
	-k : == -BK
	-Bx : blocksize, x=K, M, G, T kilo, mega, ... (2^n), x=KB, MB, ... (10^3n)
	-h : variable blocksize 2^n
	-H : variable blocksize 10^3n

=== block devices ===
	$ lsblk

=== uuid van block devices en partities ===
	# blkid

=== hardware ===
	# lshw
	- alleen van class disk: -c disk (andere classes o.a. bridge, bus, communication, disk, display, generic, input, memory, multimedia, network, power, processor, storage, system, volume, alle vinden met -short)

=== pci-bus en devices (o.a. voor VirtualBox PCI passthrough) ===
	$ lspci

=== logins ===
	$ lslogins
		  UID USER              PROC PWD-LOCK PWD-DENY  LAST-LOGIN GECOS
			0 root               177                   nov21/15:45 root
			1 daemon               0                               daemon
			2 bin                  0                               bin
			3 sys                  0                               sys
		...
		  120 guest-tHmpt3         0                               Guest,,,
		  121 _apt                 0
		 1000 dirk                66                      09:02:10 Dirk,,,
		65534 nobody               1                               nobody

=== gebruikers en groepen ===
	$ users
	- print the user names of users currently logged in to the current host
	$ groups [username]
	- print the groups a user is in

=== gedefiniëerde aliassen ===
	$ alias

=== open bestanden ===
	$ lsof | grep gezochtbestand

=== programma's in uitvoering ===

- enkel op programmanaam
	- OPGELET: voor scripts die uitgevoerd worden als 'bash script ...' is de programmanaam 'bash'
	$ pgrep "pattern"
	- pattern : regexp, default is om case sensitive te matchen op process naam
	[-i, --ignore-case] : Match processes case-insensitively.
	[-f, --full] : match pattern against full command line
	[-x, --exact] : Only match processes whose names (or command line if -f is specified) exactly match the pattern. (zoals "^pattern$")
	[-U, --uid uid,...] : Only match processes whose real user ID matches (numerical or symbolical value)
	[ -d, --delimiter delimiter] : set string to delimit each process ID in the output (by default a newline)
		- b.v. -d, om csv-lijst te krijgen, b.v. voor
			$ top -p$(pgrep -d, pattern)
	[-l, --list-name] : List the process name as well as the process ID.
	[-a, --list-full] : List the full command line and process ID (anders alleen process ID)
	[-c, --count] : Suppress normal output; instead print a count of matching processes. When count does not match anything, e.g. returns zero, the command will return non-zero value.

- op hele opdracht (nuttig voor o.a. "bash script ...")
	$ pgrep -fa ".*naarh264.*"
	>>>5845 bash /media/ramdisk/naarh264.sh ./viv.15.12.02.mango.a.and.talia.mint.auspice.mp4
	-f, --full : The pattern is matched against the full command line

=== file attributes (nog iets anders dan chmod access mode) ===
	$ lsattr
	append only (a), no atime updates (A), compressed (c), no copy on write (C), no dump (d), synchronous directory updates (D), extent format (e), compression error (E), huge file (h), immutable (i), indexed directory (I), data journalling (j), inline data (N), secure deletion (s), synchronous updates (S), no tail-merging (t), top of directory hierarchy (T), undeletable (u), compression raw access (X), compressed dirty file (Z).

=== andere ls-opdrachten ===
- lsb_release, lscpu, lsipc, lspcmcia, lsusb, lsdiff, lsinitramfs, lslocks, lsmod, lspgpot

=== list filesystems supported by currently running Linux kernel ===
	$ cat /proc/filesystems
	>>> 2018/03/10
		nodev	sysfs
		nodev	rootfs
		nodev	ramfs
		nodev	bdev
		nodev	proc
		nodev	cpuset
		nodev	cgroup
		nodev	tmpfs
		nodev	devtmpfs
		nodev	debugfs
		nodev	tracefs
		nodev	securityfs
		nodev	sockfs
		nodev	bpf
		nodev	pipefs
		nodev	devpts
				ext3
				ext2
				ext4
				squashfs
		nodev	hugetlbfs
				vfat
		nodev	ecryptfs
				fuseblk
		nodev	fuse
		nodev	fusectl
		nodev	pstore
		nodev	efivarfs
		nodev	mqueue
		nodev	autofs
		nodev	binfmt_misc
	<<<
	- bevat niet (noodzakelijk) geinstalleerde fuse bestandssystemen

=== list all executable files installed by given package ===

	$ dpkg-query -L packagename | xargs file | grep executable
	OF
	$ dpkg -L packagename | xargs file | grep executable
	-L, --listfiles package-name... : List files installed to your system from package-name.

-If you want to only see executables installed in /usr/bin, use:
	$ dpkg-query -L packagename | xargs file | grep ^/usr/bin | grep executable

=== zoek bestanden en directories ===

- zie ook sectie "opdracht uitvoeren op alle bestanden van een directory tree"

	OFWEL
	$ find [bronpad] [selectie]...
	[bronpad] : default ".", is letterlijke prefix van elke bestandsnaam in resultaat
	[selectie] :
		-type x : f=bestanden, l=symlinks, d=directories
		-[i]name "*pattern*" : pattern IN QUOTES, anders shell globbing t.o.v. current working directory
			[i] : case insensitive
		-[i]path "*pattern*"
		-[i]lname  "*pattern*" : bestand is symbolic link, met doel volgens pattern
		-regextype posix-extended : default is gnu-emacs, geen zin om die ook te leren
		-[i]regex "pattern" : wordt toegepast op heel pad, en moet helemaal matchen, dus meestal beginnen met ".*" (niettegenstaande een opmerking in "info find" dat '^' en '$' begin- en einde van een string aanduiden)
			- vb. reeks extensies matchen :
				-regextype posix-extended -iregex ".*\.(par[^\./]*|md5|sfv|ffp|sha[^./]*)"
		-maxdepth 2 : max. 2 niveaus onder brondirectory
		[-mount] of [-xdev] : niet over mount grenzen
		-executable
		-size [+,-]235[bckMG] : b: blocks van 512 (default), c: bytes, kMG : kilo,Mega,Gigabytes
		...
	OFWEL (vanuit root of elders waar ge niet in alle directories kunt)
	$ find / ! -readable -prune -o [selectie]... -print
	-readable -prune : als het bestand of de directory niet leesbaar is: niet in afdalen, zodat ge geen lange lijst foutboodschappen 'permission denied' krijgt
	-o : OR, gevolgd door de eigenlijke selectie
	-print : omdat we voor 1ste lid van de OR expliciet -prune doen, moeten we voor het 2de lid ook expliciet zeggen wat er moet gebeuren

- negatieve zoek : zie sectie "opdracht uitvoeren op alle bestanden van een directory tree" subsectie "vb. 11 bestanden zoeken met uitsluiting van bepaalde suffixen"

==== zoek alle TTC cursussen zonder guidebook ====

$ find . /media/sdata/WERK/ -type d -name "TTC *" -and -not -name "*guidebook*" -and -not -name "*workbook*" -printf "%f\n"|sort

=== tel aantal bestanden dat aan criteria voldoet, b.v. aantal .cue-bestanden ===
	 $ find -iname '*.cue' | wc -l
	 - wc -l : 'word count' aantal lijnen

=== verbroken links vinden ===
	$ find . -xtype l
	- xtype volgt links als ze bestaan, en test dan het type van het resultaat (file, directory, socket, link, ...); als een link (evt. in een reeks) verbroken is, is het ultieme xtype die verbroken link zelf

=== recent geopende bestanden (over alle progs) ===
	/home/dirk/.local/share/recently-used.xbel

=== dubbele bestanden ===
	$ fdupes -ro path [pad1]...
	-r : recursive
	-o path : binnen duplicate-groep sorteren op volledig pad

=== hernoemde bestanden gelijk hernoemen op backupschijf ===

- met mijn eigen fdupes-versie, die opties omit first, sort, move en regex heeft
	$ ~/Documents/c/fdupes-master/fdupes -u -NrMo arg [-g "//pattern"] /media/sdata/ebooks "$bupschijf"/ebooks
	-u --simulate : run through the program without changing a thing.
	-N --noprompt : when used together with --delete or --rename, preserve the first file in each set of duplicates and delete or rename the others without prompting the user
	-r --recurse
	-M --move : prompt user for files to preserve, and move+rename all others like the first of these (tail of path following directory argument), on the same filesystem
		- OPM: sorteer hiervoor op volgorde argument, met 'bron'-schijf' eerst (en zo mogelijk vrij van dubbels: anders voor elke dubbel "requested new name in use!", en niet te voorspellen welk van de dubbels als basis wordt gebruikt voor de gelijke bestanden in de andere argumenten)
	-o --order=WORD : order files according to WORD: time - sort by modification time (default), ctime - sort by status change time, path - sort by full path, arg - sort by directory argument number, name - sort by filename. Append '-' to the sort key (like name-) to reverse order
	[-g --regex=pattern] : test only files matching a Posix.2 extended regular expressions pattern. The pattern is matched against the full file path when reaching that file, not against the directories while recursing through them. As a custom extension, start a pattern with '//' to match the remainder of that pattern against the filename only (last part of path)
	[-G --reGex=pattern] : case-insensitive regex, further as above

== INFORMATIE ZOEKEN ==

=== uid en gid van een gebruiker ===
- van huidige of genoemde gebruiker :
	$ id -u [gebruikersnaam]
	>>> 1000 <<<
		-u : alleen user id
	$ id [gebruikersnaam]
	>>> uid=1000(dirk) gid=1000(dirk) groups=1000(dirk),4(adm),24(cdrom),27(sudo),29(audio),30(dip),44(video),46(plugdev),113(lpadmin),120(scanner),128(sambashare),130(vboxusers),132(xpra) <<<
	- standaard/1ste gebruiker is meestal uid=1000,gid=1000 (o.a. in Ubuntu)

	$ id root
	>>> uid=0(root) gid=0(root) groups=0(root)
	- root is meestal uid=0,gid=0 (o.a. in Ubuntu en systemrescuecd), maar 0 is niet noodzakelijk root

=== hostnaam van locaal ip-adres en omgekeerd ===

- eigen pc of andere pc in lokaal netwerk
	$ host FRT
	FRT.home has address 192.168.1.61
	$ host 192.168.1.61
	61.1.168.192.in-addr.arpa domain name pointer FRT.

- alle pcs in lokaal netwerk
	- 1 subnet, b.v. 192.168.1.xxx
		$ for n in {1..255}; do host 192.168.1.$n; done | grep -iv "not found"
	- alle subnetten (duurt een tijd)
		$ for m in {1..255}; do for n in {1..255}; do host 192.168.$m.$n; done; done | grep -iv "not found"

=== zoek bestand ===
	- op naam (eigen shellscript, hoofdtekens-ongevoelig)
		$ zoek deelvannaam
	- zoek tekst in bestanden met een bepaalde extensie (eigen shellscript, hoofdtekens-ongevoelig)
		$ zoekin extensie zoektermen of regex
	- show location of file :
		$ whereis filename
	- show location of file if it is in your PATH :
		$ which filename

=== welke opdracht ===
	- type [-aftpP] name [name ...] : With no options, indicate how each name would be interpreted if used as a command name
	$ type schijven
	>>> schijven is aliased to `lsblk -o NAME,LABEL,PARTLABEL,RM,SIZE,RO,TYPE,FSTYPE,MODEL,MOUNTPOINT' <<<
	$ type beeldpc
	>>> beeldpc is /home/dirk/bin/beeldpc <<<

=== technische gevens van een bestand ===
	$ stat bestand
	- b.v. mount point van een bestand :
	$ stat -c %m -- bestand
	-- : einde opties (voor het geval naam bestand met - begint)
	-c %m : custom format, gevolgd door newline. O.a.
		%m : mount point
		%n : file name
		%N : 'file name' (dereferenced if symbolic link)
		%s : size in bytes
		%i : inode number
	--printf %m : custom format zoals -c, maar met escapes (\n, \t, ...) in formaat. ZELF \n voor newline opgeven

=== huidige kernel ===

- de versie
	$ uname -r
	>>> 4.4.0-98-generic <<<
	-r, --kernel-release
	-n, --nodename : print the network node hostname

- configuratie-opties van huidige kernel :
	$ cat "/boot/config-$(uname -r)" | less
	OF
	$ grep -i GezochteOptie "/boot/config-$(uname -r)"

=== geinstalleerde versie Ubuntu ===

- zie ook sectie "ONDERHOUD" - "release bijwerken"

- opm : /proc/version en /proc/version_info gaan over de kernel, niet over de distri, alhoewel er bij Ubuntu wel "Ubuntu" in staat.

- huidige versie :
	- LSB standaard (Linux Standard Base)
		$ lsb_release -a
		>>>
			Distributor ID:	Ubuntu
			Description:	Ubuntu 16.04.1 LTS
			Release:	16.04
			Codename:	xenial
		<<<
		-i, --id : Display the string id of the distributor.
		-d, --description : Display the single line text description of the distribution.
		-r, --release : Display the release number of the distribution.
		-c, --codename : Display the codename according to the distribution release.
		-a, --all : Display all of the above information.
		[-s, --short] : machineleesbaar, b.v. :
			$ lsb_release -sc
			>>> xenial <<<
	- Free Desktop standaard
		$  cat /etc/os-release
		- in NAME=VALUE formaat, zodat ge van daaruit gemakkelijk variabelen kunt instellen
		>>>
			NAME="Ubuntu"
			VERSION="18.04.1 LTS (Bionic Beaver)"
			ID=ubuntu
			ID_LIKE=debian
			PRETTY_NAME="Ubuntu 18.04.1 LTS"
			VERSION_ID="18.04"
			HOME_URL="https://www.ubuntu.com/"
			SUPPORT_URL="https://help.ubuntu.com/"
			BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
			PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
			VERSION_CODENAME=bionic
			UBUNTU_CODENAME=bionic
		<<<
		- fallback : /usr/lib/os-release

- originele install :
	$  cat /var/log/installer/media-info
	>>> Xubuntu 15.10 "Wily Werewolf" - Release amd64 (20151021)d
	- werkt natuurlijk alleen als logs bijgehouden zijn

=== welke binary voert een opdracht uit ===

- which zoekt het pad af naar een executable, zoals de shell zelf dat zou doen om die uit te voeren :
	$ which vlc
	>>> /user/bin/qvlc <<<

=== welke libraries zijn nodig voor executable ===

- welke libraries worden dynamisch geladen door programma (cfr. windows dll)
	$ objdump -p $(which ffmpeg) | grep NEEDED
	OF (recursief)
	$ ldd $(which ffmpeg)

- b.v. gebruikt evince gtk of Qt :
	$ ldd $(which evince) | grep -i 'gtk\|qt'

===  welke (versie van) een library is geïnstalleerd ===

- b.v. gtk en python :
	OFWEL met ldconfig - configure dynamic linker run-time bindings
	$ ldconfig -p | grep -e python -e libgtk
	- voor 1 library is de -e niet nodig
	OFWEL
	$ whereis libjpeg

=== (maximum) aantal open bestanden of filedescriptors ===
	- Get max open files allowed per process:
		$ ulimit -n
		>>> 1024 <<<
	- Get maximum open files allowed:
		$ cat /proc/sys/fs/file-max
		>>> 1611831 <<<
	- current number of open files:
		$ cat /proc/sys/fs/file-nr
		>>> 9786	0	1611831 <<<
		- 9786 open van max. 1611831
	- sum of opened files by all processes (telt veel dubbel) :
		$ lsof | wc -l
		>>> 104602 <<<
		- lsof zonder opties: lijst van alle open filedescriptors
		- wc -l : word count - count lines

=== temperatuur van hdd ===
	$  sudo hddtemp /dev/sdb
		>>> /dev/sdb: TOSHIBA DT01ACA300: 40°C <<<

=== aantal processors (fysiek + hyperthreading virtueel) ===
	$ nproc
		>>> 8 <<<

=== type partitie (mbr of gpt) en detail van alle partities op alle schijven ===
	# parted -l

=== report file system disk space usage ===
	- Show information about all file systems :
		$ df
	- Show information about the file system on which the specified file resides
		$ df pad-naar-bestand
		- toont o.a. device en mountpoint :
			>>> df "een bestand ergens op /dev/sda1" :
				Filesystem      1K-blocks       Used Available Use% Mounted on
				/dev/sda1      2753050464 2392517016 220663500  92% /media/sdata
			<<<

=== schijfgebruik per bestandtype in directory tree ===
- b.v. schijfgebruik van alle jpg onder een hoofddirectory :
	- exporteer paden voor bashshell die we vanuit find starten
		$ export dir=/mijn/pad/
		$ export ramdisk=/media/ramdisk/
	- voorbereiden: maak op ramdisk symlinks naar al die bestanden, met behoud van directory-indeling (om gelijk genoemde bestanden uit elkaar te houden) :
		$ find "$dir" -type f -iname "*.jpg" -execdir bash -c 'ramdir=${PWD/#$dir/$ramdisk};mkdir -p "$ramdir";ln -srt "$ramdir" "$@";' _ \{\} \+
			-execdir \+ : groepeer resultaat per directory en voer uit in die directory
			- bash -c '...' _ \{\} :
				- opdracht tss. '', tegen expansie van $PWD, $dir en $ramdisk op de find-opdrachtlijn zelf: moet pas in de subshell
				- '_' : argument 0
				- \{\} : lijst van gevonden bestanden als arg. 1 e.v.
			- vervanging ${var/$dir1/$dir2} werkt wonderwel, ook als zowel var, dir1 als dir2 zelf /-tekens bevatten
			- ln -srt "$ramdir": symlinks, relatief (anders allemaal links naar "./xxx"), en in target "$ramdir"
	- disk usage met dereferencing van de symlinks
		$ cd /media/ramdisk
		$ du -Lhs
		OF per directory
		$ du -Lhs *
			-L : dereference symlinks
			-h : human readable
			-s : summary per argument

=== aantal inodes in een directory tree ===

- als root om ALLES te vinden
	# find . -xdev -printf '%i\n' | sort -u | wc -l
	-xdev : niet naar submounts
	- %i : print inode
	-u : unique sort
	-l : count lines

=== partities en bestandssystemen identificeren ===

==== zelf partition uuid en label instellen ====
- zie ook sectie "zelf random-uuid genereren"

- label kan met parted
	# parted [/dev/sdX] : schijf, niet partitie, b.v. /dev/sda of /dev/nvme0n1
		> [print devices] : lijst van devices
		> [select /dev/sdX] : schijf, niet partitie
		> print free : print alle info partities (met nrs) en vrije ruimte van huidige schijf
		> name partitienr label
		> quit
	OF met gparted (GUI)
	OF met fdisk /dev/sdX
		> x : ga naar expert mode
		> m : help
		> p : print
		> n : change partition name
			> # : partitienr, zoals in print
			> xxxx-xxx...-xxx : gewenste uuid
		> r : return naar standard mode
		> w : write to disk (gek genoeg kan dat niet in expert mode)
		> q : quit

- uuid kan met gdisk en fdisk in expert mode :
	# gdisk /dev/sdX
		> x : ga naar expert mode
		> ? : help
		> p : print
		> c : change partition uuid
			> # : partitienr, zoals in print
			> xxxx-xxx...-xxx : gewenste uuid
		> w : write to disk
		> q : quit
	OF
	# fdisk /dev/sdX
		> x : ga naar expert mode
		> m : help
		> p : print
		> u : change partition uid
			> # : partitienr, zoals in print
			> xxxx-xxx...-xxx : gewenste uuid
		> r : return naar standard mode
		> w : write to disk (gek genoeg kan dat niet in expert mode)
		> q : quit

==== zelf filesystem uuid en label instellen ====
- zie ook sectie "zelf random-uuid genereren"


- ext2/3/4)
	# tune2fs -U mijn_uuid /dev/ext#partitie
	EN
	# tune2fs -L mijnlabel /dev/ext#partitie
	OFWEL
	# /sbin/e2label /dev/ext#partitie mijn_label

- ntfs met tool
	- uuid heet "volume serial number"
	- install the ntfsprogs package
		# ntfslabel --new-serial=x1x2x3x4x5x6x7x8 /dev/ntfspartitie mijn_label
		--new-serial	: 8 bytes, 16 hex digits
	OF met de hand (zie verder)

- fat/fat16/fat32
	- mkfs.fat -n NAAM -i UUID /dev/sdXY : UUID 8 hex cijfers
	OF
	- met tool
		- uuid heet "volume serial number"
		- install the mtools utility package.
			# mlabel [-n|-N mijn_serial] -i /dev/partitie ::mijn_label
			-n		: Assigns a new (random) serial number to the disk
			-N serial	: Sets the supplied serial number, an 8 digit (4 bytes) hexadecimal number, without spaces
	OF met de hand (zie verder)

- ntfs,fat,fat16,fat32
	- met de hand
		- uuid heet "volume serial number"
		# dd if=/dev/partitie of=EersteNtfsBlok.hex bs=512 count=1
		- ntfs: uuid op offset 0x48-0x4f (8 bytes) in EersteBlok.hex, wijzigen met hex-editor
		- fat/fat16/fat32: uuid op offset 0x43-0x46 (4 bytes) in EersteBlok.hex, wijzigen met hex-editor
		# dd if=EersteBlok.hex of=/dev/partitie bs=512 count=1

==== zelf random-uuid genereren ====
	$ uuidgen

==== de symbolic links in /dev/disk/* ====

- OPM: misschien niet algemeen,maar wel in systemrescuecd (5.2.2), en Ubuntu (16.04)

- is toegankelijk voor niet-root

- De volgende directories :
	  /dev/disk/by-id
	  /dev/disk/by-label
	  /dev/disk/by-partlabel
	  /dev/disk/by-partuuid
	  /dev/disk/by-path
	  /dev/disk/by-uuid
  bevatten voor elk device van categorie "disk" die een identificatie hebben van het genoemde "by"-type, een (relatieve) symbolic link van die identificatie naar het device, b.v. :
	$ readlink /dev/disk/by-label/M2ROOT
		>>> ../../nvme0n1p2
	$ readlink -f /dev/disk/by-partlabel/m2_root
		>>> /dev/nvme0n1p2
	-f : canonicalize

==== blkid ALS ROOT ====

- OPM: ENKEL ALS ROOT BETROUWBARE INFO; voor niet-root gebruikers werkt blkid vanuit een cache, gevuld bij gebruik door root, en dus verouderd kan zijn. Gewone gebruikers gebruiken beter lsblk

- met blkid devicenaam e.a. bepalen, b.v.
	# blkid -o device -t PARTLABEL=tosh_linux
	-o (device|list|udev|full) : output alleen devicenaam, ... (zie voorbeelden)
	-t token=value : token kan o.a. zijn LABEL, UUID, PARTLABEL, PARTUUID, TYPE
	[-l] : (letter l, niet cijfer 1) : look up only the (first) device with the highest priority.
		[alleen zinvol met brede selectiecriteria zoals -t TYPE=ext4]. Devices in decreasing
		priority are: Device Mapper, EVMS, LVM, MD, and finally regular block devices.
	- verkorte opties :
		# blkid -L fslabel
		- impliceert "-o device"
		# blkid -U fsuuid
		- impliceert "-o device"
	- vb. :
		# blkid -o device -t PARTLABEL=tosh_linux
		 >>> /dev/sdb2
		# blkid -o device -t PARTUUID=70c59928-a23f-49d2-8823-208d9f57e68d
		 >>> /dev/sdb1
		# blkid -L TEFI
		 >>> /dev/sdb1
		# blkid -L TLINUX
		 >>> /dev/sdb2
		# blkid -U 036E-FCF8
		 >>> /dev/sdb1
		# blkid -U f7158182-82e9-41b7-bebd-3c5cb23d3ca3
		 >>> /dev/sdb2

- andere outputopties :
	- list : This output format is DEPRECATED in favour of the lsblk(8) command. Prints the devices in a user-friendly format; this output format is unsupported for low-level probing (-p or -i).
		# blkid -o list -t LABEL=TEFI
		 >>>
			device      fs_type  label   mount point      UUID
			-------------------------------------------------------
			/dev/sdb1   vfat     TEFI    (not mounted)    036E-FCF8
		 <<<
	- udev : This output format is DEPRECATED. Prints key="value" pairs for easy import into the udev environment; the keys are prefixed by ID_FS_ or ID_PART_
		# blkid -o udev #(blkid -U 036E-FCF8)
		 >>>
			ID_FS_LABEL=TEFI
			ID_FS_LABEL_ENC=TEFI
			ID_FS_UUID=036E-FCF8
			ID_FS_UUID_ENC=036E-FCF8
			ID_FS_TYPE=vfat
			ID_FS_PARTLABEL=tosh_efi
			ID_FS_PARTUUID=70c59928-a23f-49d2-8823-208d9f57e68d
		 <<<
	- full :
		# blkid -o full #(blkid -L TEFI)
		 >>> /dev/sdb1: LABEL="TEFI" UUID="036E-FCF8" TYPE="vfat" PARTLABEL="tosh_efi" PARTUUID="70c59928-a23f-49d2-8823-208d9f57e68d"
	- export : print key=value pairs for easy import into the environment
		# blkid -o export #(blkid -L TEFI)
		 >>>
			DEVNAME=/dev/sdb1
			LABEL=TEFI
			UUID=036E-FCF8
			TYPE=vfat
			PARTLABEL=tosh_efi
			PARTUUID=70c59928-a23f-49d2-8823-208d9f57e68d
		 <<<

==== findmnt ====

- zoekt bij verstek "in kernel table of mounted filesystems", zal wel betrouwbaarder zijn dan alles wat in /procs, /etc/mtab, ... zoekt
	>>> man mount
		For more robust and customizable output use findmnt(8), especially in your scripts
	<<<

- geschikt voor gebruik in bash command substitution, b.v.
	$ opdracht --uuid=$(findmnt -no UUID device)
	OF
	$ opdracht --uuid=$(findmnt -no UUID mountpoint)
	-n, --noheadings :don't print column headings
	-o, --output <list> : the output columns to be shown
	- beschikbare kolommen :
		>>> findmnt --help, onder andere
			  SOURCE  source device
			  TARGET  mountpoint
			  FSTYPE  filesystem type
			 OPTIONS  all mount options
		  FS-OPTIONS  FS specific mount options
			   LABEL  filesystem label
				UUID  filesystem UUID
		   PARTLABEL  partition label
			PARTUUID  partition UUID
				USED  filesystem size used
		<<<
	[-P, --pairs] :use key="value" output format, zoals lsblk hieronder

==== lsblk ====

- betrouwbaar voor niet-root gebruikers

- device-keuze kan in lsblk enkel op devicenaam; maar opties maken uitvoer geschikt voor keuze van device met grep, en parsen met bash. Vb. :
	$ export $(lsblk -nPpo PARTLABEL,NAME,PARTUUID | grep -E "^PARTLABEL=\"m2_root\"")
	- lsblk opties :
		-n : geen header
		-p : print volledige devicenaam, b.v. /dev/sda i.p.v. sda
		-o : namen van te printen eigenschappen, b.v. NAME,[PART]LABEL,[PART]UUID
		[-O] : print alle eigenschappen
		[-r] : print eigenschappen zonder namen, gewoon in volgorde; kan met slechte labels  zorgen dat grep onbedoeld 2 devices uitkiest
			- b.v. label met alleen [0-9a-f-] kan ook in uuid voorkomen
		[-P] : print als NAAM=WAARDE, moeilijker te parsen dan -r, maar eenduidigere grep
	- grep opties :
		-E ... : gewone regexp, met PARTLABEL aan begin van de lijn
	- export $() : maakt van de met grep gekozen output van "lsblk -nP" ineens omgevingsvariabaelen (bash verwacht commando als 1ste woord, zonder export krijgt ge foutboodschappen dat NAAM geen commando is, of nog ergere dingen als NAAM wel een commando is)
	$ echo $PARTLABEL
	 >>> PARTLABEL="m2_root" <<<
	$ echo $NAME
	 >>> NAME="/dev/nvme0n1p2" <<<
	$ echo $PARTUUID
	 >>> PARTUUID="aa679962-a12e-4f09-b010-371956223d25" <<<

- om alleen devicenaam te vinden, best "lsblk -pr" (volledige naam, raw uitvoer), b.v. :
	$ lsblk -nrp -o PARTLABEL,NAME | grep -E "^m2_root /dev/"
	 >>> m2_root /dev/nvme0n1p2
	$ lsblk -nrp -o PARTLABEL,NAME | grep -E "^m2_root /dev/" | grep -oE "/dev/[^[:space:]]+$"
	 >>> /dev/nvme0n1p2
	- grep opties
		-o : print alleen gematchte deel van de lijn
		-E "/dev/[[:alnum:]_/-]+$" : onderdelen :
			- $ : match alleen aan einde van de lijn
			- /dev/ : begint met /dev/
			- [^[:space:]]+ : 1 of meer space chars: in the ‘C’ locale, this is tab, newline, vertical tab, form feed, carriage return, and space.

=== details bestandssysteem ===

$ lsblk -OP /dev/sdb1
	-O : alle eig.
	-P : als NAAM=WAARDE
	>>>
	NAME="sdb1" KNAME="sdb1" MAJ:MIN="8:17" FSTYPE="vfat" MOUNTPOINT="" LABEL="TEFI" UUID="036E-FCF8" PARTTYPE="c12a7328-f81f-11d2-ba4b-00a0c93ec93b" PARTLABEL="tosh_efi" PARTUUID="70c59928-a23f-49d2-8823-208d9f57e68d" PARTFLAGS="" RA="128" RO="0" RM="0" HOTPLUG="0" MODEL="" SERIAL="" SIZE="10G" STATE="" OWNER="root" GROUP="disk" MODE="brw-rw----" ALIGNMENT="0" MIN-IO="4096" OPT-IO="0" PHY-SEC="4096" LOG-SEC="512" ROTA="1" SCHED="deadline" RQ-SIZE="128" TYPE="part" DISC-ALN="0" DISC-GRAN="0B" DISC-MAX="0B" DISC-ZERO="0" WSAME="0B" WWN="0x5000039fe3c6dce1" RAND="1" PKNAME="sdb" HCTL="" TRAN="" SUBSYSTEMS="block:scsi:pci" REV="" VENDOR=""
	<<<

==== details ext2/3/4 ====

$ sudo dumpe2fs -h /dev/sdb2
	>>>
	dumpe2fs 1.42.13 (17-May-2015)
	Filesystem volume name:   TLINUX
	Last mounted on:          /media/tlinux
	Filesystem UUID:          f7158182-82e9-41b7-bebd-3c5cb23d3ca3
	...
	Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize
	...
	Inode count:              4194304
	Block count:              16777216
	Reserved block count:     838860
	Free blocks:              14487382
	Free inodes:              3922393
	...
	Lifetime writes:          28 GB
	...
	<<<

==== details FAT ====

$ sudo file -s /dev/sdb1
	>>>
	/dev/sdb1: DOS/MBR boot sector, code offset 0x58+2, OEM-ID "mkfs.fat", sectors/cluster 16, Media descriptor 0xf8, sectors/track 63, heads 255, hidden sectors 2048, sectors 20971520 (volumes > 32 MB) , FAT (32 bit), sectors/FAT 10240, serial number 0x36efcf8, label: "TEFI       "
	<<<

=== fragmentatie van bestand ===

	$ filefrag GrootBestand
	>>> GrootBestand: 26 extents found
	$ filefrag -v GrootBestand
	-v : verbose
	- de kolom expected geeft aan wanneer er een extra fragment begint (andere physical offset dan het 'expected' volgende block. Samenvatting onderaan geeft aantal zulke sprongen als 'extents'
	>>>
		Filesystem type is: ef53
		File size of GrootBestand is 34359738368 (8388608 blocks of 4096 bytes)
		 ext:     logical_offset:        physical_offset: length:   expected: flags:
		   0:        0..       0:      34816..     34816:      1:
		   1:        1..   30719:      34817..     65535:  30719:             unwritten
		   2:    30720..   61439:      65536..     96255:  30720:             unwritten
		   3:    61440..   63487:      96256..     98303:   2048:             unwritten
		   4:    63488..   94207:     100352..    131071:  30720:      98304: unwritten
		   5:    94208..  124927:     131072..    161791:  30720:             unwritten
		...
		 282:  8364032.. 8388607:    8976384..   9000959:  24576:             last,unwritten,eof
		GrootBestand: 26 extents found
	<<<
	- OPM : 'unwritten' is typisch voor een GrootBestand aangemaakt met fallocate, zolang er inderdaad niet geschreven is naar die blocks. Swap file gemaakt met fallocate zal altijd unwritten blijven, omdat het swap-mechanisme niet langs het bestandssysteem gaat voor het schrijven: het vraagt aan het bestandssysteem enkel de lijst van blocks, en doet daarna direct I/O naar die blocks.

=== defragmenteren ===
- voor 1 bestand, alle bestanden in directory, of partitie
	- zien of er winst te halen is
		$ e4defrag -cv naam
		-c :  get current fragmentation count and an ideal fragmentation count
		[-v] : verbose
	- uitvoeren :
		$ e4defrag -v naam
		[-v] : verbose

=== is dit een virtual machine ===

- /proc/cpuinfo heeft dan een flag "hypervisor" voor elke cpu
	$ grep -q "^flags.* hypervisor" /proc/cpuinfo && echo "This machine is a VM"

- welke machine : (werkt ook buiten VM)
	# dmidecode -t system | grep 'Manufacturer\|Product'

=== time van een opdracht ===

	$ time opdracht
	>>> standaard opties :
		real	2m14,654s
		user	6m9,839s
		sys		0m15,829s
	<<<
		real : Elapsed real (wall clock) time used by the process
		user : Total number of CPU-seconds that the process used directly (in user mode)
		sys  : Total number of CPU-seconds used by the system on behalf of the process (in kernel mode)

=== uitvoeringsinformatie ===
- OPM: top (3,7MB) blijkt meer geheugen te vragen dan conky (2,7MB)

==== conky uitvoeringsinformatie ====
- GUI : conky, GUI voor allerlei systeeminformatie
	- ververst aan gewenst tempo
	- configureren met ~/.conkyrc
		- herlaadt bij wijzigen daarvan

==== top uitvoeringsinformatie ====
- CLI : top, wist terminal en toont in terminal tot 4 tabellen ('tasks windows'), ververst elke x sec.
	$ top -opties
	- OPM : '-' voor opties noch ' ' tss. optieletter en waarde zijn verplicht
	[-o [+|-]veld] : sorteer op dat veld, + hoog naar laag, - omgekeerd
		- print alleen lijst van beschikbare velden :
			$ top -O
	[-d ss.t] : ververs om de ss sec. en t/10 sec. (default 3.0 of ~/.toprc)
	[-p pid[,pid]...] OF [-p pid]... : alleen die process ids
		- alleen bepaalde processen op naam :
			$ top -p$(pgrep -d, john)
	[-c] : toggle display van commandline/procesnaam
	[-b] : batch mode : geen interactieve opdrachten, geen kleurtjes, scherm niet wissen, bij elke verversing gewoon nieuwe lijnen
	[n nn] : aantal keren verversen vooraleer te stoppen (OPM : verversen t.g.v. interactieve opdrachten telt mee)
	- top config onder naam (b.v. een alias of symlink) waarmee het is opgestart + "rc" :
		"$HOME/.your-name-4-top" + "rc"
		- Use the 'W' interactive command to create or update it
	- elk window heeft eigen kolommen en sortering, zie ook hieronder punt "interactie"
	- interactie algemeen
		q : quit
		? : toon help voor interactieve commando's
			? : volgende sectie help
		W : save naar ~/.toprc (of andere naam, zie boven)
		+ : reset filters in elk tasks window
		A : toggle single/multiple tasks windows
		- enkel met multiple tasks windows
			a/w : volgend/vorig tasks window
			_ : toggle aan/uit-stand van elk tasks window (i.e. toon andere set)
			- : toggle huidige tasks window uit
		g : prompt om nummer 1-4 van actieve tasks window ("column group")
			- zowel in single als multiple 'A'-mode
		= OF + :
	- interactie summary bovenaan :
		- OPM: er is er maar 1, maar de instellingen zijn per huidige tasks window
		l : toggle of lijn met o.a. load average getoond wordt in summary bovenaan
		m : toggle of en hoe geheugengebruik (RAM en swap) getoond wordt in summary bovenaan
		t : toggle of en hoe cpu-bezetting getoond wordt in summary bovenaan
		1 : toggle alle cpus samen/per (hyperthreading) kern
		E : toggle schaal geheugen (B, KB, MB, GB, ...)
	- interactie huidige tasks window
		i : toggle toon idle processen
		f : interactief scherm om getoonde kolommen en sortering te kiezen
		c : toggle commandline/processname
		e : toggle schaal geheugen (B, KB, MB, GB, ...)
			- OPM : schaal heeft invloed op filters (zie verder), want die vergelijken strings-gewijs
		n OF # : prompt om hoeveel processen te tonen (top van sortering), 0 voor window-vol
		d OF s : prompt om update interval
		r : prompt om pid en nieuw nice-level (prioriteit = 20+nice)
		k : prompt om pid en signaalnaam of -nr (default 15=sigterm)
		- sortering :
			V : toggle sorteren op kolom/groeperen per PPID (parent)
			< OF > : sorteer op (zichtbare) kolom links of rechts van huidige sorteerkolom
			R : toggle reverse/normaal sorteren
			- legacy shortcuts
				M : %MEM
				N : PID
				P : %CPU
				T : TIME+
			x : toggle highlight voor sorteerkolom
			y : toggle highlight voor actieve tasks
			b : toggle bold/reverse highlight
		= : reset filters
		Ctrl-o : toon filters
		o OF O : prompt om filter (O: hoofdlettergevoelig) :
			[!]VELD=waarde : gedeeltelijke match is genoeg
			[!]VELD<waarde
			[!]VELD>waarde
			- vergelijking is als string, dus pas op met schaal (b.v. geheugen) en links/rechts-uitlijnen

=== linux logs ===

- zie "https://help.ubuntu.com/community/LinuxLogFiles"
- zie "man journald.conf"

- kernel ring buffer?
	$ dmesg

- journals staan in binair formaat, zie sectie "journalctl"

- andere logs in /var/log, meeste als tekstbestand met generaties, oudere gezipt (zelf in te stellen)
	- gezipte generaties : met zcat, zless, zmore, zgrep, zdiff

- syslog :
	>>>
		- syslog is a standard logging facility. It collects messages from various programs, including the kernel. It is usually configured to store these messages by default. How it stores these messages is generally distribution-dependant.
		- /var/log/messages is generally used to store non-critical messages while /var/log/syslog stores everything, including critical and non-critical messages; Ubuntu no longer uses the /var/log/messages, but you can re-enable it
	<<<
	- hele syslog :
		$ less /var/log/syslog
		- shift-g : scroll naar einde
		- /zoekterm[Enter] : zoeken, met n(ext) en p(revious); regex-speciale chars escapen met '\'
	- zoeken, b.v. TBYTES :
		$ grep TBYTES /var/log/syslog
		- in generaties (al dan niet .gz) :
			$ zgrep TBYTES /var/log/syslog*
	- opvolgen
		$ tail -f -n 50 /var/log/syslog
		- afsluiten met Ctrl-C
		-f : follow; tail blijft actief en scrollt naar achter naarmate log wordt bijgevuld
		-n 50 : aantal lijnen
	- zoeken met opvolgen :
		$ watch [-n seconden] -c grep -colour=always [-i] [-E "zoekterm"] ... /var/log/syslog

==== journalctl ====

- systeem- en user-journaal zijn binaire bestanden in /var/log/journal/, beheerd en raadpleegbaar met de opdracht journalctl.
	- OPM: default gedrag in Ubuntu (Storage=auto in journald.conf) : als directory /var/log/journal/ niet bestaat, wordt journal bijgehouden in /run/log/journal (dir. wordt aangemaakt); in Ubuntu is /run een tmpfs, dus journals verdwijnt bij afsluiten

- journals nakijken :
	- in Ubuntu (bionic) is journalctl gecompileerd zonder -g --grep optie; om te zoeken pipe naar grep
	# journalctl --no-pager [-D /mnt/var/log/journal/] >/media/ramdisk/journals
	--no-pager : niet pipen naar less, zodat ge zelf een pipe kunt doen naar b.v. grep, of redirect naar tekstbestand
	[-D ...] : directory naar ander journal, b.v. van gemounte andere systeemschijf

- lijst van alle gejournaleerde opstartsessies
	# journalctl --list-boots

- journals verkleinen :
	# journalctl --disk-usage
		- Bij mij 500MB, en dat zit mee in mijn backup
	- journalctl --list-boots geeft bij mij aan dat hij de log van de laatste 133 boots heeft bijgehouden.
	- Gelukkig kunt ge dat verminderen : https://askubuntu.com/questions/1012912/systemd-logs-journalctl-are-too-large-and-slow/1012913#1012913
		- eenmalig :
			# journalctl [--vacuum-size=10M] [--vacuum-time=2weeks] [-D /mnt/var/log/journal]
			[--vacuum-size=10M] : verwijdert enkel volledige journal-archieven
			[--vacuum-time=2weeks] : verwijdert enkel volledige journal-archieven
			[-D /mnt/var/log/journal] : in journal van ander systeem
		- blijvend : directory /etc/systemd/journald.conf.d/ maken met .conf-bestand, b.v. :
			>>> /etc/systemd/journald.conf.d/kleinerjournaal.conf
			SystemMaxUse=50mb
			<<<
			- zie "man journald.conf"

=== snelheid USB schijf ===

- soms wordt een USB-schijf of -stick niet herkend op zijn volle snelheid, o.a. meegemaakt met de Kingston 64GB USB3.0. In andere poort steken kan helpen, maar om zeker te zijn:
	- zien in welke bus hij zit
		$ lsusb
		>>>	Bus 004 Device 007: ID 0951:1666 Kingston Technology DataTraveler G4 <<<
		- hiermee worden de USB-aparaten getoond met naam
	- zien welke snelheid device op die bus nu heeft
		$ lsusb -t
		-t : tree
		>>> zoek naar Dev 7 op Bus 4
		/:  Bus 04.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/2p, 10000M
			|__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/4p, 5000M
				|__ Port 2: Dev 7, If 0, Class=Mass Storage, Driver=usb-storage, 5000M
		<<<
		- achteraan staat de snelheid in MBit/sec :
			1.5M	: USB0
			12M		: USB1
			480M	: USB2
			5000M	: USB3.0 == USB3.1 gen. 1
			10000M	: USB3.1 gen. 2

=== beschikbare documentatie ===

- man pages : de man-opdracht zoekt die zelf, zie sectie "eigen programmas en man pages toevoegen", o.a. in
	- /usr/share/man
- info pages : idem, o.a. in
	- /usr/share/info
- niet-man documentatie per toepassing :
	- /usr/share/doc
- beschrijving per toepassing welke niet-man documentatie en waar ze geinstalleerd is
	- /usr/share/doc-base
	- /var/lib/doc-base

=== welke tty in gebruik ===
- toon wie op welke tty terminal is aangemeld:
	$ w

=== status toetsenbord en muis ===
	$ xset q
	>>>
	Keyboard Control:
	  auto repeat:  on    key click percent:  0    LED mask:  00000002
	  XKB indicators:
		00: Caps Lock:   off    01: Num Lock:    on     02: Scroll Lock: off
		03: Compose:     off    04: Kana:        off    05: Sleep:       off
		06: Suspend:     off    07: Mute:        off    08: Misc:        off
		09: Mail:        off    10: Charging:    off    11: Shift Lock:  off
		12: Group 2:     off    13: Mouse Keys:  off
	  auto repeat delay:  500    repeat rate:  20
	  auto repeating keys:  00ffffffdffffbbf
							fadfffefffedffff
							dfffffffffffffff
							fff7ffffffffffff
	  bell percent:  50    bell pitch:  400    bell duration:  100
	Pointer Control:
	  acceleration:  10/1    threshold:  1
	Screen Saver:
	  prefer blanking:  yes    allow exposures:  yes
	  timeout:  600    cycle:  0
	Colors:
	  default colormap:  0x20    BlackPixel:  0x0    WhitePixel:  0xffffff
	Font Path:
	  /usr/share/fonts/X11/misc,/usr/share/fonts/X11/Type1,built-ins
	DPMS (Energy Star):
	  Standby: 720    Suspend: 0    Off: 0
	  DPMS is Enabled
	  Monitor is On
	<<<

== HANDELINGEN ==

=== offset van string in binary file ===

- GUI zoeken met hex viewer zoals
	- tweak : Ctrl+S hsqs
	- GHex : Ctrl-F

- CLI met grep, b.v.
	>>> $ grep -boa hsqs Mapton-2.0.1-x86_64.AppImage
		32609:hsqs
		188392:hsqs
	<<<
	>>> $ grep -boaP "\x01CD001" *.iso
		32768:CD001
		98304:CD001
	<<<
		-b, --byte-offset : Print 0-based offset before each line of output.
		-o, --only-matching : Print only the matched (non-empty) parts
		-a, --text : Process a binary file as if it were text
		[-P, --perl-regexp] : hex bytes in zoekstring opgeven met \x voor, b.v. \x0F
	- opgelet: wildcards kunnen meer bestanden matchen, en dan zet grep "bestandsnaam:" voor de uitvoer van elke lijn :
	   -H, --with-filename : default when there is more than one file to search.
	   -h, --no-filename : default when there is only one file
- CLI met strings (toont alle strings van minstens 4 opeenvolgende afdrukbare chars) :
	$ strings -t d *.AppImage | grep hsqs
		-t d : toon offsets, decimaal

=== bytes op offset in binary file ===

- b.v. lees de 6 bytes op offset 0x8000 = 32768
	$ 2>/dev/null dd skip=32768 iflag=skip_bytes,count_bytes count=6  if=bestand
	- dd verstaat geen hex getallen, desnoods bash arithmetic $((0x8000)) gebruiken

- testen of die bytes een bepaalde waarde hebben : pipen naar hexdump, met -e formaat

- b.v. test of de 6 bytes op offset 0x8000 = 32768 gelijk zijn aan 0x01 "CD001" (ISO 9660 magic word)
	$ 2>/dev/null dd skip=32768 iflag=skip_bytes,count_bytes count=6  if=bestand | hexdump -e '1/1 "%02X" 5 "%_c""\n"' | grep 01CD001
	- hexdump -e formaat: '[herhaling][/byte-lengte] "%printf-formaat"'
		- altijd tss. '', want de printf-formaten moeten tss. en met "" doorgegeven worden
		- 1 printf-formaat per "", elk evt. voorafgegaan door [herhaling][/byte-lengte]
		- speciale printf-formaten:
			- de gebruikelijke escapes \t, \n, ...
			- %c, %_c, %_p, %_u : altijd 1 byte lang

=== sed - zoek en vervang in een bestand ===

- OPM : -E om extended regular expression te gebruiken, anders basic regex (~ zoals grep)

- man sed is beknopt :
	$ info sed

- zie [Useful one-line scripts for sed](http://sed.sourceforge.net/sed1line.txt)

==== sed search/replace regexp op 1 lijn ====
	$ sed -Esi [/regex/[I]]s/zoek/vervang/[I][g] file.txt [file2.txt]...
		-E : NIET VERGETEN : extended regular expression
		-s : elk bestand apart
		-i[backupextensie], --in-place[=backupextensie] : niet naar stdout, maar naar originele bestandsnaam, met evt. backup
		[-e] script, --expression=script : script commands to be executed; als er meer dan 1 script is, moet de -e er staan
		- script : gequote als er spaties in staan
			- [/regex/] : de volgende opdracht alleen uitvoeren op de lijnen die matchen met deze regex
				[I] : case-insensitive
				- andere begrenzingsteken mogelijk, 1ste voorafgaan door '\', b.v. \=regex=
			- s/searchpattern/replacepattern/ : substitute
				[I] : case-insensitive
				[g] : 'global', d.w.z. alle voorkomens van zoek-string
				- scheidingsteken (hier '/') bepaald door 1ste teken naar keuze, maar alledrie gelijk
				- zie verder sectie "sed opdrachten"

==== sed dos CRLF naar unix LF ===
	$ for i in *.srt;do sed -i 's/\r$//' "$i";done
	-i : in place
	- gewoon alle \r weglaten
	- OPM: in for-loop bestand per bestand, want met b.v. "sed ... *.srt" concateneert alle inputbestanden

==== sed unix LF naar dos CRLF ===
- b.v. onze Medion TV leest .srt subscripts alleen met dos CRLF lijneinde :
	$ for i in *.srt;do sed -i 's/$/\r/;s/\r\r/\r/' "$i";done
	-i : in place
	- eerst blindweg een \r voor elk lijneinde ('$') zetten, dan alle \r\r vervangen door \r (fallback voor als het bestand al (deels) dos CRLF heeft) :
	- OPM: in for-loop bestand per bestand, want met b.v. "sed ... *.srt" concateneert alle inputbestanden

==== sed hold en pattern space ====

- hold space : a long-term storage, such that you can catch something, store it and reuse it later when sed is processing another line. You do not directly process the hold space, instead, you need to copy it or append to the pattern space if you want to do something with it.

- pattern space : When sed reads a file line by line, the line that has been currently read is inserted into the pattern buffer (pattern space). Pattern buffer is like the temporary buffer, the scratchpad where the current information is stored. For example, the print command p prints the pattern space only. Likewise, s operates on the pattern space.

- met sed, search/replace regexp op meer lijnen: eerst hele bestand laden in "hold space", en dat als geheel naar "pattern space" sturen en multi-line regexp op uitvoeren
	- OPM: ge kunt de hele tekst daarna terug opdelen in lijnen, met b.v. 's@iets@iets\n@g', maar het blijft 1 blok in pattern space; pipe naar nieuwe sed om de nieuwe lijnen lijn per lijn te behandelen.
	$ sed -Ei -e '1h;2,$H;$!d;g' -e "s/lijn1\nlijn2/nieuw op lijn 1.../g"
	-e script, --expression=script : add the script to the commands to be executed
	- '1h;2,$H;$!d;g' : tussen '' gezet om interpreteren van $ door bash te voorkomen
		1h : "1" 1ste lijn - "h" in hold space zetten
		2,$H : "2,$" 2de t.e.m. laatste lijn - "H" append na \n aan hold space
		$!d : "$!" alle behalve laatste lijn - "d" pattern niet behandelen, lees volgende lijn en begin terug met eerste sed-commando van script
		g : "" alle lijnen, maar komen hier alleen voor de laatste lijn, waarvoor geen "d" wordt gedaan - "g" kopieer hold space naar pattern space (en voer daarop dan volgende sed scripts uit)

==== sed opdrachten ====
- zie [command summary for sed](http://docstore.mik.ua/orelly/unix/sedawk/appa_03.htm)

- enkele sed opdrachtlijn-opties :
	-E : gebruik extended regex syntax (de Echte Regex)
	-n : lijnen niet automatisch printen, enkel expliciet met b.v. de opdrachten p of n
		-n in combinatie met opdrachten p of n maakt voorafgaande grep overbodig
	[-e] opdrachtlijst : eerste of enige opdrachtlijst van sed-script
	-e opdrachtlijst : voeg opdrachtlijst toe aan sed-script

- opdrachtlijst:
	- opdracht
	- "opdracht;[ ]opdracht" : deze vorm ALTIJD tss. aanhalingstekens, t.b.v. shell

- opdracht:
	- opdracht
	- {opdracht[;[ ]opdracht]...} : deze vorm ALTIJD tss. aanhalingstekens, t.b.v. shell

- adressen :
	- [adres]opdracht : opdracht enkel voor die lijnen
	- [adres]!opdracht : opdracht voor alle behalve die lijnen
	- /zoek/ : regex adres
		- scheidingsteken (hier '/') naar keuze, maar 1ste moet dan voorafgegaan door '\', b.v. \=adres=
		- /…/I : case insensitive ('i' al gebruikt voor insert)
		- /…/M : multi-line mode, met extra regels voor zoek-pattern:
			- ^/$ : begin/einde lijn
			- `/' : begin/einde buffer
			- . : matcht GEEN newline
		- // : laatst gematchte regexp
	- lijnnr : lijnnr (begint van 1)
		$ : laatste lijn (geen ^ voor 1ste lijn, oplossen door negatie !)
	- adres1,adres2 : van tot, elk adres kan lijnnr of zoekpattern zijn
		- adres2 wordt pas gezocht vanaf lijn na gematchte adres1, behalve als adres1 == 0
		- gematchte address ranges kunnen overlappen, b.v.
			>>> $ seq 21 50 | sed -n  '/3/,/6/p' (\n vervangen door ' ')
				23 24 25 26 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
			<<<
	- lijnnr~N : ("tilde") vanaf lijnnr (niet /zoek/), elke N-de lijn
	- adres,~N : vanaf adres (lijnnr of /zoek/), elk lijnnr. dat veelvoud is van N

- command "cheat-sheet"
	- werken met hold space :
		h : hold = pattern
		H : hold += \n + pattern
		x : swap pattern and hold
		g : pattern = hold
		G : pattern += \n + hold
	- niet-sequentiële uitvoering
		: : label
		t : branch on substitute (naar elders benoemd label), b.v. ":l;...;tl"
		b : branch unconditional (naar elders benoemd label), b.v. ":l;...;bl"
		n : flush pattern, pattern = nextline continue
		N : pattern += \n + nextline
			vb. : sed -e 'N;s/\n/=/' vervangt "lijn1\nlijn2" door "lijn1=lijn2"
		q : flush en quit
		d : pattern delete top/cycle
		D : pattern ltrunc(line + \n) top/cycle
		l : pattern list
		p : print pattern
		P : print pattern first line
		w : print pattern to file
		i : insert text to stdout
		a : append text to stdout after flush
		r : append file to stdout after flush
	= : print line number en '\n'
	c : range change
	e COMMAND : execute COMMAND
		- execute the contents of pattern space as command, and replaces the pattern space with its output; a trailing newline is suppressed
		- uitvoeringsfouten krijgen de prefix "sh: ", vanwege de shell die door execute wordt aangeroepen om de contents of pattern space uit te voeren
		- OPM : typisch wordt de opdracht in pattern space samengesteld door voorafgaande substitute 's', met & (volledige pattern match) en \N (gematchte capturing group)
			- OPGELET: niet \& maar gewoon &, behalve als de opdracht niet tss. '' of "" staat, want dan is & voor bash het teken voor einde-opdracht-en-voer-uit-in-achtergrond; in dat geval moet de '&' wel ge-escaped worden als \&, zodat bash een letterlijke '&' doorgeeft aan sed.
		- OPM : volledige pattern space wordt als opdracht uitgevoerd; evt. jongleren met hold space, of opdracht opsplitsen met meerdere capturing groups en echo om diegene te behouden die niet door opdracht bewerkt moeten worden, b.v.:
			's/(prefix)(opdrachtparams)(suffix)/echo "\1" "$(opdracht \2)" "\3"/;e'
				- OPGELET : 's///', NIET "s///", zodat de $() command substitution pas wordt uitgevoerd door de shell die de execute doet, met substitutie van \N en &, en niet reeds vooraf door de shell die sed uitvoert
				- "" rond "$()" enkel nodig om evt. spaties in uitvoer te beschermen
	s/searchpattern/replacepattern/ : substitute of search and replace
		- attempts to match the pattern space against the supplied regular expression REGEXP; if the match is successful, then that portion of the pattern space which was matched is replaced with REPLACEMENT.
		- eerste teken na s (hier de /) scheidt de onderdelen zoek en vervang, b.v. 's|pad/naar/bestand|ander/pad/naar/bestand|g'
		- s//replacepattern/ : leeg search pattern wordt vervangen door laatst gematchte regexp, b.v. regex adres, zelfs inclusief \(\)-groepen
		- opties na laatste / :
			- s/…/…/g : optie global (allemaal op betreffende lijn, anders alleen 1ste voorkomen)
			- s/…/…/9 : niet de 1ste, maar de 9-de match vervangen
			- s/…/…/i EN s/…/…/I : case insensitive matching
			- s/…/…/m EN s/…/…/M : multiline mode, met extra regels voor zoek-pattern (zie adressen hierboven)
			- s/…/…/p : replace en print pattern space (meestal na optie -n : silent)
			- s/…/…/W filename : replace en print naar filename (b.v. ook /dev/stdout en /dev/stderr)
			- s/…/…/e : replace, execute in shell, en replace zoals shell command substitution (trailing newline is suppressed)
				- weinig of geen onderscheid met command e, behalve dat deze versie enkel bij een s kan, en enkel wordt uitgevoerd als de s een vervanging doet
		- speciale waarden in vervang-pattern :
			- \1 ... \9 : gematchte groepen (wat tss. () staat, in volgorde, ook genest)
			- & : hele gematchte pattern
			- \L : Turn the replacement to lowercase until a '\U' or '\E' is found,
			- \l : Turn the next character to lowercase,
			- \U : Turn the replacement to uppercase until a '\L' or '\E' is found,
			- \u : Turn the next character to uppercase,
			- \E : Stop case conversion started by '\L' or '\U'.
	y/sourcechars/destchars/ : transliterate chars (zoals opdracht tr)

=== beschermd tekstbestand bewerken ===

- veilig en snel, maar in tekst-interface (nano)
	$ sudoedit tekstbestand
		- bewerkt (met nano) een tijdelijke kopie (bewaar ook naar die naam), en hernoemt die pas na afsluiten terug naar originele naam

- met sudo, sudo -i, pkexec, mijn bash-alias spawn etc. kunt ge alles bewerken

=== eigenaar of groep van bestand veranderen ===

- met naam (d.i. dirk, Dirk is maar een displaynaam), niet uid of gid:
	- allebei
		$ sudo chown naam:groep foobar
	- alleen naam
		$ sudo chown naam bestand
	- alleen groep
		OFWEL
		$ sudo chown :groep bestand
		OFWEL
		$ sudo chgrp groep bestand

=== luidspreker kiezen ===

- mogelijkheden bekijken met
	$ pacmd list-cards
	>>> In huidige pc (ASUS PRIME H270 PRO) geeft dit
		2 card(s) available.
			index: 0
			name: <alsa_card.usb-MPOW_MPOW_HC6_001-00> (mijn Chinese koptelefoon)
			driver: <module-alsa-card.c>
			owner module: 8
			properties:
				alsa.card = "1"
				alsa.card_name = "MPOW HC6"
				...
			profiles:
				input:analog-mono: Analogue Mono Input (priority 2, available: unknown)
				output:analog-stereo: Analogue Stereo Output (priority 6000, available: unknown)
				output:analog-stereo+input:analog-mono: Analogue Stereo Output + Analogue Mono Input (priority 6002, available: unknown)
				output:iec958-stereo: Digital Stereo (IEC958) Output (priority 5500, available: unknown)
				output:iec958-stereo+input:analog-mono: Digital Stereo (IEC958) Output + Analogue Mono Input (priority 5502, available: unknown)
				off: Off (priority 0, available: unknown)
			active profile: <output:iec958-stereo+input:analog-mono>
			...
			index: 1
			name: <alsa_card.pci-0000_00_1f.3>
			driver: <module-alsa-card.c>
			owner module: 9
			properties:
				alsa.card = "0"
				alsa.card_name = "HDA Intel PCH"
			profiles:
				input:analog-stereo: Analogue Stereo Input (priority 60, available: unknown)
				output:analog-stereo: Analogue Stereo Output (priority 6000, available: unknown)
				output:analog-stereo+input:analog-stereo: Analogue Stereo Duplex (priority 6060, available: unknown)
				output:iec958-stereo: Digital Stereo (IEC958) Output (priority 5500, available: unknown)
				output:iec958-stereo+input:analog-stereo: Digital Stereo (IEC958) Output + Analogue Stereo Input (priority 5560, available: unknown)
				...
				>>> HDMI-uitgang !!! <<<
				output:hdmi-stereo-extra1: Digital Stereo (HDMI 2) Output (priority 5200, available: unknown)
				output:hdmi-stereo-extra1+input:analog-stereo: Digital Stereo (HDMI 2) Output + Analogue Stereo Input (priority 5260, available: unknown)
				...
			active profile: <output:analog-stereo>
			...
			ports:
				analog-output-lineout: Line Out (priority 9900, latency offset 0 usec, available: yes)
				analog-output-headphones: Headphones (priority 9000, latency offset 0 usec, available: unknown)
				hdmi-output-1: HDMI / DisplayPort 2 (priority 5800, latency offset 0 usec, available: yes)
					properties:
						device.icon_name = "video-display"
						device.product.name = "42 FHD_LCD-TV"
	<<<
	>>> In vorige pc (MSI H170A PC Mate) geeft dit
		3 card(s) available.
			index: 0
			name: <alsa_card.usb-Plantronics_Plantronics_.Audio_648_USB-00>
			driver: <module-alsa-card.c>
			owner module: 6
			properties:
				alsa.card = "1"
			...
			index: 1
			name: <alsa_card.pci-0000_05_01.0>
			driver: <module-alsa-card.c>
			owner module: 7
			properties:
				alsa.card = "0"
				alsa.card_name = "SB Live! 5.1 [SB0220]"
			...
			index: 2
			name: <alsa_card.pci-0000_00_1f.3>
			driver: <module-alsa-card.c>
			owner module: 8
			properties:
				alsa.card = "2"
				alsa.card_name = "HDA Intel PCH"
			...
				device.description = "Built-in Audio"
			...
			profiles:
				input:analog-stereo: Analogue Stereo Input (priority 60, available: unknown)
				output:analog-stereo: Analogue Stereo Output (priority 6000, available: unknown)
				output:analog-stereo+input:analog-stereo: Analogue Stereo Duplex (priority 6060, available: unknown)
				output:hdmi-stereo: Digital Stereo (HDMI) Output (priority 5400, available: unknown)
			...
	<<<
  en blijkbaar is het de index, en niet het alsa.card nummer dat we nodig hebben voor het volgende commando. Maar aangezien de index opnieuw bepaald wordt bij elke opstart, beter de name gebruiken:
- geluid van built-in audio (index 2) naar tv-uitgang (hdmi) sturen:
	(NIET pactl set-card-profile 2 output:hdmi-stereo)
	$ pactl set-card-profile alsa_card.pci-0000_00_1f.3 output:hdmi-stereo-extra1
- geluid van built-in audio (index 2) naar lijn-uitgang (mini-cinch) sturen:
	(NIET pactl set-card-profile 2 output:analog-stereo)
	$ pactl set-card-profile alsa_card.pci-0000_00_1f.3 output:analog-stereo

- programma starten met bepaald kanaal voor in- en/of uitvoer:
	- gewenste kanalen moeten geactiveerd zijn (Profile) op hun resp. device
		OFWEL
		- in pavucontrol/Configuration
		OFWEL
		- met cli, lijst van geluidsdevices en hun profielen
			$ pacmd list-cards
				>>> (
				...
				index: 3
				name: <alsa_card.pci-0000_00_1f.3>
				driver: <module-alsa-card.c>
				owner module: 10
				properties:
					alsa.card = "0"
					alsa.card_name = "HDA Intel PCH"
				...
				profiles:
					input:analog-stereo: Analogue Stereo Input (priority 60, available: unknown)
					output:analog-stereo: Analogue Stereo Output (priority 6000, available: unknown)
				...
				<<<
			- syntax "pacmd set-card-profile CARD PROFILE", met CARD (index of naam) en PROFILE ("off", "output:naam", "input:naam" of "output:naam+input:naam" zonder afsluitende ':') te vinden met commando list-cards
			- voorbeeld moederbord audio, met "pacmd list-cards" zoals hierboven:
				OFWEL
				$ pacmd set-card-profile 3 output:hdmi-stereo+input:analog-stereo
				OFWEL
				$ pacmd set-card-profile alsa_card.pci-0000_00_1f.3 output:analog-stereo
	- lijst van beschikbare ingangen (afh. van pavucontrol/Configuration)
		$ pactl list | grep -A2 'Source #' | grep 'Name: ' | cut -d" " -f2
		>>> vb.
			combined.monitor
			alsa_output.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo.monitor
			alsa_input.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo
			alsa_output.pci-0000_00_1f.3.analog-stereo.monitor
			alsa_output.pci-0000_05_00.0.analog-stereo.monitor
			alsa_input.pci-0000_05_00.0.analog-stereo	---> (FM801 PCI geluidskaart)
			alsa_input.pci-0000_05_01.1.analog-stereo	---> (Bt878 video tuner)
			alsa_input.pci-0000_00_1f.3.analog-stereo	---> (moederbord)
		<<<
		- "ffmpeg -f alsa -i pulse" neemt op van de "Monitor of Built-in Audio analog stereo" (WAS: met de monitors kunt ge niets aanvangen)
	- lijst van beschikbare uitgangen (afh. van pavucontrol/Configuration)
		$ pactl list | grep -A2 'Sink #' | grep 'Name: ' | cut -d" " -f2
		>>> vb.
			combined
			alsa_output.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo
			alsa_output.pci-0000_00_1f.3.analog-stereo	---> (moederbord)
			alsa_output.pci-0000_05_00.0.analog-stereo	---> (FM801 PCI geluidskaart)
		<<<
	- in/uitgangen kiezen met env. variabelen PULSE_SOURCE/PULSE_SINK, b.v.
		OFWEL
		$ export PULSE_SOURCE="alsa_input.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo"
		$ export PULSE_SINK="alsa_output.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo"
		$ skype
		OFWEL in commando buiten bash shell (b.v. in .desktop bestand, met de opdracht 'env var=waarde opdracht', niet zomaar 'var=waarde opdracht' zoals in bash)
		Exec=env PULSE_SOURCE="alsa_input.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo" PULSE_SINK="alsa_output.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo" skype
			- de opdracht env voert een opdracht uit in een gewijzigde omgeving
		OFWEL in 1 commando (in bash shell is wijziging van omgeving ingebouwd d.m.v. NAAM=WAARDE prefix)
		$ PULSE_SOURCE="alsa_input.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo" PULSE_SINK="alsa_output.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo" skype

=== geluidrecorder ===
Simpele rechttoe rechtaan recorder naar wav:
	$ arecord filename.wav
Neemt op in 'Unsigned 8 bit, Rate 8000 Hz, Mono'
Enkele opties:
	-d ##	:voor seconden (anders Ctrl+C om te stoppen)
	-V mono	of -V stereo : toon VU meter
	-f cd : 441000kHz 16-bit stereo

=== pdf utilities ===

- geinstalleerd :
	pdf180             pdfbook            pdfflip            pdfjam-slides3up   pdfpun             pdftoppm
	pdf270             pdfbook2           pdffonts           pdfjam-slides6up   pdfseparate        pdftops
	pdf2dsc            pdfclose           pdfimages          pdfjoin            pdfsig             pdftosrc
	pdf2ps             pdfcompress        pdfinfo            pdflatex           pdftex             pdftotext
	pdf90              pdfcrop            pdfjadetex         pdflatexpicscale   pdftocairo         pdfunite
	pdfannotextractor  pdfdetach          pdfjam             pdfnup             pdftohtml          pdfxmltex
	pdfatfi            pdfetex            pdfjam-pocketmod   pdfopen            pdftool            pdfxup

- uit de Poppler bibliotheek gebruikt door de evince document viewer
	pdfdetach extract embedded documents from a PDF
	pdffonts lists the fonts used in a PDF (-subst om de substituties van niet-ingesloten fonts te tonen)
	pdfimages extract all embedded images at native resolution from a PDF
		$ pdfimages -all -p input.pdf outputprefix
		- kopieert alle beelden uit input.pdf naar outputprefix-###.ext , met ext extensie die hoort bij het beeldformaat
		-all : ingebedde jpg, jpeg2000, jbig2 en ccitt naar zichzelf, cmyk naar tiff, rest naar png
		-p : voeg bladzijdenr toe aan outputprefx, vóór nummering beeldbestanden
	pdfinfo list all infos of a PDF
	pdfseparate extract single pages from a PDF
	pdftocairo convert single pages from a PDF to vector or bitmap formats using cairo
	pdftohtml convert PDF to HTML format retaining formatting
	pdftoppm convert a PDF page to a bitmap
	pdftops convert PDF to printable PS format
	pdftotext extract all text from PDF
	pdfunite merges several PDF

- java PDFMultivalent: zie eigen script ~/bin/pdftool en ~/bin/pdfcompress
	Split, Merge, Compress, Uncompress, Info, Validate, Repair, Decrypt, Encrypt, Impose, Undo, Extract, Diff, Convert, Stamp

- Ghostscript, b.v. pdf comprimeren door beeldkwaliteit te verlagen:
	$  gs -dNOPAUSE -sDEVICE=pdfwrite -dCompatibilityLevel=1.6 -dPDFSETTINGS=/screen -sOutputFile=out.pdf in.pdf
	- op ghostscript-prompt ">" quit [enter]
	-dPDFSETTINGS=/screen of =/ebook of =/printer of =/prepress
	-dNOPAUSE niet pauseren tussen paginas

- eigen java progs
	$ java JpgExtractor x.pdf
	$ java be.arci.pdf.ImageExtractor x.pdf
	$ Usage: java be.arci.pdf.ImageWrapper [-d dir] [[image(.jb2|.jpg|.jp2)]... [out.pdf] [-s|-g]]...
		 -d dir change directory for all following filenames (including for generated pdf filename)
			- OPM : opgepast met wildcards, niet geëxpandeerd in 'dir'
		 -s      wrap evt. preceding images in a pdf and set single mode
		 -g      wrap evt. preceding images in a pdf and set group mode (default)
		 out.pdf wrap preceding images in the named pdf file
		 All filenames not ending in '.pdf' will be assumed to be images.
		 ImageWrapper currently handles jbig2, jpeg and jpeg2000 images.
		 In single mode each image is wrapped in a separate pdf file.
		 In group mode all consecutive images are wrapped as pages of 1 pdf file.
		 If no pdf file name is given, one is generated from the filename of the 1st
		 image of a group, by appending or substituting the extension '.pdf'.

==== pdf paginagroottes ====

- lijst van groottes met Poppler bib :
	$ pdfinfo -f 1 -l 99  Physics\ ~\ Giancoli-x.pdf
		[-f 1] : (vanaf) blad 1, anders maar 1 blad (standaard 1ste blad)
		[-l 99] : (tot) blad 99, anders maar 1 blad (standaard 1ste blad)
		[-box] : Print the page box bounding boxes: MediaBox, CropBox, BleedBox, TrimBox, and ArtBox

- aanpassen paginagrootte (b.v. witruimte rondom toevoegen)
	- Foxit PDF editor (wine)
		- centert oude paginas in nieuwe grotere pagina
		- kan wijziging toepassen op alle blz.
		- kan naar keuze inhoud aanpassen aan nieuwe paginagrootte
		- kan wschlk. geen pdf van >1000 blz openen
	- Master PDF  Editor
		- voegt witruimte rechts-boven toe
		- kan wijziging toepassen op oneven/even/alle blz.
			- nuttig om oneven/even anders te behandelen : tussenin 180° roteren

==== pdf splitsen in oneven en even paginas en terug samenvoegen ====

- zie ook sectie "pdf dubbele bladzijden (b.v. boekscan) splitsen in links en rechts"
- zie ook sectie "opdracht uitvoeren op alle bestanden van een directory tree" subsectie "vb. 12 jpeg scans opsplitsen naar linker- en rechterblz."

- met java PDFMultivalent (script ~/bin/pdftool)
	- opgelet : evt. hierarchische inhoudstafel (index) in het document wordt in 2 hierarchieën gesplitst
	$ pdftool Split -pages "odd;even" invoer.pdf
		- OPM : meerdere page ranges gescheiden door ';' (is bash-teken, daarom tussen "")  maakt evenzoveel documenten, hier invoer-x1.pdf met oneven en invoer-x2.pdf met even blz
			- evt. inhoudstafel wordt gesplitst
	$ pdftool Merge -samedoc  invoer-x1.pdf invoer-x2.pdf
		- zet alle oneven, dan alle even blz. terug samen (1,3,5,...,2,4,6,...) in invoer-x1-m.pdf
		-samedoc : zet inhoudstafel van even blz. volledig achter die van oneven blz.
			- hierarchie wordt niet gemerged, maar achter elkaar geplakt, b.v.
				- hfstk1
					- blad1
					- blad3
				- hfstk2
				...
				- hfstk1
					- blad2
					- blad4
				...
	$ pdftool Split -pages "odd,even,backmap" invoer-x1-m.pdf
		- zet blz. terug in juiste volgorde (1,2,3,4,5,6,...)
		- inhoudstafel blijft staan zoals Merge ze heeft gemaakt (maar verwijst natuurlijk wel naar juiste blz.)

==== pdf dubbele bladzijden (b.v. boekscan) splitsen in links en rechts ====

- zie ook sectie "pdf splitsen in oneven en even paginas en terug samenvoegen"
- zie ook sectie "opdracht uitvoeren op alle bestanden van een directory tree" subsectie "vb. 12 jpeg scans opsplitsen naar linker- en rechterblz."
- werkt enkel als de blz. even groot zijn, en het midden overal op dezelfde plaats zit
- evt. doorzoekbaarheid (onzichtbare OCR) blijft bewaard!
- zonder noemenswaardige vergroting bestand !
- eerst elke blz. 2 keer na elkaar zetten:
	- boek 2 keer na elkaar zetten:
		$ pdftool Split -pages all,all orig.pdf
	- blz.-dubbels in juiste volgorde na elkaar zetten:
		$ pdftool Split -pages odd,even,backmap orig-x.pdf
	- blz. opdelen met Foxit PDF Editor:
		- kies representatieve oneven blz.
		- Tool/Crop, linkerkant selecteren (iets over het midden gaan als er marge nodig is),
		- [enter], "All pages" EN "Odd pages only"
		- mutatis mutandis voor even blz.

=== schermafdruk van hele Firefox pagina ===

- De Firefox-plugin Nimbus Capture probeert dit te doen door stapsgewijs door de pagina te scrollen, van elk stuk een schermafdruk te nemen, en die aan elkaar te plakken. Dit lukt dikwijls niet, door o.a. gebrekkige synchronisatie met Firefox, en door wijzigingen aan b.v. dynamishce pagina's. De Developper Tools van Firefox zelf bieden soelaas:
	- zorg dat de screenshot Web Developper Tool van Firefox beschikbaar is:
		- open om het even welke Web Developper Tool van Firefox
		- ga naar Settings (F1 of via menu achter de …)
		- selecteer "Available Toolbox Buttons/Take a screenshot of the entire page"
			- zet een camera-icoon op de knoppenbalk van de Web Developper Tools
		- selecteer evt. "Screenshot behaviour/Screenshot to clipboard"
			- zorg dan dat "Notification Area" op een xfce4 panel staat, en dat Clipman (xfce4-clipman) opgestart is
			- installeer evt. xclip om zonder grafisch programma het clipboard naar een bestand te schrijven
	- open om het even welke Web Developper Tool van Firefox
	- klik op het camera-icoon ib de knoppenbalk van de Web Developpers Tools ("Take a screenshot of the entire page")
		- als "Screenshot to clipboard" NIET op staat: schermafdruk staat als png in de Downloads directory (Firefox preferences/General/Files and applications/Downloads). Opm.: de gekozen directory wordt ook gebruikt voor deze screenshots, als daarna die voorkeur wordt veranderd naar "Always ask where to save files"
		- als "Screenshot to clipboard" WEL op staat: schermafdruk staat in verschillende formaten op het clipboard
			- selecteer, als het volgende niet direct lukt, uitdrukkelijk de genomen screenshot in Clipman (in de notification area)
			- nog niet gelukt met XnView
			- doe in b.v. Gimp "Edit/Paste as/Paste as new Image"
			OF
			- met xclip in een script of vanop een command prompt het clipboard naar een bestand schrijven
				- zien welke formaten beschikbaar zijn:
					$ xclip -selection clipboard -o -t TARGETS
					>>>
						TIMESTAMP
						TARGETS
						MULTIPLE
						SAVE_TARGETS
						image/png
						image/bmp
						image/x-bmp
						image/x-MS-bmp
						image/x-icon
						image/x-ico
						image/x-win-bitmap
						image/vnd.microsoft.icon
						application/ico
						image/ico
						image/icon
						text/ico
						image/jpeg
						image/tiff
					<<<
				- schermafdruk bewaren in b.v. png:
					$ xclip -selection clipboard -o -t image/png > afdruk.png

=== mkv video splitten ===

- niet meer geinstalleerd (mkvtoolnix)
Meerdere sequenties samen in 1 bestand bewaren:
	$ mkvmerge -o /media/ramdisk/out.mkv --split parts:uu:mm:ss-uu:mm:ss,+uu:mm:ss-uu:mm:ss ... input.mkv
	- zowel begin als einde van elke sequentie beginnen op volgende key-frame, dus om het beginframe goed te krijgen, proberen met telkens een paar seconden eraf.

=== geluidsbestand splitsen volgens cue file ===

- OPM : shntool hercodeert de gesplitste uitvoer ALTIJD. Is geen bezwaar voor verliesloze formaten zoals flac, maar voor mp3, als er een klein beetje stilte is rond de splitspunten, kan ffmpeg splitsen zonder hercoderen : zie "_ffmpeg truuks en commandos.adoc" sectie "splitsen in segmenten"

- Enkel voor cue met slechts 1 FILE met daarin verschillende tracks, b.v. om 1 flac uit te splitsen over meer flacs:
	- zowel de oplossing met shntool split -f, als die met cuebreakpoints, lezen enkel de "INDEX 01" van de cue-file, dus NIET de FILE statements, en shntool past die INDEX points dan blind toe op het invoerbestand plaat.flac
	$ shntool split -f plaat.cue -t "%n %t" -o flac plaat.flac
		- shnsplit is andere naam voor shntool split
		-f plaat.cue : Specifies a file from which to read split point data. If a simple CUE sheet, each "INDEX 01 m:ss:ff" line is converted to a m:ss.ff split point (ff in 75 frames per seconde). If not given, then split points are read from the terminal
		-t "%n %t" : Name output files in user‐specified format based on CUE sheet fields.  The following formatting strings are recognized:
			%p Performer
			%a Album
			%t Track title
			%n Track number
		-o flac : uitvoerformaat flac, evt. tussen '' met opties voor flac opdracht, waarin %f wordt vervangen door de bestandsnaam
		OF
		- b.v. 'cust ext=mp3 lame --quiet -m j -h -V 2 - %f'
		plaat.flac : het origineel, een hele plaat in 1 geluidsbestand
		- splitst op de "INDEX 01" punten, b.v.
			>>> .cue file
				FILE "Anna Moffo - Canteloube Villa-Lobos Rachmaninov.flac" WAVE
				  TRACK 01 AUDIO
					INDEX 01 00:00:00
				  TRACK 02 AUDIO
					INDEX 00 03:15:68
					INDEX 01 03:17:63
			<<<
			maakt 1ste track 3' en 17" en 63/75" lang
		- daarom kunnen flac bestanden die met shnsplit gemaakt zijn, gewoon terug met shntool join aaneengeplakt worden om het origineel te bekomen
	OFWEL (alternatief voor -f : zonder -f "split points are read from the terminal") :
	$ cuebreakpoints plaat.cue | shntool split -o flac plaat.flac
		- cuebreakpoints is part of cuetools

- tags toevoegen aan de resulterende flac op basis van cue-sheet, onder aanname dat de flac bestanden sorteren in track-volgorde (b.v. omdat ze genummerd zijn) :
		$ cuetag plaat.cue *.flac
		- cuetag is part of the cuetools, maar eerste op path is mijn versie in ~/bin/cuetag :
			$ cuetag -h

- info over cue files : http://wiki.hydrogenaud.io/index.php?title=Cue_sheet

=== flac geluidsbestanden achter elkaar plakken ===

- bestanden in natuurlijke sortering samenvoegen naar /media/ramdisk/samengevoegd.flac
	OFWEL
	$ shnjoin ./*.flac -o flac -a /media/ramdisk/samengevoegd
	OFWEL
	$ shntool join ./*.flac -o flac -a /media/ramdisk/samengevoegd
	-o flac : uitvoerformaat flac, evt. tussen '' met opties voor flac opdracht, waarin %f wordt vervangen door de betandsnaam
	-a str : Prefix str to base part of output filenames, default is 'joined'
	- andere opties :
		-r val : reorder input files;  val is one of: {ask, ascii, natural, none}.  The default is natural.

	- voorbeelden met deze invoer :
	>>> files.lst (flacs uit ~/Music)
		Anna Moffo - Aria Cantilena (Villa-Lobos).flac
		Anna Moffo - Vocalise Op34 (Rachmaninov).flac
		Claude Debussy - Nocturnes - Sirènes.flac
	<<<
	- join naar 1 flac-bestand
		$ shntool join -F files.lst -n -o flac
		-n : niet padden achteraan tot volledige CD-blocksize (zou alleen nuttig zijn om cd te schrijven)
		[-a prefix] : uitvoernaam prefix (eig. volledige naam bij join, i.p.v. "joined")
		>>>
			Joining [Anna Moffo - Aria Cantilena (Villa-Lobos).flac] (7:05.17) --> [joined.flac] (23:58.12) : 100% OK
			Joining [Anna Moffo - Vocalise Op34 (Rachmaninov).flac] (7:05.70) --> [joined.flac] (23:58.12) : 100% OK
			Joining [Claude Debussy - Nocturnes - Sirènes.flac] (9:47.00) --> [joined.flac] (23:58.12) : 100% OK
			Output file was not padded, nor was it needed.
		<<<
	- join naar 1 mp3-bestand zonder tijdelijk flac-bestand
		$ shntool join -F files.lst -n -o 'cust ext=mp3 lame --quiet -m j -h -V 2 - %f'
		- OPM: mislukt soms om onduidelijke reden, mogelijk op buffer voor pipe naar cust
			>>>
				shntool [join]: warning: error while transferring 49744800 bytes of data
				shntool [join]: warning: child encoder process 5831 had non-zero exit status 1
				shntool [join]: error: failed to join files
			<<<
		- cust : externe encoder
		- ext=mp3 : extensie voor output "joined.$ext"
		- lame ... : de externe encoder en zijn opties
			-m j : joint stereo
			-h : high quality (trager)
			-V 2 : variable bitrate en kwaliteit (0 hoog, 9 laag)
			-tt : titel
			-ta : artiest
			...
			- : encode from stdin
			%f : output, default ingevuld door shntool met joined.$ext
		>>>
			Joining [Anna Moffo - Aria Cantilena (Villa-Lobos).flac] (7:05.17) --> [joined.mp3] (23:58.12) : 100% OK
			Joining [Anna Moffo - Vocalise Op34 (Rachmaninov).flac] (7:05.70) --> [joined.mp3] (23:58.12) : 100% OK
			Joining [Claude Debussy - Nocturnes - Sirènes.flac] (9:47.00) --> [joined.mp3] (23:58.12) : 100% OK
			Output file was not padded, nor was it needed.
		<<<

- cue-sheet maken (of alvast de basis daarvan)
	- info over cue files : http://wiki.hydrogenaud.io/index.php?title=Cue_sheet
	$ shntool cue  -F files.lst
	-
	- alleen nuttig samen met 'join' : bevat maar 1 bestandsnaam "joined.wav"
	- zelf aanvullen met TITLE "titel", PERFORMER "zanger", COMPOSER "", ARRANGER "" en GENRE "" (VLC leest alleen de eerste 2)
		- per cue-sheet vooraan
		- per track na "TRACK ##"
	>>>
		FILE "joined.wav" WAVE
		  TRACK 01 AUDIO
			INDEX 01 0:00:00
		  TRACK 02 AUDIO
			INDEX 01 7:05:17
		  TRACK 03 AUDIO
			INDEX 01 14:11:12
	<<<
	- OPM : VLC (en waarschijnlijk geen enkel programma) vindt correct begin van gejoinde tracks in een VBR mp3-bestand; bij afspelen hebben ze natuurlijk wel de juiste lengte.
	- voorbeelden op basis van vorige join-voorbeelden:
	>>> split.cue
		FILE "Anna Moffo - Aria Cantilena (Villa-Lobos).flac" WAVE
		  TRACK 01 AUDIO
			TITLE "Aria Cantilena (Villa-Lobos)"
			PERFORMER "Anna Moffo"
			INDEX 01 0:00:00
		FILE "Anna Moffo - Vocalise Op34 (Rachmaninov).flac" WAVE
		  TRACK 02 AUDIO
			TITLE "Vocalise Op34 (Rachmaninov)"
			PERFORMER "Anna Moffo"
			INDEX 01 0:00:00
		FILE "Claude Debussy - Nocturnes - Sirènes.flac" WAVE
		  TRACK 03 AUDIO
			TITLE "Nocturnes - Sirènes"
			PERFORMER "Claude Debussy"
			INDEX 01 0:00:00
	<<<
	>>> joined.flac.cue
		FILE "joined.flac" WAVE
		  TRACK 01 AUDIO
			TITLE "Aria Cantilena (Villa-Lobos)"
			PERFORMER "Anna Moffo"
			INDEX 01 0:00:00
		  TRACK 02 AUDIO
			TITLE "Vocalise Op34 (Rachmaninov)"
			PERFORMER "Anna Moffo"
			INDEX 01 7:05:17
		  TRACK 03 AUDIO
			TITLE "Nocturnes - Sirènes"
			PERFORMER "Claude Debussy"
			INDEX 01 14:11:12
	<<<
	>>> joined.mp3.cue
		FILE "joined.mp3" MP3
		  TRACK 01 AUDIO
			TITLE "Aria Cantilena (Villa-Lobos)"
			PERFORMER "Anna Moffo"
			INDEX 01 0:00:00
		  TRACK 02 AUDIO
			TITLE "Vocalise Op34 (Rachmaninov)"
			PERFORMER "Anna Moffo"
			INDEX 01 7:05:17
		  TRACK 03 AUDIO
			TITLE "Nocturnes - Sirènes"
			PERFORMER "violist"
			SONGWRITER "Claude Debussy"
			INDEX 01 14:11:12
	<<<

=== zip zonder compressie ===
	$ zip -0q doel.zip [bestand]...
	-0 : no compression (store all files)
	-q : quiet
	- zie ook sectie "opdracht uitvoeren op alle bestanden van een directory tree" subsectie "vb. 9 stripverhalen opnieuw inpakken naar cbz"

=== Folders delen op het netwerk ===

- Benodigd: Samba (sudo apt-get install samba, zie _Xubuntu.adoc)

- zie ook sectie "symlinks volgen in Samba netwerk shares"

- shares worden geconfigureerd via leesbare bestanden in /var/lib/samba/usershares/, aangemaakt met de commando's van 'net usershare' (zie 'net help usershare', 'net help usershare add' etc.). Die commando's kunnen evt. toegevoegd worden aan thunar (Edit/Configure Custom Actions/+, met in de tab 'Appearance conditions' alleen Directories aangevinkt).
	- folder met definitie van samba-networkshares moet waarschijnlijk leesbaar zijn:
		- kreeg eerst veel foutberichten
		>>> /var/log/samba/log.pav (voor computer PAV van Mieke)
			[2017/05/07 19:44:25.795655,  0] ../source3/param/loadparm.c:3259(process_usershare_file)
			process_usershare_file: stat of /var/lib/samba/usershares/muziek failed. Permission denied
		<<<
		- met chmod, of in thunar properties van /var/lib/samba/usershares/: "other: read"

- share toevoegen of wijzigen 'net usershare add [-l|--long] <sharename> <path> [<comment>] [<acl>] [<guest_ok=[y|n]>]'
	- zie "_Xubuntu.adoc" sectie "op netwerk gedeelde directories"
	- default restricted to directories you own
		0 tijdelijk ramdisk schrijfbaar maken vanuit netwerk:
			- enkel eigenaar kan directory delen, dus eerst een directory maken op ramdisk :
			$ mkdir /media/ramdisk/RW ;  net usershare add RAMDISK /media/ramdisk/RW "ramdisk van frt (vergankelijk)" Everyone:f guest_ok=y
			- NA AFLOOP
			$ net usershare delete RAMDISK
		- verholpen met toevoeging aan /etc/samba/smb.conf (b.v. in sectie 'misc', juist voor header "Share Definitions" :
		>>>
			# Allow usershare without owning the shared folder (t.b.v. usershare op ramdisk)
		   usershare owner only = false
		<<<

- share verwijderen
	$ net usershare delete <sharename>

- zie ook _VirtualBox.txt sectie "Samba share mounten in VM"
- toon share-namen
	- volledige lijst (met commando's) zie "_Xubuntu.adoc" sectie "op netwerk gedeelde directories"
	>>> $ net usershare list
		MUZIEK
		...
	<<<

- toon de inhoud van de bestanden uit /var/lib/samba/usershares/
	$ net usershare info [sharename]

- directories en bestanden van network shares in gebruik:
	# smbstatus -L
	- OPM: op Mieke's PAV is FRT's RAMDISK in gebruik van zo gauw haar verkenner start

==== Samba configuratie wijzigen ====

- staat in /etc/samba/smb.conf
	$ man smb.conf

- shares definieren in smb.conf is nog niet gelukt
	- zie "_Xubuntu.adoc" sectie "Samba installeren om network shares te maken", OPM onderaan

- Samba leest smb.conf om de 60 seconden, wijzigingen best eerst opslaan onder tijdelijke naam en testen, vooraleer smb.conf zelf te overschrijven :
	$ testparm /etc/samba/smb.conf.nieuw

- After saving /etc/samba/smb.conf, be sure you restart Samba:
	# /etc/init.d/samba restart

==== symlinks volgen in Samba netwerk shares ====

- Samba verhindert als standaard toegang via symbolic links (verbergt die zelfs) naar directories en bestanden buiten een netwerk-share
	- VirtualBox shared folders doen dit NIET, daar wprden symbolic links wel gevolgd
		- OPGELET : resultaat van volgen op guest VM kan/zal anders zijn dan volgen op host
		- guest VM kan zonder "VBoxManage setextradata" geen symbolic links maken op shared folder
			- zie "_VirtualBox.txt" sectie "Symbolic links op shared folders"
	- zie "https://www.samba.org/samba/news/symlink_attack.html"
	- zie "https://unix.stackexchange.com/questions/5120/how-do-you-make-samba-follow-symlink-outside-the-shared-path"
	- zie "https://www.samba.org/samba/docs/using_samba/ch08.html#samba2-CHP-8-TABLE-1"
	- zie sectie "Samba configuratie wijzigen"
	>>> /etc/samba/smb.conf
		[global]
		unix extensions = no

		[share]
		follow symlinks = yes
		wide links = yes
	<<<
	- "unix extensions = yes" kan blijven als volgt:
		- dit lijkt onveiliger
		- met unix extensions kunnen directories/bestanden 'echt' gedeeld worden over netwerk, i.p.v. enkel toegankelijk zijn voor read/write, lijkt niet nodig voor mij
		>>> /etc/samba/smb.conf :
			[global]
			unix extensions = yes
			allow insecure wide links = yes

			[share]
			follow symlinks = yes
			wide links = yes
		<<<

=== Bestanden nummeren ===

- kan ook met b.v. Thunar Bulkrename

- alle bestanden in een reeks subdirectories van huidige directory opeenvolgend nummeren vanaf 01, met evt. een vaste extensie
	$ for i in ./* ; do num=100; cd "$i" ; for j in *.* ; do ((++num)) ; mv "$j" "${num:1}.jpg" ; done; cd .. ;done
	- num=100 zorgt dat de volgende 99 num's even veel (3) cijfers hebben
	- ((++num)) : increment num
	- ${num:1} pitst daar het eerste cijfer (de 1##) af
	- OPGELET: als de bestanden al genummerd zijn vanaf 00, wordt 00 over 01 gemoved, en dan over 02, ..., tot er maar 1 bestand overblijft: de originele 00, maar hernoemd naar het laatste nummer + 1

=== meerdere opdrachten (CLI en GUI) als root uitvoeren ===

- terminalgebruiker op root zetten
	$ sudo -i
	- vervangt ineens environment van user door die van root
	- GUI commandos kunnen vanuit deze prompt veilig gestart worden als root; in achtergrond uitvoeren met '&' erachter, best stdout en stderr naar /dev/null pipen:
		# guiopdracht >& /dev/null &
		- zie ook functie 'spawn' in .bash_aliases.rc
	- GUI opdrachten niet gewoon met sudo uitvoeren: sudo zonder -i behoudt environment van user, de gui kan dan zijn configuratiebestanden van de user overschrijven als root, waardoor de user zelf er nadien niet meer aan kan veranderen; dat kan zelfs over login-bestanden gaan, waardoor de user niet meer kan inloggen.

- zie .bash_aliases : alias sudos='XDG_CONFIG_HOME=~/.configroot xfce4-terminal --disable-server --geometry 132x30+0+0 -e "sudo -i"&'
	- gebruikt aparte map om voorkeuren van xfce4-terminal op te slaan, zodat die zichtbaar te onderscheiden is van gewone terminal
	- sudo -i maakt de shell root en login, met o.a. verwerking van /root/.profile waar PATH gezet wordt
		- NIET NODIG: xfce4-terminal --default-working-directory=/root

=== Thunar Custom Actions ===

- worden opgeslagen in ~/.config/Thunar/uca.xml

- vb.: scripts uitvoeren vanuit thunar
	Create a Thunar Custom Action to do this:
	In Thunar, Edit -> Configure Custom Actions -> Add a new custom action, then:
	On the Basic Tab:
	   - Name = Run In Terminal
	   - Description = Run in Terminal
	   - Command = xfce4-terminal -e %f --hold
	   - Select an icon if you want
	- On the Appearance Conditions tab:
	   - pattern "*.sh", select "Other files"
	Then in thunar, right-click the script and select the "Run in Terminal" option.

=== opdracht of shellscript uitvoeren in nieuwe terminal, en open houden ===

- opdracht uitvoeren in nieuwe (Xubuntu) terminal
	- sluiten na afloop van de opdracht (vgl. de terminals die door Whisker worden geopend om een man-page te bekijken) :
		$ xfce4-terminal -x opdracht args
		-x : rest van de lijn is de uit te voeren opdracht
		-e : volgende string of "string1 string2 ..." is de uit te voeren opdracht
		--tab of --window : 2de tab of window, met eigen opdracht
		--active-tab : zojuist gedefiniëerde tab actief maken
		--default-working-directory=directory : alle windows en tabs
		--working-directory=directory : tab
		-H : venster open houden na afloop opdracht, maar geen prompt: enkel om uitvoer te kunnen lezen
		-T titelstring
		--geometry wxh±x±y : vensterafmetingen in chars, +x/y : van linkerbovenhoek scherm, -x/y rechteronderhoek
		--drop-down : enige of zojuist gedefiniëerde window in 'drop down' mode (max. 1 window), sluit standaard bij verlies focus (optie rechtsonder in terminal zelf aan te passen)
		--show/hide-menubar/toolbar/borders/scrollbar
			- zonder scrollbar scrollen met muiswiel
			- averechts klikken geeft optie om toch nog menu te tonen
			- Alt-space voor systeemmenu, o.a. move, resize, always on top ...
		--font=lettertype
		--zoom=+-n : standaard lettergrootte x1.2^+n of /1.2^-n

	- na afloop openhouden voor vervolgopdracht :
		$ xfce4-terminal -T titel -e "bash -c \"opdracht ; exec bash\""
	b.v.	$ xfce4-terminal -T titel -e "bash -c \"./Documents/shellscripts/mijnscript.sh ; exec bash\""
		- 'bash -c' opent shell om script of andere opdracht uit te voeren
		- 'exec bash' vervangt het vorige proces, in dezelfde terminal, met uitvoer daarvan nog zichtbaar, en biedt prompt voor vervolgopdrachten; exec is a bash built in command:
			>>>
				Execute a command
				Syntax
					  exec [-cl] [-a name] [command [arguments]]
				Options
					  -l   Place a dash at the beginning of the zeroth arg passed to command. (This is what the login program does.)
					  -c   Causes command to be executed with an empty environment.
					  -a   The shell passes name as the zeroth argument to command.
				If command is supplied, it replaces the shell without creating a new process. If no command is specified, redirections can be used to affect the current shell environment. If there are no redirection errors, the return status is zero; otherwise the return status is non-zero.
			<<<

- vanuit script nieuwe interactieve shell openen (in zelfde terminal) om opdrachten te aanvaarden, bij exit daaruit gaat script verder:
	- zet op die plaats in het script de opdracht
		bash -i
		OF (mits de aanpassing die ik daarvoor in .bash_aliases heb gedaan)
		TERMINALTITEL="Mijn nieuwe titel voor het terminalvenster" bash -i

=== terminaltype met alternatieve instellingen ===

- b.v. transparante terminals configureren :
	- HOTKEY "Shift+Super+T" ingesteld
	$ XDG_CONFIG_HOME=~/.configalt xfce4-terminal --disable-server
	--disable-server : anders gaat hij op zoek naar parent terminal, en neemt daarvan alles over
	- XDG_CONFIG_HOME= : alternatief voor ~/.config, xfce maakt daarin autom. de nodige subdirs, o.a. ./gtk-3.0 ./ibus ./xfce4/terminal
		- als environment variabele XDG_CONFIG_HOME leeg of niet-ingesteld is, nemen alle programma's ~/.config als default
		- xfce4-terminal afsluiten, naar nieuwe ./xfce4/terminal de bestanden accels.scm en terminalrc uit standaard .config kopiëren, xfce4-terminal terug opstarten en preferences wijzigen naar believen

=== bash jobs ===

- programma als neven-proces openen vanuit terminal, en direct terug een prompt krijgen :
	- vooral nuttig voor GUI en langdurige progs
	$ opdracht & [disown]
		>>> man bash
		 If a command is terminated by the control operator &, the shell executes the command in the background in a subshell. The shell does not wait for the command to finish, and the return status is 0.
		<<<
		- los van de terminal, dus zonder stdin en stdout, behoudens redirect
		- foutboodschappen, zoals de veel voorkomende van gtk, komen wel in de terminal, tenzij met pipe naar null:
			$ opdracht >& /dev/null &
			- zie ~/bash_aliases functie spawn()
		[disown] : bash command om 'current' job ook los te maken van huidige shell, zie "$ help disown"

- opdracht in uitvoering van deze shell stoppen :
	- b.v. na
		>>>
			mousepad &
			opdracht parameters
		<<<
	- Ctrl-Z : stopt proces onmiddelijk, gooit klaarstaande invoer (~ toetsenbord-buffer) en hangende uitvoer weg
	OF
	- Ctrl-Y : stopt wanneer proces invoer van de terminal probeert te lezen
		>>> [n]+  Stopped                 opdracht parameters <<<
		- [n] : jobnr.
		- nu kunt ge andere opdrachten uitvoeren, b.v. man raadplegen
		- OPGELET: als de opdracht in een opdrachten-lijst stond, dan wordt nu de volgende opdracht gestart, b.v. :
			$ sleep 100 ; doe iets
			- Ctrl-Z
				>>> [n]+  Stopped                 sleep 100 <<<
				maar "doe iets" wordt onmiddelijk uitgevoerd
	- job herstarten
		$ [fg] %n
		[fg] : herstart in voorgrond, is default
		- koppelt job n aan de terminal (o.a. stdin) en laat ze verder lopen
	- job herstarten, maar in achtergrond (lukt niet voor interactieve opdrachten)
		$ %n &
		OF
		$ bg %n
		[bg] OF & : 'background', laat job n verder lopen maar in de achtergrond, los van de terminal
	- achtergrondjob naar/in voorgrond halen/herstarten
		$ fg %n
	- lijst lopende en gestopte jobs met deze shell als parent (bash internal)
		$ jobs
		>>>
			[m]-  Running                 mousepad &
			[n]+  Stopped                 opdracht parameters
		<<<
		- genummerde lijst (jobnr., NIET pid)
	- job vragen om af te breken
		$ kill %n
		- BELANGRIJK : %-prefix, anders is n een pid (process id)
		- zelfde als kill -TERM %n, breek job n helemaal af. De afgebroken job blijft wel als 'terminated' in jobs staan, mogelijk om met 'fg n' de job terug naar de voorgrond te brengen om zijn exit code te krijgen.
		- het is om jobnummer n (met prefix %) als argument te kunnen geven, i.p.v. pid, dat de opdracht kill is ingebouwd in bash
	- zie ook sectie "bash shell sneltoetsen"

=== beheer processen ===

==== overzicht van alle processen, met pid ====
- OPM: ps heeft opties met en zonder prefix '-'

	$ ps -e
	-e     Select all processes.  Identical to -A
	[r]    (ZONDER - !!)  Restrict the selection to only running processes
	[T]    (ZONDER - !!)  Select all processes associated with this terminal
	>>>
	  PID TTY          TIME CMD
		1 ?        00:00:02 systemd
	    2 ?        00:00:00 kthreadd
		4 ?        00:00:00 kworker/0:0H
		...
	<<<

==== pid van een bepaald proces ====

- OPM: ps heeft opties met en zonder prefix '-'

	$ ps -C geany,cupsd
	-C cmdlist : Select by command name (komma-gescheiden)
	>>>
	  PID TTY          TIME CMD
	 5019 ?        00:00:10 geany
	13641 ?        00:00:00 cupsd
	<<<

- voor verdere verwerking
	$ pid=$(ps -o pid= -C geany); echo $pid
	>>>
	5019
	<<<
	-o, --format [kolom[=[titel]]] : Specify user-defined format, met optie om zelf kolom-titel te zetten; als alle kolom-titels zelf gekozen en leeg zijn, dan geen lijn met kolom-titels

- selectie kan ook met grep (minder efficient)
	$ ps -e | grep -i geany

==== process stoppen, afsluiten, naar achtergrond ====

- processen worden in Xenial door systemd beheerd, op basis van pid (process id)
	$ kill -STOP [pid | %n]
		- zoals ctlr+z in bash shell: stopt process met pid, zonder zijn resources vrij te geven
		- OPM : kill is een bash internal, maar aanvaardt als argument om signaal naar te sturen zowel %jobnr v.d. bash shell, als pid (volledig numeriek), zie sectie "bash jobs"
	$ kill -CONT [pid | %n]
		- zoals 'bg n': laat job pid terug lopen, maar in de achtergrond(?), los van de terminal
	$ kill -l
		- lijst van alle SIGxxxx die we naar jobs en processen kunnen sturen als 'kill -xxxx pid' of 'kill -xxxx %jobnr'

==== info van processen in /proc ====
- in het virtueel bestandssysteem gemount op /proc, staat voor elk PID een map met info en voor besturing ervan :
	- /proc/1234 : alle info van process 1234; hierin staan allemaal pseudo-bestanden van 0 lang, uit te lezen met redirect of cat.
		- OPGELET : niet alles is leesbaar, meeste niet schrijfbaar
			- exe is symlink naar de binary in uitvoering :
				$ realpath /proc/1234/exe
				>>> /usr/bin/huppeldepup <<<
			- cwd is symlink naar de PWD :
				$ realpath /proc/1234/cwd
				>>> /home/1000/Documents <<<
			- cmdline toont volledige opdrachtlijn, opgesplits als C-main()'s argv[] :
				$ sed -E 's/^/"/;s/\x0/" "/g;s/ "$/\n/' /proc/1234/cmdline
				>>>"huppeldepup" "-arg1" "-arg2"<<<
					- zet '"' aan begin, vervang elke ASCII-Z door '" "', en vervang de laatste zo zelf toegevoegde ' "' door newline
			- environ toont environment, opgesplits als C-main()'s env[] :
				$ sed -E 's/\x0/\n/g' /proc/1234/environ | sort
			- fd/ directory met symlinks naar geopende filedesriptors, vooraan het trio stdX
				$ realpath /proc/1234/fd/*
				>>>
				/dev/pts/1
				/dev/pts/1
				/dev/pts/1
				/home/dirk/snap/john-the-ripper/297/.john/john.rec
				/home/dirk/snap/john-the-ripper/297/.john/john.log
				/home/dirk/snap/john-the-ripper/297/.john/john.pot
				/dev/tty
				/snap/john-the-ripper/297/run/ascii.chr
				<<<
			- fdinfo/ info van geopende filedesriptors, zoals huidige offset
				$ catfiles /proc/1234/fdinfo/*
				>>>
				...
				fdinfo/4
					 1	pos:	440212
					 2	flags:	0102001
					 3	mnt_id:	483
				...
				<<<

==== toon lopende opdrachten, hun argumenten en process id ====

	$ pstree -lap [-s] [user | pid]
		-l, --long : kap niet af op terminalbreedte
		-a, --arguments
		-p, --show-pids
		-s, --show-parents : toon parent van gevraagde pid
		[ user | pid ] : beperk tot de user of process id

==== uitvoeren na einde van een opdracht ====

- zie sectie "pid van een bepaald proces"

- met loop die pid in het oog houden :
	$ while [[ $(ps 15859 &> /dev/null)$? -eq 0 ]]; do sleep 60 ;done && sleep 10 && slaap
		- na einde taak nog even geven om mischien caches naar schijf te schrijven, af te koelen met ventilators aan, ...
	OF (rechtstreeks met /proc virtueel bestandssysteem :
	$ while [ -d /proc/15859 ]; do sleep 60 ;done && sleep 10 && slaap


=== pipe naar bestand maar ook naar scherm ===

- tee : read from standard input and write to standard output and files
	$ opdracht | tee [-a] bestand
	- -a : --append

=== java broncode omzetten naar ASCII ===

- Op Windows (ook Eclipse voor Windows) waren alle tekst-bestanden (ook .java) gecodeerd als windows codepage 1252 (Latin-1). Op Xubuntu (ook Eclipse voor Linux) als UTF-8. Omzetten van cp1252 naar UTF-8 kan met iconv :
	$ iconv -f WINDOWS-1252 -t UTF-8 in.java uit.java
	- -f : from encoding
	- -t : to encoding
	- ZIE sectie "opdracht uitvoeren op alle bestanden van een directory tree" voor meer uitgewerkt voorbeeld

- JDK zelf heeft een geschikte opdracht om .java bronbestand om te zetten naar ASCII met Java-stijl Unicode-escapes
	$ native2ascii -encoding windows-1252 in.java uit.java

=== directory van mijn website synchroniseren over FTP ===

- NIET rsync met FTP server gemount (b.v. met gigolo) op local file system : "is designed to compute file hashes remotely to compare files without transferring them, but doing that with virtual files transfers the files anyway"

- ZIE OOK Unison (nog in TEDOEN van _Xubuntu.adoc)

- ZIE https://stackoverflow.com/questions/1461978/how-to-synchronize-local-directory-with-remote-ftp-directory
	$ wget --mirror username:password@siteurl.com/path
	- nog te onderzoeken welke opties conflicten (gewijzigd aan beide kanten) behandelen
	- nuttige bijkomende opties :
		--limit-rate=amount : Limit the download speed to amount bytes (k kB, m MB) per second; e.g. --limit-rate=2.5k
		-w seconds , --wait=seconds : Wait seconds (m minutes, h hours, d days) between retrievals. Specify a large value to wait long enough to reasonably expect the network error to be fixed before the retry. The waiting interval specified by this function is influenced by "--random-wait".
		--waitretry=seconds : wait between retries of failed downloads. Wget will use linear backoff, waiting 1 second after the first failure on a given file, then waiting 2 seconds after the second failure on that file, up to the maximum number of seconds you specify. By default, Wget will assume a value of 10 seconds.
		--random-wait : causes the time between requests to vary between 0.5 and 1.5 * wait seconds, where wait was specified using the --wait option, in order to mask Wget's presence from analysis to identify automated retrieval programs.
		-Q quota , --quota=quota : Specify download quota in bytes (k kB, m MB) for automatic retrievals. This does not affect downloading a single file or file URLs specified on the command-line. Quota is respected when retrieving either recursively, or from an input file. Thus you may safely type "wget -Q2m -i sites"; download will be aborted when the quota is exceeded. Setting quota to 0 or to inf unlimits the download quota.

=== opdracht uitvoeren op alle bestanden van een directory tree ===

ZIE http://www.dwheeler.com/essays/filenames-in-shell.html ("Filenames and Pathnames in Shell= How to do it Correctly.mht")
ZIE http://mywiki.wooledge.org/UsingFind

==== basistechnieken ====
	- loop over alle bestanden in een directory, met een naam die overeenkomt met bepaalde jokertekens :
		$ for i in ./*.ext; do opdracht1; opdracht2; else opdracht3 ; opdracht4; done
	- loop over alle bestanden in directe subdirectories, beide met een naam die overeenkomt met bepaalde jokertekens :
		$ for i in "TTC "*/*.ext; do opdracht1; opdracht2; else opdracht3 ; opdracht4; done
	- loop over alle niveaus van subdirectories (in het algemeen globbing = wild card expansion over subdirectories):
		- hiermee wordt ** uitgebreid tot alle niveaus van subdirectories
		$ shopt -s globstar
		$ for i in ./**/*.ext;
	- in volgorde van grootte, datum, ...
		- bash e.a. shell breiden wildcards uit naar pad in alfabetische volgorde. Met 'ls -1 ...' kunnen bestandsnamen in andere volgorde opgevraagd worden
			- b.v. op Size reversed :
				$ ls -1Sr
				>>>
				'klein bestand'
				'groot bestand'
				<<<
			- b.v. Lijst van bestanden in subdirectories gesorteerd op grootte:
				$ ls -dG1S [-r] [-Q | --quoting-style=shell] [-sk] */*
				-d, --directory : list directories themselves, not their contents
				-G, --no-group : in a long listing, don't print group names
				-1 : list one file per line.
				-S : sort by file size, largest first
				- vooral nuttig voor display: grotere bestanden staan onderaan in de lijst, zijn nog niet van terminal weg gescrolled :
					[-r, --reverse] : reverse order while sorting
				- zonder quoting optie gebruikt ls toch escapes wanneer nodig. Evt. expliciet sturen:
					[-Q, --quote-name] : enclose entry names in double quotes : "Un \"Moment\" D'égarement"
					[--quoting-style=WORD] : use quoting style WORD for entry names: literal, locale, shell, shell-always, shell-escape (mog. synoniem van shell, nog geen verschil gevonden), shell-escape-always, c, escape
						- heeft voorrang op Q
							>>>
							--quoting-style=literal : Un "monument" d'élégance
							[zonder quoting-optie] : 'Un "monument" d'\''élégance'
							-Q : "Un \"monument\" d'élégance"
							--quoting-style=shell : 'Un "monument" d'\''élégance'
							--quoting-style=escape : Un\ "monument"\ d'élégance
							<<<
				- bestandsnamen voorafgegaan door grootte, mooi in kolom:
					[-s, --size] : print the allocated size of each file, in blocks
					[-k, --kibibytes] : default to 1024-byte blocks for disk usage
		- uitvoer van 'ls -1 ...' is niet rechtstreeks bruikbaar b.v. als 'for a in $(ls -1 ...)', omdat de quotes verwijderd worden en de bestandsnamen gesplitst in woorden
		- als opdracht NIET leest van STDIN:
			$ while read i;do opdracht;done <$(ls -1 ...)
		- als opdracht WEL leest van STDIN (b.v. ffmpeg zonder -nostdin):
			- opdracht zou zelf van de pipe lezen, voor while aan de volgende iteratie toekomt
				b.v. $ ls -1S | while read i;do echo i=$i;read -t 0.1 j;echo j=$j;done
					- read -t: time out
			- weerszijden van een pipe worden in een subshell uitgevoerd, kunnen daarom geen variabelen zetten voor buiten de while-loop
			- oplossing: while-read niet van pipe, maar van here-string <<<$(ls -1 ...) of process substitution < <(ls -1 ...) laten lezen EN resultaat eerst naar array lezen, en doorgeven naar 2de loop:
				$ unset lijst
				$ while read i;do lijst=("${lijst[@]}" "$i");done <<<$(ls -1 ...)
				$ for i in "${lijst[@]}";do opdracht;done
	- in volgorde van totale grootte van directory :
		$ du -BM -d0 TTC*/ | sort -h
		-B, --block-size=SIZE : scale sizes by SIZE before printing them; e.g., '-BM' prints sizes in units of 1,048,576 bytes;
		-d, --max-depth=N : print the total for a directory only if it is N or fewer levels below the command line argument;  --max-depth=0 is the same as --summarize
		-h, --human-numeric-sort : compare human readable numbers (e.g., 2K 1G)
	- find [bronpad] selecties acties
		- [bronpad] selecties : zie sectie "lijst-opdrachten" lemma "zoek bestanden en directories"
		- acties : default actie is naam naar stdout
			- meerdere akties zijn toegelaten, worden uitgevoerd in opgegeven volgorde, per zoekresultaat
			- b.v. opeenvolgende "-exec commando ;"
			- b.v. -print -exec commando \; : drukt bestandsnamen als separators tussen elke uitvoer commando
			-delete
			-exec commando : commando wordt direct vanuit find uitgevoerd, met de functie exec(args[]), dus zonder langs de shell te gaan: commando string opgesplitst in args[i] door find zelf
				- {} plaatshouder voor bestandsnaam(lijst)
					- wordt rechtstreeks ingevuld met het resultaat van find
					- soms t.b.v. shell escapen \{\} of quoten "{}", omdat { en } daar ook iets betekenen
				- commando afsluiten met \; :
					- per aanroep 1 bestandsnaam in {}
					- meerdere {} mag
					- {} mag overal staan
				- commando afsluiten met \+
					- per aanroep lijst van zoveel mogelijk bestandsnamen in {}
					- slechts 1 {}
					- {} moet helemaal achteraan, en naakt
						MAG : {} \{\} "{}"
						MAG NIET : "\{\}" prefix{}suffix, zelfs niet b.v. -{}
				- ALTERNATIEVEN :
					-execdir : commando wordt in directory van zoekresultaat uitgevoerd, is veiliger
						- met \+ worden zoekresultaten gegroepeerd per directory
						- OPGELET bestandsnaam ingevuld in {} bevat geen volledige padnaam meer, MAAR WEL "./"
					[-ok] OFWEL [-okdir] : prompt voor elk zoekresultaat, enkel met \; (per bestand)
						- "command ... bestandsnaam ... ?" (y of n enteren)
				- pipe in commando KAN NIET, want vooraf door shell verwerkt => onvolledige exec.
				- variable=waarde commando : idem (environment variable enkel voor uitvoering van commando)
				  OPLOSSING:
					- pipe na de \; of \+ is soms genoeg (b.v. voor gewone grep)
					- commando in script zetten, met {} als parameter
					- bash als commando gebruiken :
						$ find . -type f -exec bash -c 'commando1 $1 -$2 | commando2 $1 -$3' _ {} optie1 optie2 \;
							bash -c :
								- first non-option argument ('', NIET "") is command string
								- arguments after that assigned to positional parameters, starting with $0
								- in het voorbeeld wordt :
									- _ : $0 (plaatshouder)
									- {} : $1
									- optie1 : $2
									- optie2 : $3
						$ find . -type f -exec bash -c 'naam=waarde commando1 $1' _ {} \;
			-print : print zoekresultaten op stdout, gescheiden door \n
				-fprint file : naar bestand 'file'
			-print0 : gescheiden door 0x00
				-fprint0 file : naar bestand 'file'
			-printf formaat : geformateerd
				-fprintf file formaat : naar bestand 'file'
			...
		- OPM: bij het opbouwen en testen van -exec met echo i.p.v. uitvoering, moeten de "..." in de argumentlijst voor echo tijdelijk geschreven worden als "\"...\"", omdat echo zelfs zijn ding doet met ""
		- OPM: max. lengte command line is beperkt, -exec {} \+ splitst desnoods op over meerdere aanroepen
			OFWEL
			$ getconf ARG_MAX
			2097152
			OFWEL
			$ xargs --show-limits
			Your environment variables take up 3557 bytes
			POSIX upper limit on argument length (this system): 2091547
			POSIX smallest allowable upper limit on argument length (all systems): 4096
			Maximum length of command we could actually use: 2087990
			Size of command buffer we are actually using: 131072
			Maximum parallelism (--max-procs must be no greater): 2147483647

==== Korte voorbeelden ====
	- checksum van lijst bestanden
	OFWEL
	$ find pad -type f -exec sha256sum -b \{\} \; > sha256sums.lst
	OFWEL (sha256num aanvaardt meerdere bestandsnamen)
	$ find pad -type f -exec sha256sum -b \{\} \+ > sha256sums.lst
		-exec, want -execdir zou padnaam verwijderen, dus niet geschikt voor b.v. "sha256sum -c" achteraf
	- + sluit het opdracht-argument van -exec af, BEST net zoals de accolades ge-escaped met \ (of tussen '' of "")
	OFWEL
	$ find pad -type f -print0 | xargs -0 sha256sum -b > sha256sums.lst
	- "|" pijpt stdout van find naar stdin van xargs
	find -print0 : (niet in alle linux/unixen) namen in stdout van find gescheiden door 0x00
	xargs -0	 : (niet in alle linux/unixen) 0x00 als scheidingsteken in stdin van xargs
	- grootte van alle bestanden per directory :
	$ find /media/sdata/muziek -maxdepth 1 -type d -exec du -hs \{\} \;
	- totale grootte (du, disk usage) van alle bestanden van een bepaald type, b.v alle flac muziekbestanden :
	$ find /media/sdata/muziek -type f -iname "*.flac" -print0 | du -ch --files0-from=- | grep total
		du --files0-from=- : lees lijst namen met 0x0 als scheidingsteken van stdin (of =lijstbestand i.p.v. =-)
		du -c, --total : produce a grand total
		du -h, --human-readable : print sizes in human readable format (e.g., 1K 234M 2G)
	- alle bestanden in een subtree, met een bepaalde extensie, openen in mousepad (b.v. VirtualBox VM definities):
	$ find pad -type f -iname "*.vbox" -exec mousepad \{\} \+
	- alle java-sourcecodes converteren van Latin-1 (Eclipse voor Windows) naar UTF-8 (Ubuntu) :
	$ find . -type f -iname *.java -print -exec mv {} {}.cp1252~ \; -exec iconv -f WINDOWS-1252 -t UTF-8 -o {} {}.cp1252~ \;
		- eerst backup naar x.java.cp1252~ (bestand met suffix ~ is 'hidden' in thunar)
		- codepage 1252 is Latin1
		- semi-inplace via tussenbestand

==== vb. 1 alle .java omzetten van Windows cp1252 naar utf-8, met backup ====
	$ find . -type f -iname "./*.java" -exec bash -c 'iconv -f WINDOWS-1252 -t UTF-8 "$1" | diff -q - "$1" || { mv "$1" "$1.cp1252" && iconv -f WINDOWS-1252 -t UTF-8 -o "$1" "$1.cp1252" ; } ' _ \{\} \;
		bash -c '' _ \{\} : ingevulde \{\} als $1 in 'commandos'
		| : iconv naar stdout, en pipe naar stdin van diff
		diff - : stdin
		|| : als diff exit status != 0 heeft (1: inputs are not the same, 2: trouble)) wordt deel na || uitgevoerd (logische OR), een compound command list tussen { && ;} als geheel

==== vb. 2 als vb. 1, met delete van niet-gewijzigde bestanden ====
	OPGELET ALLEEN UITVOEREN OP RESERVEKOPIE, verwijdert alle .java-bestanden zonder speciale characters
	$ find . -type f -iname "*.java" -exec bash -c 'iconv -f WINDOWS-1252 -t UTF-8 "$1" | { diff -q - "$1" && rm "$1" ;} || { mv "$1" "$1.cp1252" && iconv -f WINDOWS-1252 -t UTF-8 -o "$1" "$1.cp1252" ; } ' _ \{\} \;

==== vb. 3 als vb. 2, met omzetten naar ASCII met Java Unicode escapes ====
	OPGELET ALLEEN UITVOEREN OP RESERVEKOPIE, verwijdert alle .java-bestanden zonder speciale characters
	$ find . -type f -iname "*.java" -exec bash -c 'iconv -f WINDOWS-1252 -t UTF-8 "$1" | { diff -q - "$1" && rm "$1" ;} || { mv "$1" "$1.cp1252" && native2ascii -encoding windows-1252 "$1.cp1252"  "$1" ; } ' _ \{\} \;

==== vb. 4a alle bestandsnamen met niet-ASCII tekens ====
	$ find . | perl -ne 'print if /[^[:ascii:]]/'

==== vb. 4b alle windows (cp1252) bestandsnamen in directory tree omzetten naar linux (UTF-8) bestandsnamen ====
	OPGELET: heel gevoelig voor de plaats van de quotes (en NIET escapen)
	OPGELET: eerst testen met een echo voor de mv (om absoluut zeker te zijn dat het CP1252 is, en b.v. geen rare chars van CP1252 die UTF-8 gecodeerd zijn)
	$ shopt -s globstar
	- zorgt voor expansie van ** naar volledige subdirectory tree
	$  for i in **/* ; do if [ -f "$i" ] && [ "$i" != "$(echo "$i" | iconv -f WINDOWS-1252 -t UTF-8)" ] ; then  mv "$i" "$(echo "$i" | iconv -f WINDOWS-1252 -t UTF-8)" ; fi; done
		- de "" rond $i dienen voor bestandsnamen met whitespace; zelfs dubbele spaties blijven behouden (van belang voor de echo)
		- de "" rond `opdracht` idem voor de geconverteerde bestandsnaam

==== vb. 5 kb/s van alle filmbestanden in een map ====
	$ find -maxdepth 1 -type f -exec /opt/ffmpeg/ffprobe -hide_banner {} \; 2>&1 | grep -e "Input #" -e "kb/s"
		2>&1 : ffprobe stuurt resultaat zot genoeg naar stderr, dus die moeten we aan stdout hangen
		grep -e : zo kan grep meerdere regexp tegelijk zoeken

==== vb. 6 alle films (van meerdere types: avi, mkv, mp4, mpg) ====
	$ find pad \( -iname ./*.avi -or -iname ./*.mkv -or -iname ./*.mp? \) -print0 | du -ch --files0-from=- | grep total
		\( ... -or ... \) : deze gehele expressie eerst, voor we de combinatie aanbieden aan -print0
			- zonder wordt alleen resultaat van de laatste test, "-iname ./*.mp?", naar -print0 gestuurd
			- escapes \( en \) zijn nodig voor bash, omdat die zijn eigen betekenis heeft voor ()
			-or : logische OR

==== vb. 7 symbolic links naar bestanden in hernoemde map ====

- links in current directory naar liedjes na hernoemen van /media/sdata/ naar /media/tarch/ :
	$ find . -lname '/media/sdata/*' -exec bash -c 'lied=$(readlink "{}") ; ln -sfiT "${lied/sdata/tarch}" "{}"' \;
	-lname : selecteer op target van de link, met klassieke bash pathname expansie
	-ilname : idem, case insensitive
	-s : symbolic link
	-f : forceer vervangen van bestaande (verbroken) link
	-i : forceer interactief (y of n)
	-T : BELANGRIJK anders kan 2de argument als doeldirectory geinterpreteerd worden, i.p.v. als linknaam
	bash -c '...' : nodig om de 2 commando's lied=... en ln ... aan elkaar te breien: lied= is iets van shell
	- ${parm/zoek/vervang} : parameteruitbreiding met vervanging van zoekterm

==== vb. 8 in een map links maken naar alle directories met een subdirectory "ORIG" ====
	$ mkdir /media/ramdisk/mp3
	$ cd /media/ramdisk/mp3
	$ find /media/sdata/muziek/ -type d -name ORIG -exec bash -c 'ln -s "$(realpath "{}/..")" ' \;
	-exec bash -c '...' : -exec van find is via call naar C exec(), niet via een shell; daarom werken shell-specifieke zaken zoals $() niet, daarvoor moet ge zelf een shell opstarten

==== vb. 9 stripverhalen opnieuw inpakken naar cbz ====
	- strips staan per album als .jpg in subdirectory van current directory :
		$ for i in * ; do pushd "$i"; zip -0 ../"$i".cbz *.jpg; popd; done
	- hele directory jpg-strips in .cbr, met verwijderen van andere bestanden (o.a. Apple's .DS_store), bestanden hernoemen naar simpele volgnrs en lowercase jpg
		$ for r in *.cbr;do cd /media/ramdisk/;unrar e "$OLDPWD/$r";find -type f -not -iname "*.jpg" -delete;ls -v * | cat -n | while read n f; do mv -n "$f" "$(printf %04d $n).jpg"; done;zip -0q "$OLDPWD/${r:: -1}z" *;rm /media/ramdisk/*;cd "$OLDPWD";done

==== vb. 10 in alle bestandsnamen dubbele aanhalingstekens vervangen door enkele ====
	$ find -xdev -iname "*\"*" -execdir bash -c 'mv "${1//\"/"\""}" "${1//\"/\'\''}"' _ \{\}  \;
	- het argument voor bash -c staat best tussen enkele aanhalingstekens, dat voorkomt expansie (in deze shell, want in de aangeroepen bash-shell zijn die al verdwenen) :
	- zowel in de uitvoerende shell, als in de shell die wordt aangeroepen door de find-opdracht exec, de argumentstrings in 2 splitsen met extra set aanhalingstekens (die toch wegvallen na de nodige expansies), met daartussen ge-escaped het aanhalingstekens dat in de bestandsnaam moet staan/komen

==== vb. 11 bestanden zoeken met uitsluiting van bepaalde suffixen ====

- b.v. bestanden die geen e-book o.i.d. zijn, met bash brace expansion :
	- WERKT : met brace expansion find-opdracht samenstellen, en uitvoeren met eval
	$ eval find -type f "\! -iname \*."{pdf,djvu,epub,mobi,ps,txt,html,doc,docx,rtf,odt,cbz,chm}
	0 NIET find-opdracht rechtstreeks aanmaken :
		0 find -type f "\! -iname *".{pdf,djvu,epub,mobi,ps,txt,html,doc,docx,rtf,odt,cbz,chm}
		- "iets"{x,y} expandeert tot "iets"x "iets"y
	- WERKT : genereer eerst de find-opdracht, toon die met echo, en dan kopieren, plakken, uitvoeren
		$ echo find -type f "\! -iname \"*\"".{pdf,djvu,epub,txt,html,htm,chm,doc,docx,ps,rtf,mobi,odt}
			>>> output kopieren naar een nieuwe opdrachtlijn :
			find -type f \! -iname "*".pdf \! -iname "*".djvu \! -iname "*".epub \! -iname "*".txt \! -iname "*".html \! -iname "*".htm \! -iname "*".chm \! -iname "*".doc \! -iname "*".docx \! -iname "*".ps \! -iname "*".rtf \! -iname "*".mobi \! -iname "*".odt
			<<<
	0 NIET $(echo find ... zie hierboven ...) : find geeft dezelfde fout als rechtstreekse find van hoger


==== vb. 12 jpeg scans opsplitsen naar linker- en rechterblz. ====

- zie ook sectie "pdf dubbele bladzijden (b.v. boekscan) splitsen in links en rechts"
- sommige pdf's zijn per 2 blz. gescand :
	- jpg's uit pdf halen :
		$ java be.arci.pdf.ImageExtractor input.pdf
		OF (typisch als lengte van pdf-stream gecodeerd is in ander object, i.p.v. rechtstreeks opgegeven) :
		$ java JpgExtractor input.pdf
		OF
		$ pdfimages -all -p input.pdf outputprefix
	- resulterende jpegs opsplitsen in linker en rechter blz
			$ mkdir gesplitst
		- methode 1 : met sed
			$ for i in *.jpg; do eval $(jpeginfo "$i"|sed -E 's/.*jpg ([0-9]+) x ([0-9]+) .*/w=\1 h=\2/');echo $i w:$w $((w/2)) h:$h;jpegtran -opt -prog -crop "$((w/2))x$h+0+0" -copy none -outfile "gesplitst/${i/.jpg/}L.jpg" "$i";jpegtran -opt -prog -crop $((w-w/2))x$h+$((w/2))+0 -copy none -outfile "gesplitst/${i/.jpg/}R.jpg" "$i";done
				- OPM : $(jpeginfo | sed) moeten in dezelfde subshell, dus dezelfde bracket expansion, want pipe werkt enkel binnen zelfde shell
				- OPM : jpegtran argumenten mogen afgekort worden, BEHALVE -outfile
		- methode 2 : met read
			$ for i in *.jpg;do echo $(jpeginfo $i);done|while read naam breed x hoog rest;do echo naam=$naam w=$breed h=$hoog r=$rest;done
			...
		$ java be.arci.pdf.ImageWrapper gesplitst/*.jpg [uitvoer.pdf]
			- wildcard expansie is altijd alfanum gesorteerd, toegevoegde suffixen L en R geven toevallig de juiste volgorde

==== vb. 13 vergelijken duur van reeks afleveringen na hercompressie ====
- zie "_ffmpeg truuks en commandos.adoc" sectie "vergelijken duur van reeks afleveringen na hercompressie"

==== vb. 14 named pipe ====

- omdat een commandolijn een beperkte lengte heeft (o.a. find en xargs splitsen lijsten met bestandsnamen automatisch op in korte stukken), kunnen programma's die een hele reeks bestanden of andere argumenten verwerken, die uit een lijstbestand lezen. Bash laat toe om zo'n lijstbestand niet eerst naar schijf te schrijven, maar on-the-fly via bash process substitution in te vullen (via een named pipe). B.v. als de directory waar find in zoekt (default ./) niet in de bestandsnaam mag staan :
	$ commando -l <(find ... -printf "%P\n")
	-l : typische parameter voor "read filenames from list"
	- %P : File's name with the name of the starting-point under which it was found removed.

- OPM : smv (SmartVersion) kan bestandslijst niet lezen uit zo'n pipe, die moet een echt bestand krijgen

==== vb. 15 crop jpgs ====

- met "jpeginfo -l" krijgt ge info in listing-formaat van een jpeg-bestand, b.v. :
	$ jpeginfo -l 19.jpg
	>>>
	1403 x 1020 24bit JFIF  P   74894 19.jpg
	<<<

- uit die info width en height afzonderen, kunnen daarmee dan bash berekeningen doen
	$ for i in *.jpg;do dim=$(jpeginfo -l "$i") ;dim="${dim%%??bit *}";w="${dim%% x *}";w=${w// };h="${dim#* x }";h=${h// };jpegtran -crop ${w}x$((h-100)) -outfile "/media/ramdisk/$i" $i;done
		- ${x%%??bit *} : verwijdert alvast zowel " 8bit ..." als "24bit ...", zodat 9999 x 9999 overblijft (met evt. voorloopspaties)
		- ${x// } verwijdert alle ' '

==== vb. 16 alle woorden met hoofdletter in reeks bestanden ====

- sommige ondertitels zijn volledig in hoofdletters, andere niet
	- uit de ondertitels met kleine letters een lijst maken met de 'eigennamen' (woorden met hoofdletter)
		$ for f in *.srt;do grep -E "[a-z]" "$f" >/dev/null && grep -iE "[a-z]" "$f" | sed -Ee 's|^[a-zA-Z]+[^a-zA-Z](.*)|\1|; s|\. [a-zA-Z]+[^a-zA-Z]||g; s|[[:punct:]][a-zA-Z]+([^a-zA-Z])|\1|g; s|([^[:alpha:]]+)|\n|g; s| ||g' | grep -E "^[A-Z][a-z]"; done | sort -uf
			- grep 1: zoek bestanden met lijnen met kleine letters; bij succes :
				- grep 2: enkel de lijnen met letters (b.v. voor .srt: niet de nummers en tijden)
				- sed s 1: verwijder 1ste woord van elke lijn : kan hoofdletter hebben als begin van zin
				- sed s 2: verwijder woord na punt : zou hoofdletter moeten hebben als begin van zin
				- sed s 3: verwijder woord na punctuatie : zou hoofdletter kunnen hebben (b.v. tss. haakjes)
				- sed s 4: vervang alle niet-letters door \n
				- sed s 5: verwijder spaties
				- grep 3: behoud alleen lijnen met letters
			- sort -uf : verwijder dubbels, case-insensitive; als woord met hoofd- EN kleine letter voorkomt, de kleine houden
				-u : uniek
				-f, --ignore-case : fold lower case to upper case characters
			- grep 5: behoud alleen woorden met hoofdletter gevolgd door kleine letter

=== tekstbestanden naast elkaar vergelijken ===

- diff zet standaard verschillen onder elkaar
	$ diff -yW 167 --suppress-common-lines bestand1 bestand2
	-y om hele bestanden naast elkaar te tonen
	-W breedte van terminal (standaard 130)
	--suppress-common-lines

- sdiff altijd naast elkaar (? side-by-side diff ?)
	- alleen verschillen, maar afgekapt op < terminalbreedte/2  :
	$ sdiff -bBWsw 167 bestand1 bestand2
	-b Ignore changes in the amount of white space.
	-W Ignore all white space.
	-B Ignore changes whose lines are all blank.
	-s Do not output common lines.
	-w breedte van terminal (standaard 130)

=== dubbele voorkomens verwijderen uit invoer ===

- met sorteren :
	$ sort -u
	-u, --unique : sorteer output only the first of an equal run
	[-c, --check, --check=diagnose-first] : do not sort, check for sorted input (anders error)

- zonder sorteren : b.v. alle directories met een of meer flac-bestand vinden
	- met awk, heeft eigen associative arrays, waarvoor we gevonden directories als key kunnen gebruiken, en zo zien of die eerder al gebruikt is :
		- vb.: maak lijst met alle directories met flac-bestanden :
			$ find "_Muziek/" -type f -iname "*.flac" -printf "%h\n" | awk '!a[$0]++'
			-printf "%h\n" : print alleen directory (zonder eind-/), met new-line achter
			- awk '!a[$0]++' : removes duplicate lines
				- OPGELET : enkele quotes '!...', want "!..." is bash history
				- a : willekeurige naam voor een array
				- $0 : hele invoerlijn van awk, in dit vb. de directorynaam
				- a[$0] : array element van 'a' met directorynaam als sleutel
				- !a[$0] : als element a[$0] niet bestaat [dan stuurt awk de invoer lijn uit naar stdout]
				- !a[$0]++ : increment array element (doet het ineens bestaan, zodat een volgende keer a[$0] met dezelfde invoerlijn WEL bestaat)
	- met bash associative arrays; moeten expliciet gedeclareerd, maar ge moet er awk niet voor leren:
		- vb.: voer opdracht uit op elke directory met flac-bestanden :
			$ find "_Muziek/" -type f -iname "*.flac" -printf "%h\n" | { declare -A a; while IFS= read -r map; do if [ ! ${a["$map"]} ]; then a["$map"]=x; opdracht $map; fi; done; }
			-printf "%h\n" : print alleen directory (zonder eind-/), met new-line achter
			- | { ... } : weerszijden van een pipe worden in een subshell uitgevoerd, waarna variabelen en cd-opdrachten verloren gaan; door opdrachtlijst binnen { } te zetten, is dat geheel 1 kant van de pipe, zodat daarbinnen variabelen en cd zichtbaar blijven
			- declare -A a : a is associative array (met keywords), anders met integers als sleutel
			- IFS= om begin- en eindspaties te behouden in read
			-r : Backslash does not act as an escape character. The backslash is considered to be part of the line. In particular, a backslash-newline pair may not be used as a line continuation.
			- "if [ ! ${a["$map"]} ]; then a["$map"]=x; opdracht $map; fi;" : als array element met key==directorynaam niet bestaat of leeg, zet dan dat array element (op een willekeurige waarde), en voer de opdracht uit
			- "${...}" : verhindert dat shell opeenvolgende whitespaces samen neemt tot 1 spatie

=== directory verwijderen ===

- lege directory
	$ rmdir mijndir

- hele tree met inhoud
	$ rm -r[f] mijndirtree
	- r : --recursive, remove directories and their contents
	- f : --force, ignore nonexistent files

- alle lege directories in tree
	- vinden:
	$ find mijndirtree -type d -empty -depth
	- -depth om exact hetzelfde zoekgedrag te hebben als bij -delete
	- verwijderen:
	$ find mijndirtree -type d -empty -delete

=== directory tree kopieren, met behoud van eigenaars en rechten ===

- kopieer bron/ naar doel/, resultaat doel/
	# cp -ax[n] bron/. doel
	- -a : --archive, combineert:
		-d : --no-dereference --preserve=links (volg links niet, maar kopieer ze wel)
		-R : recursive
		--preserve=all : bewaar niet alleen de links, ook eigenaarsschap, rechten, ...
	- -x : --one-file-system, stay on this filesystem (volg geen mounts)
	- bron/. : kopieer de self-directory van bron, niet bron zelf (dus niet naar doel/bron/). Aangezien we recursive kopieren, is dit de inhoud
	- OPM: niet bron/* /doel, want dat slaat verborgen bestanden en directories (die beginnen met .) over
	- -n : --no-clobber, do not overwrite existing file

- kopieer bron/ naar bestaand doel/, resultaat doel/bron/
	# cp -ax[n] bron doel
	- OPM: als doel nog NIET bestaat, wordt het gemaakt en komt enkel de inhoud van bron erin, niet bron als subdirectory doel/bron/

=== directory tree vergelijken ===
	$ diff -rqN -x=pattern dir1/ dir2/ | tee bestand
	- -r : recursive
	- -q : --brief, "quiet", meldt alleen als er verschillen zijn
	- -N : treat absent files as empty (en geeft dus verschil als het bestand in 1 tree bestaat en niet leeg is)
		- variant: --unidirectional-new-file : treat absent first files as empty
	- -x : --exclude=pattern, exclude files that match 'pattern'
		- variant: -X : --exclude-from=FILE, exclude files that match any pattern in FILE
	- | tee bestand : stuurt stout naar stdout én bestand
b.v.	# diff -rqN -x=.swapfile /media/sdata/. /media/tarch/. | tee /media/ramdisk/difftree

=== Backup restoren naar Virtualbox VM met EFI boot ===

- zie "_VM model restore Ubuntu-backup.txt"

=== in standby of uit zetten na verloop van tijd (b.v. 45 minuten) ===

- zie ook sectie "uitvoeren na einde van een opdracht"
- voor standby of uit na download met nzbget: zie hierna
- standby of uit na vast aantal minuten:
	$ sleep 45m ; standby
	- standby is mijn .bash-aliases alias voor "systemctl suspend"
	$ sleep 45m ; uit
	- uit is mijn .bash-aliases alias voor "shutdown now"

=== in standby of uit zetten na nzbget einde ===

- op download naam klikken
- knop [Postprocess -> ]
- procedure (eigen script) postproc_standby (of postproc_shutdown) op 'yes'
- save
- OPM: met postproc_standby blijft ramdisk behouden om evt. download fouten nog op te lossen, bij postproc_shutdown niet, maar bij fout is de download sowieso niet klaar, dus dan wordt die procedure niet aangeroepen

=== prioriteit van een taak instellen ===

- nieuwe taak : start de taak met voorvoegsel 'nice ' of 'nice -n niceness ', bij voorbeeld om taak met lage prioriteit te laten draaien
	$ nice hercomprimeervideo.sh
	- niceness [-20,19] is bereidheid om tijd af te staan aan andere taken.
	- uit niceness en realtime of niet berekent het systeem een prioriteit als 20 - niceness
	- in uitvoer van 'top' staan de kolommen PRioriteit en NIceness
	- zonder 'nice' start een taak met niceness 0
	- met 'nice ' start een taak met niceness 10
	- met 'nice -n niceness ' start een taak met de opgegeven niceness
	- voor niceness < 0 is root nodig

- bestaande taak (processid nodig)
	$ renice -n niceness -p processid

=== opstartboodschap "system program problem detected" verhelpen ===

- apport-gtk-root meldt programma-fouten aan hun auteurs: diagnose met extensie .crash  in /var/crash/. Bij volgende boot vraagt dialoog "system program problem detected" of apport-gtk-root melding mag sturen. Bedoeling is dat elk soort crash maar 1 keer gerapporteerd wordt (middels lege dummy bestanden xxx.upload en xxx.uploaded), maar de foutmelding blijft komen zolang het .crash-bestand bestaat :
	$ ll /var/crash/
	# rm /var/crash/*
	- verwijdert alle bestaande crash diagnoses

- B.v. VirtualBox maakt hier gebruik van, en sluit al eens een VM fout af. Nuttig voor de ontwikkelaars, maar niet als ge ettelijke versies achterloopt.

- crashreport systeem uitschakelen vanaf volgende boot
	$ sudo nano /etc/default/apport : wijzig als volgt
		"enabled=0"
	- uitschakelen zonder reboot (volgens bestand zelf)
		$ sudo service apport start force_start=1
		- volgens bestand zelf (en stackexchange)
	- uitschakelen zonder reboot (sinds Ubuntu 16.04)
		- a different syntax than just restart is needed to restart apport. 16.04 uses systemd to manage services :
		$ sudo systemctl restart apport

- In ~/.apport-ignore.xml staan programmas waarvoor geen crashraport meer moet gemaakt worden. Ik weet niet hoe ze daarin gezet worden. De mtime (wschlk. modification time) is misschien een manier om de 'versie' van het programma aan te geven

=== urlencode ===

- definieer deze functie in bash, (b.v. door ze gewoon naar terminal te kopiëren :
	- niet inspringen of met voorloopspaties, maar geen tabs!
	- laatste lijn, leeg op 1 spatie na is handig, om LF na "} ;" mee te nemen
	>>>
		codeerurl() {
			local string="${1}";
			local strlen=${#string};
			local encoded="";
			local pos c o;
			for (( pos=0 ; pos<strlen ; pos++ ));
			do
			c=${string:$pos:1};
			case "$c" in
				[-_.~a-zA-Z0-9] ) o="${c}" ;;
				* )               printf -v o '%%%02x' "'$c";
			esac;
			encoded+="${o}";
			done;
			# You can the result (EASIER)
			echo "${encoded}";
			# or set a return variable (FASTER)
			#REPLY="${encoded}";
		};
	<<<

- aanroepen als volgt:
	$ codeerurl http://www.url.be?zoek=term&taal=nl
	of
	$ codeerurl "http://www.url.be?zoek=woord1 woord2&taal=nl"
	of (om resultaat in commando te gebruiken)
	$ doeiets `codeerurl  "http://www.url.be?zoek=woord1 woord2&taal=nl"`

=== computernaam wijzigen ===

- in 2 bestanden aanpassen :
	- /etc/hostname
	- /etc/hosts lijn met 127.0.1.1
		>>> [https://askubuntu.com/a/754216/1020749] en Section 10.4 of the (Debian Reference Manual)[http://qref.sourceforge.net/quick/ch-gateway.en.html].
		If your system has a permanent IP address then use that; otherwise use the address 127.0.1.1
		<<<

- zonder herstarten toepassen (lukt niet altijd) :
	# service hostname start

=== Mr Sid converteren ===

	$ for i in *.sid; do /opt/GeoExpress/bin/mrsidgeodecode -i "$i" -o /media/ramdisk/"$i".jpg;done
	- .jpg 3-4 keer zo groot als .sid
	- andere opties :
		$ /opt/GeoExpress/bin/mrsidgeodecode -h : korte help
		$ /opt/GeoExpress/bin/mrsidgeodecode -help : lange help


=== Schermopstelling wijzigen ===

- met xrandr, CLI-interface voor RandR (X Resize, Rotate and Reflect Extension)
	$ xrandr --help

- lijst van monitors ("outputs") en hun modes, met '+' na preferred modes en '*' na current mode
	$ xrandr -q
	OF
	$ xrandr --current	# zonder pollen naar gewijzigde hardware
	OF
	$ xrandr			# waarschijnlijk == -q
	- via aliassen in ~/.bash-aliases, en scripts in ~/bin/beeld* om hotkeys toe te wijzen of ook geluidsinstelling te wijzigen

- beeldinstelling van een monitor wijzigen, b.v. :
	$ xrandr --output HDMI-2 [--mode 1280x1024] [--rate 60.02] [--rotate left] [--pos XxY | [--left-of | --right-of | --above | --below | --same-as] another-output ] [--gamma 1.2:1.3:1.1] [--brightness 1.5]
	--output : de monitor die op die output is aangesloten
	--mode [naam | WxH], -s WxH, --size WxH : de gewenste (al dan niet benoemde) resolutie
	-r, --rate : een geldige verversingssnelheid voor die resolutie (zie "$ xrandr")
	--rotate : stand (normal, left, right, inverted)
	--pos : positie van de monitor op output HDMI-2 in een multi-monitor-screen van X11
	--left-of HDMI-1 : positie van monitor is links van b.v. HDMI-1 in een multi-monitor-screen van X11
	--gamma red:green:blue : floating point values
	--brightness brightness : floating point value
	- andere opties:
	     --panning    widthxheight[+x+y[/track_widthxtrack_height+track_x+track_y[/border_left/border_top/border_right/border_bot‐
       tom]]]
       --transform a,b,c,d,e,f,g,h,i	# transformation matrix
											 a b c
											 d e f
											 g h i
       --scale XxY			# shortcut version of the --transform option.
       --scale-from wxh		# shortcut version of the --transform option.
       --primary			# Set the output as primary. It will be sorted first in Xinerama and RANDR geometry requests.

- beeldinstelling van een monitor herstellen, maar met rotatie :
	$ xrandr --output HDMI-2 --preferred --rotate left

- uitvoer naar monitor stoppen:
	$ xrandr --output HDMI-1 --off

- uitvoer naar monitor stoppen als hij niet aangesloten is, of starten in -preferred mode als hij wel aangesloten is:
	$ xrandr --output HDMI-1 --auto

=== Scherm roteren in tty-terminal ===

- zie https://www.kernel.org/doc/Documentation/fb/fbcon.txt "Framebuffer Console"

- in tty-terminals mijn Viewsonic scherm roteren naar portrait :
	- tijdelijk : vie tee om een sudo in de redirect te kunnen doen
		$ echo 3 | sudo tee /sys/class/graphics/fbcon/rotate
	- blijvend : in /etc/default/grub of /etc/default/grub.d/mijndefaults.cfg
		>>> GRUB_CMDLINE_LINUX="fbcon=rotate:3" <<<
		>>>
		GRUB_CMDLINE_LINUX
			Entries on this line are added to the end of the 'linux' command line (GRUB legacy's "kernel" line) for both normal and recovery modes. It is used to pass options to the kernel.
		GRUB_CMDLINE_LINUX_DEFAULT
			This line imports any entries to the end of the 'linux' line (GRUB legacy's "kernel" line). The entries are appended to the end of the normal mode only.
		<<<
	- terug landscape : 0 i.p.v. 3

=== helderder beeld ===

- b.v. om video te spelen op monitor; puur software regeling, en niets voor overlay apart
	- Bionic HDMI-n, Xenial : HDMIn
	$ xrandr --output HDMI-2 --brightness 1.2 --gamma 1.6:1.6:1.6
	- voor hardware regeling helpt misschien xbacklight (te installeren)

=== zelf schermresolutie definieren ===

- met xrandr kunt ge eigen schermresoluties toevoegen:

- gebruik cvt om de timings voor een bepaalde resolutie te berekenen:
	$ cvt 1280 800 60	# horz vert [verversingssnelheid (default 60)]
	>>>
		# 1280x800 59.81 Hz (CVT 1.02MA) hsync: 49.70 kHz; pclk: 83.50 MHz
		Modeline "1280x800_60.00"   83.50  1280 1352 1480 1680  800 803 809 831 -hsync +vsync
	<<<
	- geef alles van de 2de lijn na "Modeline" aan xrandr als waarde van de optie --newmode
		$ xrandr --newmode "1280x800_60.00"   83.50  1280 1352 1480 1680  800 803 809 831 -hsync +vsync
	- kijk na of de nieuwe mode bestaat
		$ xrandr
		>>>
			Screen 0: minimum 320 x 200, current 1200 x 1920, maximum 8192 x 8192
			HDMI-1 connected (normal left inverted right x axis y axis)
			   ...
			HDMI-2 connected primary 1200x1920+0+0 left (normal left inverted right x axis y axis) 547mm x 350mm
			   ...
			DP-1 disconnected (normal left inverted right x axis y axis)
			HDMI-3 disconnected (normal left inverted right x axis y axis)
			  1280x800_60.00 (0x1a3) 83.500MHz -HSync +VSync
					h: width  1280 start 1352 end 1480 total 1680 skew    0 clock  49.70KHz
					v: height  800 start  803 end  809 total  831           clock  59.81Hz
		<<<
	- wijs de nieuwe mode toe aan een monitor :
		$ xrandr --addmode HDMI-2 "1280x800_60.00"
	- test nu of ze werkt : doe Ctrl-C om de ingestelde nieuwe mode te bewaren als ze werkt, anders gaat de monitor na 5s terug naar zijn voorkeursinstelling
		$ xrandr --output HDMI-2 --mode "1280x800_60.00" --rotate left;sleep 5s; xrandr --output HDMI-2 --preferred

- blijven niet bewaard over opstarten heen:
	- zet de "xrandr --newmode" en "xrandr -addmode" in uw ~/.profile (executed by the command interpreter for login shells)
	OF
	- definieer de mode in /usr/share/X11/xorg.conf.d/
	>>>
		Section "Monitor"
		  Identifier "Monitor0"
		  <INSERT MODELINE HERE>
		EndSection
		Section "Screen"
		  Identifier "Screen0"
		  Device "<INSERT DEVICE HERE>"
		  Monitor "Monitor0"
		  DefaultDepth 24
		  SubSection "Display"
			Depth 24
			Modes "<INSERT MODENAME HERE>"
		  EndSubSection
		EndSection
		<<<

=== cat zonder commentaar en lege lijnen ===

- zie ~/bin/compcat

- laat alle lijnen weg die leeg zijn, of volledig blank (spatie of tab) op '#'-commentaar na
	$ grep -vE "^[ \t]*(#.*| *)$" bestand...
	-E : extended regexp
	[-h] : print zonder bestandsnaam, zelfs als er meer bestanden gegeven zijn
	[-H] : print met bestandsnaam, zelfs als er maar 1 bestand gegeven is

=== pythons CLI Web Server gebruiken ===

- zie "https://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python"
	$ cd webroot
	$ python -m SimpleHTTPServer [poort]
	OF
	$ python3 -m http.server [poort]
	Ctrl-C : beëindigen
	- default poort 8000, IP 0.0.0.0 (maar luistert dan ook op 127.0.0.1)
	- andere IP, b.v. localhost :
	>>> mijnserver.py
		#! /usr/bin/python
		import sys
		import BaseHTTPServer
		from SimpleHTTPServer import SimpleHTTPRequestHandler
		HandlerClass = SimpleHTTPRequestHandler
		ServerClass  = BaseHTTPServer.HTTPServer
		Protocol     = "HTTP/1.0"
		if sys.argv[1:]:
			port = int(sys.argv[1])
		else:
			port = 8000
		server_address = ('127.0.0.1', port)
		HandlerClass.protocol_version = Protocol
		httpd = ServerClass(server_address, HandlerClass)
		sa = httpd.socket.getsockname()
		print "Serving HTTP on", sa[0], "port", sa[1], "..."
		httpd.serve_forever()
	<<<

=== php's CLI Web Server gebruiken ===

- zie "http://php.net/manual/en/features.commandline.webserver.php"

- enkel vanop eigen pc toegankelijk
	$ cd ~/webroot
	- b.v. met de php-installatie van mijn Bitnami nginx stack :
		$ ~/nginxstack-1.9.14-0/php/bin/php -S localhost:8000
		-S serveradres
		[ -t path-to-webroot] : absoluut of relatief, default is current directory
		[-c php.ini] : set configuration options
		- Ctrl-C om af te sluiten (NIET Ctrl-Z : maakt server onbereikbaar, maar proces blijft lopen en poort bezetten)
		- default home pagina is index.php, dan index.html

- toegankelijk vanop andere pc's
	$ ~/nginxstack-1.9.14-0/php/bin/php -S 0.0.0.0:8000

- Using a Router Script
	- vb. : requests for images will display them, but requests for HTML files will display "Welcome to PHP":
	>>> router.php
		<?php
		if (preg_match('/\.(?:png|jpg|jpeg|gif)$/', $_SERVER["REQUEST_URI"])) {
			return false;    // serve the requested resource as-is.
		} else {
			echo "<p>Welcome to PHP</p>";
		}
		?>
	<<<
	$ php -S localhost:8000 router.php

=== grep een tab ===

- alleen perl-regexp van grep herkennen een tab-escape :
	$ grep -P "xxx\tyyy" ...

- alternatief : de tab op een andere manier in het grep-pattern krijgen
	- command substitution met printf :
		$ grep "xxx$(printf '\t')yyy"
	- command substitution met echo :
		$ grep "xxx$(echo -e '\t')yyy"
	- bash string quoting : Words of the form $'string' are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard.
		$ grep $'xxx\tyyy'
		- om b.v. te combineren met variable expansion, gewoon 2 (quoted) strings concateneren, b.v.
			$ grep $'xxx\tyyy'"en een $variabele"

=== grep als cat met highlights ===
- voorbeeld : toon volledige uitvoer, maar met highlight
	$ apt-cache show node.js | grep -e "^" -e "^Description"
	-e "^" : matcht elk lijnbegin, toont dus elke lijn, maar heeft niets te highlighten
	-e "^Description" : heeft wel iets te highlighten

=== opdracht uit bash history terug uitvoeren ===

- bash history shortcuts
	[Esc]^	: history-expand-line
	[Esc][Ctrl]+i	: dynamic-complete-history
	[Esc]>	: end-of-history
	[Esc]<	: beginning-of-history
	[Ctrl]+s	: forward-search-history
	[Esc]n	: non-incremental-forward-search-history
	[Ctrl]+r	: reverse-search-history
	[Esc]p	: non-incremental-reverse-search-history
	[Esc]OA	: previous-history
	[Esc][A	: previous-history
	[Ctrl]+p	: previous-history
	[Esc]OB	: next-history
	[Esc][B	: next-history
	[Ctrl]+n	: next-history
	- zie ook _Xubuntu.adoc sectie ".inputrc gemaakt" : selectief door history bladeren met pijl omhoog/omlaag a.d.h.v begin-string opdracht :
		"\e[A": history-search-backward
		"\e[B": history-search-forward

- !-1 : vorige opdracht
	- !-2 : opdracht daarvoor
	...
	- voor wijzigingen aan opdracht, zet ':' + modifiers achter het nr., b.v.
		$ !-2:gs=drama=griezel=
		- Voert de op 2 na laatste opdracht terug uit, maar met modifier (de ':') om alle (de 'g') "drama" te vervangen (de 's') door "griezel"; '=' is een zelf te kiezen scheidingsteken, zoals voor de sed-opdracht s.
		- [Esc]^ OF Alt-^ (d.w.z. Alt-Shift-6) i.p.v. <Enter> : breidt de opdrachtlijn uit tot de opdracht uit history met de vervanging
		- Alt-Ctrl-E idem, maar dan worden ook variabelen (en aliassen) ingevuld, en dat is dikwijls vervelend.

- opdrachtgeschiedenis van bash is zoekbaar (met grep) en genummerd. b.v. wat heb ik nu ook weer gedaan met het bestand "floep" :
	$ history | grep "floep"
	>>>
		231 echo $REPLY > floep
		235 ls -l floep
		238 cat floep
	<<<
	- zet opdracht 238 terug op de opdrachtlijn met shell-expand-line toetsencombinatie <Alt>+<Ctrl>+e : Expand the line as the shell does (alias, history en shell word expansions)
		$ !238 # <Alt>+<Ctrl>+e (Expand)
			$ cat floep
		- alternatief: enkel history-expand-line met <Alt>+<Shift>+^ (Shift omdat ^ boven de 6 staat), dus geen variabelen of aliassen
	- voer opdracht 238 terug uit met <Enter>
		$ !238 # <enter>
		>>>
			cat floep
			....
		<<<

=== history wissen ===

- alle behalve open terminals :
	$ rm $/.bash_history

- sommige opdrachten
	$ mousepad ~/.bash_history

- huidige bash prompt
	- enkel vorige opdrachten niet toevoegen, latere wel :
		 $ history -c
		 - wist hele history list die in current terminal is ingeladen van uit history file en van nieuwe opdrachten
		 - wijzigt history file (~/.bash_history) niet
		 - is een bash-opdracht, heeft geen eigen man :
			$ help history
	- vorige noch volgende opdrachten toevoegen bij afsluiten bash prompt
		$ unset HISTFILE
		OF
		$ HISTSIZE=0
	- opdrachtgeschiedenis terug helemaal inlezen :
		$ history -r
		- handig na wissen history huidige shell met 'history -c'
	- opdrachtgeschiedenis van ene shell/terminal overdragen naar andere :
		- ene shell : opdrachtgeschiedenis opslaan
			$ history -a
				-a : append opdrachtgeschiedenis aan .bash_history
			OF (sluit die shell)
			$ exit
		- andere shell
			$ history -n
			-n : leest nieuwe lijnen uit .bash_history (elke bash shell onthoudt dus nr. laatst ingelezen lijn)

=== genummerde bestanden van ramdisk naar HDD verplaatsen naarmate ze aangemaakt worden ===

- een reeks bestanden aanmaken op ramdisk, kan ze vol doen lopen (b.v. media-bestanden in niet-gecomprimeerd formaat). Als ze genummerd zijn, in dit vb. van 01 tot 08, kunt ge ze naar HDD verplaatsen telkens als het volgende bestand gemaakt wordt :
	- genummerd zonder voorloopnullen :
		$ for i in {2..99};do while ! [ -f $i*.avi ] ; do sleep 10;done;mv $((i-1))*.avi /media/sdata/WERK;done;klaar;sleep 30;cp $i*.avi /media/sdata/WERK/;sleep 30;slaap
			- als bestand 2 verschijnt, wordt verondersteld dat bestand 1 klaar is, en dat wordt naar HDD verplaatst
			- als alles klaar is (volgens mijn script "klaar") wordt tenslotte het laatste bestand (99 in dit voorbeeld) naar de HDD gekopiëerd (niet verplaatst, om niet te struikelen over evt. foute interpretatie van "klaar")
		- OPM : in $(()) moet er geen $ voor shell-veranderlijken, maar het mag wel; is wel nodig voor {} parameter expansion syntax
			- zonder $ wordt de veranderlijke, als dat al een formule is, uitgerekend alsof ze tss. haakjes staat, b.v.:
				$ avg_frame_rate=60000/1001
				$ echo $((avg_frame_rate))
				>>> 59 <<<
				$ echo $((avg_frame_rate*100))
				>>> 5900 <<<
				$ echo $((100*avg_frame_rate))
				>>> 5900 <<<
				$ echo $((100*$avg_frame_rate))
				>>> 5994 <<<
		- NIET "for i in {02..99}" : i zelf is string, maar in $(()) wordt die string geinterpreteerd als getal, octaal als er een voorloop-0 is, en 08 en 09 zijn octaal niet geldig
			- voorloop-0 van i evt. verwijderen met $((${i#0}-1) : remove prefix 0
			- evt. expliciteren dat i radix 10 heeft :  $((10#$i-1)) : syntax is radix#string; moeten dan wel $i gebruiken, want i zou geïnterpreteerd worden als digit, en dit zou in dit vb. " value [d.w.z. i] too great for base [d.w.z. 10]" geven
		- NOOIT voorloopnullen in output van $(())
	- genummerd met altijd 1 voorloopnul, 01 tot 10 :
		- expliciet de voorloopnul toevoegen wanneer we van i een bestandsnaam maken :
		$ for i in {2..9};do while ! [ -f 0$i*.avi ] ; do sleep 10;done;mv 0$((i-1))*.avi /media/sdata/WERK;done;klaar;sleep 30;cp 0$i*.avi /media/sdata/WERK/;sleep 30;slaap
	- genummerd met 1 voorloopnul wanneer < 10 (i.e. meer dan 10 bestanden 01,...,09,10,...) :
		- expliciet de voorloopnul toevoegen wanneer we van i < 10 een bestandsnaam maken :
		$ for i in {2..99};do while ! [[ -f 0$i*.avi || -f $i*.avi ]] ; do sleep 10;done;[[ $((--i)) -lt 10 ]] && i=0$i;mv  $i*.avi /media/sdata/WERK;done;klaar;sleep 30;cp $((++i))*.avi /media/sdata/WERK/;sleep 30;slaap
			- werken met 1 variabele, die we decrementen als we vorige bestandsnaam maken om te verplaatsen, maar dan moeten we wel terug incrementen om laatste bestandsnaam te maken

=== status van iets opvolgen ===

- watch voert in een tijdloop herhaaldelijk dezelfde opdracht uit, b.v.
	$ watch cat mijn.log
		- geeft om de 2 seconden de opdrachtstring 'cat mijn.log' door aan /bin/sh (de nodige aanhalingstekens gebruiken om pipes, redirects, $x, ... pas door sh te laten evalueren)
		- toont bovenin een 'titel'-lijn met interval, opdracht, tijdstip laatste herhaling
		-n, --interval seconds.decimals : update interval, default 2 seconds
		-x, --exec : pass the command to exec instead of to /bin/sh
		-d, --differences[=permanent] : Highlight the differences between successive updates. "permanent" [of elke andere =x] allows to see what has changed at least once since first iteration.
		-p, --precise : Make watch attempt to run command every interval seconds. Try it with ntptime and notice how the  fractional  seconds stays (nearly) the same, as opposed to normal mode where they continuously increase.
		-t, --no-title : Turn off the header showing the interval, command, and current time at the top of the display, as well as the following blank line.
		-b, --beep : Beep if command has a non-zero exit.
		-e, --errexit : Freeze updates on command error, and exit after a key press.
		-g, --chgexit : Exit when the output of command changes.
		-c, --color : Interpret ANSI color and style sequences
			- komt neer op kleuruitvoer behouden
			- OPM: grep e.a. geven default alleen kleuruitvoer naar terminal, niet naar pipe :
				$ grep --colour=always
			- OPM: geeft conflict met -d=permanent

=== torrent's magnet link maken van info hash ===

- een magnet link van een torrent heeft de structuur magnet:sleutel=waarde[&sleutel=waarde]..., met de volgende sleutels en waarden :
	- xt=urn:btih: gevolgd door de infohash (b.v. getoond op YourBitTorrent, die zelf geen magnet links geeft)
	- dn= gevolgd door downloadnaam (URL-encoded, d.w.z. o.a. spaties vervangen door %20)
	- tr=udp://tracker.archlinux.org:6969 : 1 of meer trackers, kunnen in Transmission ook nadien toegevoegd worden. De magnet links van [http://rarbgaccess.org/] hebben gewoonlijk maar een tracker of 3, meer zijn te vinden op o.a. [https://newtrackon.com/list]

=== gepersonaliseerde e-mail naar lijst ===

- bericht-template maken op ramdisk, met b.v. "veld" %%1 te vervangen door titel + achternaam
- In Thunderbird/Edit/Preferences/Advanced/Config-editor zoeken naar de From-identiteit waarmee ge de e-mail wilt sturen, hier "id9"
- namen en adressen exporteren naar .csv, b.v. in volgorde titel, achternaam, voornaam, e-mailadres
- loop met read over die .csv
- template met sed naar gepersonaliseerd bericht
- gepersonaliseerd bericht als message aan thunderbird -compose geven :
	$ export i=0;while IFS=, read -r titel anaam vnaam adres;do ((i++)); to="$vnaam $anaam <$adres>"; sed -E "s|%%1|$titel $anaam|" /media/ramdisk/template >/media/ramdisk/bericht$i;thunderbird -compose "to='$to',format='2',preselectid=id9,subject='Het belang van een eerste minister uit eigen partij',message='/media/ramdisk/bericht$i'" ;done < CD\&V\ Burgemeesters\ 2019-2024.csv
	- thunderbird -compose opties (allemaal in 1 waarde-string)
		- format='2' : tekstformaat, ='1' : HTML-formaat (allebei UTF-8)
		- message=bestandsnaam : de body komt uit het bestand (!= bijlage)
		OF
		- body='tekst van het bericht'

=== meerdere tty gebruiken ===

- zie ook sectie "in tty of console de display draaien"
- zie ook sectie "welke tty in gebruik"
- zie ook (https://wiki.ubuntu.com/Multiseat)
- zie ook (https://help.ubuntu.com/community/MultiseatOneCard)

- Met Ctrl+Alt+F[1-7] kunt ge wisselen tss. de 7 tty-terminals die Ubuntu maakt. De default GUI start in tty7
	- Ubuntu toont het tty-nummer zelf, anders:
		$ tty
	- in elke tty kunt ge inloggen met dezelfde of met een verschillende gebruiker
		- zie sectie "in tty of console de display draaien"
	- in VirtualBox VM is de toetscombinatie [Hostkey]+F[1-7]
		- OPGELET: met [Hostkey] verliest VM ook keyboard focus aan VM-host. Let vooral op met sneltoetsen op dat moment.

=== in tty of console de display draaien ===

- is tegenwoordig altijd via framebuffer
	- als root:
		# echo 3 > /sys/class/graphics/fbcon/rotate
		OF
		# echo 3 > /sys/class/graphics/fbcon/rotate_all
		- 0 : rotate   0°
		- 1 : rotate  90° clockwise
		- 2 : rotate 180° clockwise
		- 3 : rotate 270° clockwise
	- als user: redirect gebeurt voor sudo, misbruik daarom tee om in sudo naar bestand te schrijven:
		$ echo 3 | sudo tee /sys/class/graphics/fbcon/rotate

=== GUI starten in een tty ===

- zie ook sectie "meerdere tty gebruiken"

- In elke tty kan een GUI gestart worden
	- dit b.v. gebruikt verder tty2 en X11-DISPLAY :1 (de default, op tty7, is :0)
    - Ctrl+Alt+F2 : ga naar tty2
	- log in
	- zie sectie "in tty of console de display draaien"
    - start Xserver (NIET als sudo) :
		- OPM: lightdm hiervoor gebruiken zou niet kunnen, zou te simpel zijn om een display op te geven. Mij lukte het zeker niet
		$ startx -display :1 -- :1
		OF (vollediger)
		$ startx -display :1 -- :1 vt2 &
			- met de '2' in vt2 het tty-nr
			- opties vóór '--' zijn opties voor de X11 client (xinit), die erna voor de X11 server
			- '&' : in background, is dit nodig?
		- startx delegeert zijn parameters naar xinit, met volledige syntax:
			"xinit [[client] options ...] [ -- [server] [:n] options ...]"
				- default client is xterm, met o.a. optie "-display :n", met n zelfde displaynr. als aan serverkant van de '--'
		- X11 toont nu een xterm terminal-venster (met bash, ngl. gebruikersconfig), maar zonder vensterdecoraties (dus ook geen frame menu, sluitknoppen, ...)
			- aanklikken om focus te geven
			- Daarin kunt ge ook GUI programmas starten, maar zorg dat ge de prompt terug krijgt, want ge hebt nog maar 1 terminal:
				- OFWEL met mijn 'spawn', b.v.
					$ spawn mousepad
				- OFWEL opdracht afsluiten met '&', b.v.
					$ mousepad &
			- om meer en controleerbare vensters te gebruiken, start ge een windowmanager of ineens de hele desktop (die ook xfwm4 start):
				$ spawn xfce4-session
				OF alleen windowmanager
				$ xfwm4 --daemon &
		- OPGELET:
			- met zelfde bestanden openen als in een andere tty
				- DENK OM config-bestanden
			- In VM opletten met de toetsen Host+Fn waarmee ge van terminal wisselt: met Host-toets verliest VM ook keyboard focus, en gaat die terug naar de VM-host. Let vooral op met sneltoetsen op dat moment.

- OPM: in 2de DISPLAY opnemen van het scherm met ffmpeg werkt (-f x11grab ... -i :1.0+x,y), maar bij wisselen van tty is die DISPLAY niet meer gekoppeld aan de grafische kaart, en dan neemt ffmpeg gewoon zwart beeld op.

=== CUPS configureren ===

- Common? Unix Printer Spooler

- te configureren op http://localhost:631/
	- daar ook online handleiding
	- volgens Ubuntu docu wordt cups-genppd al een tijd niet meer geinstellerd met gutenprint omdat dat niet meer nodig is. Hoe de geinstalleerde printerdriver voor gutenprint dan met cups moet werken, staat er niet bij.

=== asciidoc naar markdown ===

- geen tool die dat rechtstreeks kan, wel via AsciiDoctor naar docbook, en met pandoc van docbook naar b.v. markdown :
	>>> (https://gist.github.com/cheungnj/38becf045654119f96c87db829f1be8e)
	- Adapted from https://tinyapps.org/blog/nix/201701240700_convert_asciidoc_to_markdown.html
	- Using asciidoctor 1.5.6.1 and pandoc 2.0.0.1
	- Install pandoc and asciidoctor : beide werken ook zonder installeren, zie GEZIPTE.PRG/Xubuntu
			0 sudo apt install asciidoctor
			0 sudo wget https://github.com/jgm/pandoc/releases/download/2.0.0.1/pandoc-2.0.0.1-1-amd64.deb
			0 sudo dpkg -i pandoc-2.0.0.1-1-amd64.deb
	- Convert asciidoc to docbook using asciidoctor
		$ asciidoctor -b docbook foo.adoc
		- foo.xml will be output into the same directory as foo.adoc
	- Convert docbook to markdown
		$ pandoc --wrap=none -f docbook -t gfm foo.xml -o foo.md
		--wrap=none : else Pandoc inserts hard line breaks at 72 characters
		[--columns=120] : insert line breaks at 120 chars
	- Unicode symbols were mangled in foo.md. Quick workaround:
		$ iconv -t utf-8 foo.xml | pandoc -f docbook -t gfm | iconv -f utf-8 > foo.md
	<<<

== RSYNC ==

=== MIJN VOORKEUR voor synchronisatie van directories ===

- ntfs heeft geen permissies, owners en group owner zoals ext4, daarom deze opties meegeven :
	NTFSopts=" --no-p --no-g --no-o "

- rsync heeft zoveel opties, en is zo gevoelig aan '\' :
	ALTIJD : -n, --dry-run : perform a trial run with no changes made

	- voor EXTn schijven (linux) :
		$ rsync -aASXx [-civ] [--delete | --delete-before] bronpad/ doelpad/
		-a , --archive	: archive mode; equals -rlptgoD (no -H,-A,-X) (preserve symbolic links, devices, attributes, permissions, ownerships, etc.)
		-A, --acls : preserve ACLs (implies -p)
		-S, --sparse : handle sparse files efficiently
		-X, --xattrs : preserve extended attributes
		-x, --one-file-system : (o.a. linux eigen mounts her en der niet archiveren)
		[-c, --checksum] : skip based on checksum (duurt VEEL langer), not mod-time & size
		[-i, --itemize-changes] : output a change-summary for all updates
		[-v, --verbose] : increase verbosity
		[--delete] : delete extraneous files from dest dirs
		[--delete-before] : receiver deletes before xfer, not during (variant op --delete, geen optie van)
	- voor NTFS schijven (Windows en veel USB) :
		$ rsync -rltDSx [-civ] [-delete | --delete-before] bronpad/ doelpad/
		-rltD : -a --no-o --no-g --no-p, want FAT/NTFS kent geen linux -o (owner), -g (group) of -p (permissions), zouden fouten geven
		- sudo misschien niet nodig bij rsync, maar b.v. wel voor Meld omdat die bij 'delete' naar .Trash wil moven
	- voor FAT en FAT32 schijven (DOS en kleine USB) :
		$ rsync -rltD -x
		-rltD : -a --no-o --no-g --no-p, want FAT/NTFS kent geen linux -o (owner), -g (group) of -p (permissions), zouden fouten geven

=== test of te verwachten resultaat nakijken ===
	$ rsync -niv ...
	-n, --dummy : geen wijzigingen aanbrengen
	-i, --itemize-changes : output a change-summary for all updates
	-v, --verbose : increase verbosity

=== archive mode ===
	-a , --archive	: archive mode; equals -rlptgoD (no -H,-A,-X) (preserve symbolic links, devices, attributes, permissions, ownerships, etc.)
		-r, --recursive	: recurse into directories
		-l, --links	: copy symlinks (as symlinks, zonder -l geheel niet)
		-p, --perms	: preserve permissions
		-t, --times	: preserve modification times
		-g, --group	: preserve group
		-o, --owner	: preserve owner (super-user only)
		-D		: same as --devices --specials
			--devices	: preserve device files (super-user only)
			--specials	: preserve special files
	- FAT/NTFS-schijven : -rltD : -a --no-o --no-g --no-p, want FAT/NTFS kent geen linux -o (owner), -g (group) of -p (permissions), zouden fouten geven
	- in afwachting van voldoende kennis, doe ik daar zelf ook de volgende bij
		-A, --acls : preserve ACLs (implies -p)
		-X, --xattrs : preserve extended attributes
		- heeft een paar maar-en, en ik gebruik hard links zelf (nog) niet:
			0 -H, --hard-links : preserve hard links (look for hard-linked files in the source and link together the corresponding files on the destination.  Without this option, hard-linked files in the source are treated as though they were separate files.)
		-x, --one-file-system : (o.a. linux eigen mounts her en der niet archiveren)
		-S, --sparse : handle sparse files efficiently
	- soms ook deze :
		--safe-links : (enkel effect samen met -l) ignore absolute symbolic links and symlinks that point outside the copied tree (oppassen samen met --relative)

=== verschil tussen bronmappen met en zonder eind-'/' ===
	>>> man rsync
		Put a trailing slash on the source to avoid creating an additional directory level at the destination. You can think of a trailing / on a source as meaning "copy the contents of this directory" as opposed to "copy the directory by name", but in both cases the attributes of the containing directory are transferred to the containing directory on the destination. In other words, each of the following commands copies the files in the same way, including their setting of the attributes of /dest/foo:
				  rsync -av /src/foo /dest
				  rsync -av /src/foo/ /dest/foo
	<<<
	- eind-'/' maakt geen verschil voor doelmap
	- bron MET eind-'/' : onbenoemde submapstructuur synchroniseren met doelpad
		$ rsync -aAXxSiv bronpad/ doelpad
		OF
		$ rsync -aAXxSiv bronpad/ doelpad/
		- bestanden en alle submappen en submaptrees van bronpad/ komen in doelpad/
	- enkel submap, ZONDER eind-'/' : benoemde submapstructuur synchroniseren naar doelpad
		$ rsync -aASXxiv bronpad/submap doelpad
		OF
		$ rsync -aASXxiv bronpad/submap doelpad/
		- submap zelf, met bestanden en submaptrees, wordt gesynchroniseerd met of gecopiëerd als doelpad/submap

=== nakijken betrokken bronbestanden : 1 bron, en geen doel opgeven ===
	$ rsync -opties bron
	- Usages with just one SRC arg and no DEST arg will list the source files instead of copying

=== subtree van volledige pad synchroniseren met overeenkomende subtree in doel ===
	$ rsync -R -aAXxSiv pad/van/./sub/tree doel/
	- -R, --relative : Use relative paths. This means that the full path names specified on the command line are sent to the server rather than just the last parts of the filenames.
	- "./" invoegen om deelpad te markeren
	- inhoud van sub/tree in pad/van wordt gesynchroniseerd (vergelijken en kopieren) met doel/sub/tree

=== volledige backup with rsync ===
	- zie ook sectie "backup maken"
	# rsync [-n] [--delete] -aAXxSiv --exclude={"/dev/*","/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*", "/media/*", "/lost+found"} bron/ doel
	- OPGELET : bron/ MET eind-'/'
	- OPGELET : GEEN SPATIES in --exclude={dir1,dir2} voor bash brace expansion naar "--exclude=dir1 --exclude=dir2", dus met "=", en "," maar geen ", "
	- OPGELET : argumenten met "*" tussen quotes "" om globbing te voorkomen
		- globbing, oftewel "pathname expansion", zou dan wel zijn van b.v. "--exclude=/dir1*", dus waarschijnlijk geeft dat geen resultaat, maar met "shopt -s globstar" zou die expansie dan gewoon wegvallen, en dat kan nooit de bedoeling zijn.
	[-n, --dry-run] : perform a trial run with no changes made
	[--delete] : you may want to add this option if you are running this multiple times to the same backup folder. In this case make sure that the source path does not end with /*, or this option will only have effect on the files inside the subdirectories of the source directory, but it will have no effect on the files residing directly inside the source directory.
	-aAX : transfer in archive (-a) mode (zie hoger), to preserve symbolic links, devices, permissions, ownerships, modification times, and also ACLs (-A), and extended attributes (-X)
	-x, --one-file-system : (o.a. linux eigen mounts her en der niet archiveren)
	-S, --sparse : handle sparse files efficiently
	-i, --itemize-changes : output a change-summary for all updates
	-v, --verbose : increase verbosity
	--exclude : /lost+found is filesystem-specific, /dev, /proc, /sys, /tmp, and /run are populated at boot, although the folders themselves are not created.
		- Ending the excluded paths with * ensures that the directories themselves are created if they do not already exist.
		 - OPGELET : tussen "", anders doet shell de wildcard expansion (globbing), en dan moet ge ofwel zowel * als .* opgeven voor elke map, ofwel vooraf "shopt -s dotglob" doen
		 - OPGELET : elk exclude pad beginnen met '/', om begin van de matching te verankeren op "bron/" (cfr. '^' bij regexp; anders matcht rsync het pattern om het even waar in het volledige pad van bestandsnamen)
	[--exclude={"/home/*","/util/*","/opt/*"}] om deze apart te backuppen
	- If you wish to restore the backup, use the same rsync command that was executed but with the source and destination reversed.
		- OPGELET : bij restore op andere schijf: /etc/fstab aanpassen, grub.cfg aanpassen of opnieuw genereren

=== enkel .java-bestanden van subtree kopieren naar ramdisk ===
	$ rsync -aAXxSivm --include='*/' --include='*.java' --include='*.JAVA' --exclude='*' /home/dirk/Documents/./java .
	 -m, --prune-empty-dirs : prune empty directory chains from file-list
	- include/exclude regels worden van links naar rechts toegepast, eerste match alleen
	- patterns met wildcards '*' en '?' worden gezocht per component van een volledig pad van een bestand/directory, zonder over '/' te springen
	- patterns met wildcard '**' worden gezocht over '/' in volledig pad heen
	- patterns die eindigen op '/' matchen enkel een directory
	- patterns die beginnen met '/' matchen enkel vanaf het begin van een component van een volledig pad
	- include/exclude patterns met / worden op directories toegepast
	- zonder --include='*/' (alle directories wel) zou --exclude='*' matchen op alle directories, en die samen met hun inhoud uitsluiten

=== vergelijken van verschillende backups ===

- b.v. verschillende kandidaten voor herstel vergelijken met origineel en met elkaar :
	# rsync -ncaAXxi kandidaat1/ kandidaat2/
	-n, --dry-run	: no changes
	-c, --checksum	: skip based on checksum, not mod-time & size
	-a , --archive	: archive mode; equals -rlptgoD  (zie hoger)
	-A, --acls	: preserve ACLs (implies -p)
	-X, --xattrs	: preserve extended attributes
	-x, --one-file-system : (o.a. linux eigen mounts her en der niet archiveren)
	-i		: itemize changes

=== volledig herstel van backup over nieuwe versie, met delete van bestanden in nieuwe versie die niet in backup stonden ===
	$ rsync -aAXxSi --delete backup/ huidige/
	- OPGELET : symbolic links in Samba network shares en VirtualBox shared folders zijn standaard beperkt of uitgeschakeld
		- zie sectie "symlinks volgen in Samba netwerk shares"
		- zie "_VirtualBox.txt" sectie "Symbolic links op shared folders"

== SHELL EN ENVIRONMENT VARIABELEN ==

- shell variabelen gelden enkel in de shell of in een script dat door de shell wordt uitgevoerd. Een executable ziet alleen environment variabelen. De opdracht printenv toont de waarde van een environment variabele, de interne bash-opdracht "echo $naam" toont de waarde van een shell variabele.
	- De bash-opdracht "export naam[=waarde] ..." markeert een of meer shell variabelen voor export naar het environment van elke executable die vanuit de huidige shell gestart wordt, en kent die variabelen evt. ineens een waarde toe.
		- OPGELET: het blijven shell variabelen, maar met een vlagje "exporteer deze naar environment als ge een opdracht uitvoert", met de waarde van de shell variable op dat moment. B.v.
			$ a=b
			$ printenv a
			>>><<<
			$ export a
			$ printenv a
			>>>b<<<
	- Een bash opdrachtlijn die een executable start, kan vooraan een of meer environment variabelen opsommen en een waarde geven, en die aan de opdracht doorgeven:
		$ [naam=waarde ] ... opdracht ...
		- OPGELET: die komen enkel in het environment van opdracht; in b.v. een opdrachtlijn als "n=w opdracht $n" is "n" nog een (al dan niet bestaande) shell variabele, NIET de environment variabele die de waarde w gaat krijgen binnnen "opdracht" zelf.

=== laatste exit code ===

	$ echo $?

=== process id van script ===

- De expansie van "$$" is de process id van het script in uitvoering (of shell bij sourcen van script vanuit shell) :
	$ $$
	>>> 2624 <<<
		- In a () subshell, $$ expands to the process ID of the current shell, not the subshell.

- De speciale variabele ! (gebruiken als "$!") geeft de process id van het meest recente process dat in de achtergrond werd geplaatst, door af te sluiten met een '&' (asynchronous command) dan wel door de bash opdracht "bg"

=== lijst van bash set opties ===

- met de opties van de built-in bash opdracht "set" stelt ge interne bash attributes in (!= de shell options van shopt), b.v.
	$ set -C
	-C, -o noclobber : geef fout als redirect ">" een bestaand bestand zou overschrijven
	$ set +C
	+C : zet die optie terug uit

- de expansie van "$-" is een lijst met de ingestelde (short) option letters van set

=== shellfunctie tonen ===
	$ type mijnfunctie

=== shellvariabele tonen ===
	$ echo $NAAM

=== environment variable tonen op (deel van) naam ===
	- enkel voor environment variabelen (geëxporteerde shell variabelen)
	$ printenv | grep NAAMDEEL

=== allemaal ===
 	$ set
	- an internal bash command, so it shows all the "shell variables" (unexported environment variables) as well as the exported environment variables.
	$ printenv
	- an external command, so it only knows about (and prints) exported environment variables.
	$ env
	- an external command to run a program in a modified environment (bash can do this without env); also, when no argument given, displays variables like printenv does

=== environment available to any GUI application ===

- in Gnome Shell:
	. press Alt-F2 (application finder)
	. 'xterm -e bash --noprofile --norc'
		to open a terminal with a shell that did not add any environment variables; it only has the environment variables added by the system files, that are available (by inheritance) to all programs in the system.
	$ printenv
	- in that terminal to list all your environment variables

=== environment permanent instellen ===

- zie https://help.ubuntu.com/community/EnvironmentVariables
	- environment variable settings that affect the system as a whole (rather than just a particular user) is /etc/environment. An alternative is to create a file for the purpose in the /etc/profile.d directory.
	- ~/.profile is run after ~/.pam_environment has been read
	- ~/.pam_environment
		(not a script, but list of assignment expressions, one per line. Some variables, like HOME, might not be set at the time ~/.pam_environment is parsed)
	- ~/.profile
		(script, gets executed automatically by the DisplayManager during the start-up process desktop session as well as by the login shell when one logs in from the textual console)
	- OPM: als ik het goed begrijp, roept .profile als BASH wordt uitgevoerd ook .bashrc aan, dat zelf dan weer (en dat is zeker) ~/.bash_aliases uitvoert

=== test of veranderlijke alleen witruimte is ===

- gemakkelijkst door te testen op de echo ervan met standaard IFS " \t\n" :
	$ if [ -z "$(echo $var)" ] ; then echo var is blanco; else echo -${var}- bevat tekens; fi
	- "$(echo $var)" is "" als var alleen IFS-chars " \t\n" bevat

=== variabele lijst met een scheidingsteken ===

- maken: willen lijst niet beginnen of eindigen met een scheidingsteken, want dan hebt ge bij het opsplitsen voor- of achteraan een ""
	- oplossing : ${parameter:+word} "Use Alternate Value. If parameter is null or unset, nothing is substituted, otherwise the expansion of word is substituted."
	- voorbeeld met ',' als scheidingsteken :
		$ lijst=$nieuwelement"${lijst:+,$lijst}"
		OF
		$ lijst="${lijst:+$lijst,}"$nieuwelement
	- uitleg : als lijst nog leeg is, is de expansie "" en wordt lijst == nieuwelement. Als lijst al een waarde heeft, wordt de expansie door ",lijst" resp. "lijst,"

- gebruiken : met expansie ${lijst//,/ } (NIET in "") wordt elk scheidingsteken ',' vervangen door een spatie
	- enkel als de elementen geen ' ' bevatten, anders zie sectie "IFS tijdelijke waarde"
	- voorbeeld loop : for elem in ${lijst//,/ };do echo $elem;done
	- voorbeeld array : elems=(${lijst//,/ })

=== prompts en terminal escapes ===

- zie ook https://www.davidpashley.com/articles/bash-prompts/

- bash kent 4 prompts :
	- PS0 : wordt getoond nadat commando gelezen is en voor het wordt uitgevoerd
	- PS1 : prompt wanneer de shell wacht op nieuw commando
	- PS2 : prompt wanneer de shell wacht op vervolglijn van nieuw commando
	- PS3 : prompt voor interne select-opdracht
	- PS4 : prompt tijdens execution trace van script tonen

- prompts kunnen terminal-escapecodes gebruiken (terminal Xubuntu Xenial : xterm, Bionic : $TERM = xterm-256color)
	- 1-teken-escapes : zie man bash sectie "PROMPTING"
	- \[ : Begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
	- \] : End a sequence of non-printing characters
		- markeer escapes als non-printing characters door ze tussen \[ en \] (in script \\[ en \\])  te zetten, zodat terminal line editor niet in de war geraakt voor positionering:
			>>> \[...\] tells bash to ignore the non-printing control characters when calculating the width of the prompt. Otherwise line editing commands get confused while placing the cursor. <<<
	- tekstkleur en -decoratie :
		- \e[...m : begin of wijziging, met ... een ';'-gescheiden lijst van 2-cijferige codes
		- zie ~/.dircolors voor de codes
		- \e[m : einde
	- set title patterns :
		- \e]0;titel\a : icon and window
		- \e]1;titel\a : icon
		- \e]2;titel\a : window

=== shell loops ===
	- zie ook sectie "opdracht uitvoeren op alle bestanden van een directory tree" - "basistechnieken"
	- loop een bepaald aantal keer, b.v. 5 :
		$ unset n;
		$ while ((++n <= 5)); do echo $n;done
		OF
		$ unset n;
		$ for ((;++n <= 5;)); do echo $n;done
		OF
		$ for ((n=0;++n <= 5;)); do echo $n;done
		OF
		$ for n in {1..5}; do echo $n;done
		- OPM: {n..m} wordt uitgebreid vóór variabelen, kan daardoor alleen literal waarden bevatten
	- loop over een aatal gekende waarden :
		$ for n in a b c; do echo $n;done
	- loop over elk array-element :
		$ a=(a b)
		$ for n in "${a[@]"}; do echo $n;done

== SCRIPTS SCHRIJVEN EN DEBUGGEN ==

=== elk tekstbestand kan een script bevatten ===

- is uit te voeren door de bestandsnaam als parameter van een shellopdracht te geven:
	OFWEL
	$ bash mijnscript.txt
	- voert de opdracht uit in een nieuwe bash shell, die niet interactief is en dus ~/.bashrc niet laadt
	OFWEL
	$ bash -i mijnscript.txt
	- voert de opdracht uit in een nieuwe interactieve bash shell, die dus ~/.bashrc wel laadt
	OFWEL
	$ . mijnscript.txt
	- . voert de opdracht uit in de huidige bash shell
	OFWEL
	$ source mijnscript.txt
	- source voert de opdracht uit in de huidige bash shell

- test of script met . of source wordt uitgevoerd:
	[ "$0" = "$BASH_SOURCE" ] && echo als script || echo als source

=== uitvoerbaar maken met chmod ===
- kan dan zelfstandig uitgevoerd worden zonder shellopdracht; de default shell wordt dan gebruikt. Om een of andere reden moet dan wel het pad worden opgegeven, al is het maar ./ :
	OFWEL
	$ ./test.txt
	OFWEL
	$ [pad//test.txt
	- pad is noodzakelijk, al is het "./"

=== default shell ===

- in Ubuntu is bash de default shell voor interactief gebruik, zeg maar terminal, en dash (Debian Almquits Shell) voor opstarten. De Xubuntu-opdracht "xfce4-terminal -e %f --hold" (b.v. in Thunar custom action) geeft echter ander gedrag aan de shell. "If bash is invoked with the name sh, it tries to mimic the startup behavior of historical versions of sh as closely  as possible,  while conforming to the POSIX standard as well." Laat het script daarom best beginnen met de gewenste interpreter:
	"#!/bin/bash"
	- de ! na # in #! ('shebang') maakt er geen commentaarlijn van, maar een opdracht: gebruik DIE shell

- in systemrescuecd is zsh de default shell, maar bash kan opgestart worden
	# bash

=== welke shell voert script uit ===

- Ubuntu default shell :
	- bij opstarten : dash
	- interactieve terminal : bash
	- bij uitvoeren shell "sh" : dash

- beslissen welke shell het script moet uitvoeren
	- de shebang bepaalt welke binary default gekozen wordt om een script uit te voeren
		>>> #!/bin/bash <<<
		- dat hoeft zelfs geen shell te zijn :
		>>> #!/usr/bin/perl <<<
		- het volledige pad is niet nodig, wel aan te raden (b.v. hacker zou elders op pad een executable "perl" of "bash" kunnen zetten)
	- MAAR de shebang wordt enkel gekozen als het script executable is, en direct wordt uitgevoerd:
		$ ./test
	- shebang NIET gekozen, als impliciet of expliciet een shell wordt gebruikt om het script uit te voeren:
		- source invoeren in current shell :
			$ . ./test
		- source uitvoeren met default shell :
			$ sh ./test
		- source uitvoeren met bepaalde shell :
			$ dash ./test
			OF
			$ bash ./test

- testen welke shell effectief uitvoert :
	- simpele test of bash de shell is :
		>>> [ -n "$BASH_VERSION" ] || echo "Geen bash wegens -n" <<<
		- kan gefopt worden door gewoon zelf zo'n variabele een waarde te geven
		- niet testen met [ -v BASH_VERSION ], want "-v" zelf is al bash-specifiek
		- array variabele BASH_VERSION_INFO splitst die versie op, zie "man bash"
		- dash heeft niet zo'n variabelen om op te testen
	- betrouwbare test :
		>>> [ $(readlink /proc/$$/exe) = "/bin/bash" ] || echo "Geen bash volgens proc/\$\$/exe" <<<
		- "$$" is process-ID van uitvoerend process
		- /proc/process-ID/exe is symbolic link naar binary van process-ID
		- waarschijnlijk is /proc/self hetzelfde, maar natuurlijk is [ "$(realpath /proc/self/exe)" = "/usr/bin/realpath" ]

- tests uitgevoerd om dit te weten
	>>> script "test"
		#!/bin/bash
		echo bash versie $BASH_VERSION
		echo arg0 is $0
		echo -n "readlink zegt "
		readlink /proc/$$/exe
		[ -n "$BASH_VERSION" ] || echo "Geen bash wegens -n"
		[ -v BASH_VERSION ] || echo "Geen bash wegens -v"
	<<<
	- in bash, default interactieve shell van XUbuntu
		$ ./test
			bash versie 4.3.48(1)-release
			arg0 is ./test
			readlink zegt /bin/bash
		$ . ./test
			bash versie 4.3.48(1)-release
			arg0 is bash
			readlink zegt /bin/bash
		$ sh ./test
			bash versie
			arg0 is ./test
			readlink zegt /bin/dash
			Geen bash wegens -n
			./test: 7: [: -v: unexpected operator
			Geen bash wegens -v
		$ bash ./test
			bash versie 4.3.48(1)-release
			arg0 is ./test
			readlink zegt /bin/bash
		$ dash ./test
			bash versie
			arg0 is ./test
			readlink zegt /bin/dash
			Geen bash wegens -n
			./test: 7: [: -v: unexpected operator
			Geen bash wegens -v
	- in dash shell
		$ dash
		$ ./test
			bash versie 4.3.48(1)-release
			arg0 is ./test
			readlink zegt /bin/bash
		$ . ./test
			bash versie
			arg0 is sh
			readlink zegt /bin/dash
			Geen bash wegens -n
			sh: 7: [: -v: unexpected operator
			Geen bash wegens -v
		$ sh ./test
			bash versie
			arg0 is ./test
			readlink zegt /bin/dash
			Geen bash wegens -n
			./test: 7: [: -v: unexpected operator
			Geen bash wegens -v
		$ dash ./test
			bash versie
			arg0 is ./test
			readlink zegt /bin/dash
			Geen bash wegens -n
			./test: 7: [: -v: unexpected operator
			Geen bash wegens -v
		$ bash ./test
			bash versie 4.3.48(1)-release
			arg0 is ./test
			readlink zegt /bin/bash

=== script maar 1 keer uitvoeren ===

- de flock-opdracht laat de uitvoering van een simpel commando ervan afhangen of een lock op een bestand kan gekregen worden.
	- met argument -c "samengesteld commando" kan een moeilijker commando uitgevoerd worden (vgl. "bash -c 'commandos'"); helaas is het moeilijk (kan het uberhaupt) om argumenten tussen "" door te geven aan dat commando

- complexe scripts kunnen met 1 extra lijn vooraan ge-flocked worden als volgt :
	- niet uitvoeren als ander proces dit script al uitvoert :
		- vooraan script deze lijn toevoegen
		>>>
		[ "${mijnFlockEnvVar}" != "$0" ] && exec env mijnFlockEnvVar="$0" flock -n "$0" "$0" "$@" || :
		<<<
		- zie "man flock" laatste vb.
		- mijnFlockEnvVar != "$0" en ="$0" : mag ook andere waarde zijn
		- exec : Execute following command, replacing this shell with the specified program; If the command cannot be executed, a non-interactive shell exits.
		- env - run a program in a modified environment
		- flock -n, --nb, --nonblock : Fail rather than wait if the lock cannot be immediately acquired.
		- flock "$0" : (1ste $0) zet file lock op "$0", het huidige commando (moet dus executable script zijn, niet uitvoeren met "bash scriptnaam")
		- flock "$0" "$@" : (2de $0) roept het script terug aan, met dezelfde argumenten in ""
		- ":" : bash built-in dummy command, return value 0
			- OPM: ik weet niet waarom (en of) dat er bij moet
	- wachten als ander proces dit script al uitvoert :
		- vooraan script deze lijn toevoegen
		>>>
		[ "${mijnFlockEnvVar}" != "$0" ] && exec env mijnFlockEnvVar="$0" flock "$0" "$0" "$@" || :
		<<<
		- enige verschil met vorige script : flock zonder "-n"
		- evt. flock [-w nn] : als het script in dit proces na nn seconden nog niet aan de beurt komt, afbreken
	- verschillende script zo synchroniseren : een gemeenschappelijk lock-bestand gebruiken i.p.v. elk zichzelf ("$0"), b.v.
		- vooraan script deze lijnen toevoegen
		>>>
		onsLockBestand=/var/lock/onslockbestand
		[ "${mijnFlockEnvVar}" != "$onsLockBestand" ] && exec env mijnFlockEnvVar="$onsLockBestand" flock "$onsLockBestand" "$0" "$@" || :
		<<<
		- /var/lock is in Ubuntu een link naar een tmpfs op /run/lock

=== return of exit ===

- "return" werkt alleen vanuit functies en vanuit een gesourced script, anders geeft ze een fout; met name de interactieve shell, scripts die als uitvoerbaar bestand worden uitgevoerd, of scripts die worden uitgevoerd met "bash script", kennen de opdracht "return" alleen in functie; buiten functies moet daar "exit" gebruikt worden om een script of de interactieve shell (en zijn terminal) te beëindigen :
	$ return
	>>> bash: return: can only `return' from a function or sourced script <<<

- exit op de opdrachtlijn van een interactieve shell, of in een script dat met de bash-opdracht "source" of "." wordt uitgevoerd, beëindigt die shell (en zijn terminal). Daar is de opdracht "return" beter voor.

- goed voor allebei (recente bash) : "fc=-1; return "$fc" 2>/dev/null || exit "$fc" : in een uitvoerbaar script faalt de return, en wordt de exit uitgevoerd.

=== test, [] en [[]] ===


- test is een bash built-in commando, en '[' is er een synoniem van (moet zoals elk commando gevolgd worden door whitespace om herkend te worden). Als '[' wordt gebruikt, wordt de afsluitende ']' herkend als afsluitend, en genegeerd
	-a en -o: als de conditional expression primaries -a (true if file exists) of -o (true if shell option is set) het middelste van 3 argumenten zijn, krijgt die voor test en '[' de betekenis AND resp. OR. Dit geldt NIET voor '[[ ... ]]' : als ge een opdracht test of '[' omwerkt naar [[ ... ]], moet ge goed opletten dat ge evt. -a en -o primaries gepast vervangt door && en ||
	- To test variables you should quote the "variablename" as they may undergo word splitting or globbing: [ "$DEMO" = 5 ]

- '[[ ... ]]' is een compound command, met meer mogelijkheden dan test of '[', o.a. pattern matching
	- de ... is een expression list van conditional expressions
	- meerdere expressions worden tussen [[...]], zoals in elke bash expression list, logisch aaneengeschakeld met && (AND) en || (OR)
	- als ge een opdracht test of '[' omwerkt naar [[ ... ]], moet ge goed opletten dat ge evt. -a en -o primaries gepast vervangt door && en ||
	- variabelen worden binnen [[...]] geëxpandeerd zonder word splitting of globbing, dus [[ $DEMO = iets ]] is veilig

=== functies, argumenten, return value en spaties daarin ===

- argumenten voor een functie zijn strings, zoals argumenten voor een shell script vanop de opdrachtlijn
	- in de functie : "$1", "$2", ... of "$@"
	- $0 is naam van script of shell
	- om spaties te bewaren, argumenten zowel bij aanroep van als bij gebruik in functie tss. ""

- de return value van een functie (of sourced script) is de return code van de laatste opdracht, een getal van 0 tot 255 (cfr. de exit code van een binary)
	- als tijdens het uitvoeren van de functie (of sourced script) een return-opdracht wordt tegengekomen, is dat de laatste opdracht; het (numerieke) argument van de return-opdracht (default 0) is ook haar return code, en dus die van de functie (of sourced script)
	- bereikbaar als de expansie van "$?"
	- bij tests daarop is 0 true, al de rest false.

- een functie kan andere informatie doorgeven aan de aanroeper via
	- variabelen : als die niet als 'local' worden gedeclareerd in de functie, zijn ze toegankelijk voor de aanroeper
		- local maakt evt. externe variabelen met dezelfde naam onzichtbaar, ook voor unset. Overigens verwijdert unset alleen de waarde van de locale naam, maar hij blijft local, en bekend bij declare:
			$ a=extern;f() { echo BEGIN $a;declare -p a b c;local a b;echo LOCAL $a;declare -p a b c;unset a;echo UNSET $a;declare -p a b c; };f;echo RETURN $a;declare -p a b c;
			>>>
				BEGIN extern
				declare -- a="extern"
				bash: declare: b: not found
				bash: declare: c: not found
				LOCAL
				declare -- a
				declare -- b
				bash: declare: c: not found
				UNSET
				declare -- a
				declare -- b
				bash: declare: c: not found
				RETURN extern
				declare -- a="extern"
				bash: declare: b: not found
				bash: declare: c: not found
			<<<
	- stdout, b.v. met de opdracht "echo" en bash command substition, b.v.
		$ resultaat=$(functie argument...)
			- de command subsitution behoudt evt. spaties zonder dat er "" rondstaan, zodat elk argument tussen "" kan
		$ [ -n "$(functie argument...)" ]
			- de command substition MOET tss. "", of ze wordt aan de spaties opgesplitst in woorden; als we argumenten met spaties willen gebruiken, moet het resultaat van de command substitution eerst in een variabele worden bewaard
		- bij gebruik van het resultaat moeten er wel "" rond om spaties te behouden
	- voorbeeld :
			$ keepspaces() { echo "$1"; }
			$ spaceskept=$(keepspaces "1 2  3   spaces")
			$ echo "$spaceskept"
			>>> 1 2  3   spaces <<<

- $@ is de array van argumenten van aangeroepen script of functie

- een array is niet toegelaten als functie-argument; expansie ("$@") door aangeroepene geeft wel array :
	>>> ./test.sh
		#!/bin/bash
		function copyFiles() {
		   local arr=("$@")
		   echo "function ${#arr[@]} elements : ${arr[@]}"
		   for i in "${arr[@]}"
		   do
			   echo ">$i<"
		   done
		}
		echo "script   ${#@} elements : $@"
		copyFiles "$@"
	<<<
	$ ./test.sh  A "B C D" "  Double  Spaced  "
	>>>
		script   3 elements : A B C D   Double  Spaced
		function 3 elements : A B C D   Double  Spaced
		>A<
		>B C D<
		>  Double  Spaced  <
	<<<

=== redirect ===

- zie "http://wiki.bash-hackers.org/howto/redirection_tutorial"

- de redirect-operators zijn '>' en '<', en worden vooraf gegaan door een file descriptor nummer (fd), en gevolgd door een fd of een bestandsnaam
	- redirects mogen ook vooraf gegaan worden door een geldige variable-naam tss {} (en ZONDER $ voor); dan wijst de shell zelf een fd 10 of groter toe, en zet dat nr. in de variable voor later gebruik.
		- bij sluiten van zo'n filedescriptor wordt de fd-waarde niet toegewezen aan de variabele, maar eruit gelezen **tss. {} EN ZONDER $ voor**
		- bv. als ge 2x een soort stdin nodig hebt, 1ste voor while read, een 2de voor de opdracht in die loop, kunt ge read laten lezen uit een andere file descriptor dan stdin (optie -u):
			$ exec {fd}<invoerbestand; while read -ru ${fd} lijn;do echo "$lijn" | grep ...; done;exec {fd}<&-
			- exec start een nieuwe shell met opgegeven redirects en environment, of geeft, zonder shell-argument, de huidige shell de opgegeven redirects en environment
			- 1ste exec geeft de huidige shell, en alle opdrachten die erin uitvoeren, het invoerbestand te lezen op nr. $fd

	- /dev/stdin heeft fd 0, en wordt, behoudens pipes en redirects, van terminal gelezen
		- 0 is de impliciete fd voor '<' zonder fd voor
	- /dev/stdout heeft fd 1, en wordt, behoudens pipes en redirects, naar terminal geschreven
		- 1 is de impliciete fd voor '>' zonder fd voor
	- /dev/stderr heeft fd 2, en wordt, behoudens pipes en redirects, naar terminal geschreven (maar langs een andere poort dan /dev/stdout)

- de & in een redirection operator betekent "duplicate", b.v. "1>&2" neemt de bestemming van 2 (stderr) over als die van 1 (stdout), zodat alles wat de opdracht naar stdout schrijft, eigenlijk op stderr terecht komt

- volgorde is van belang: "2>&1" redirect van stderr naar stdout, kopiëert de bestemming van stdout als de nieuwe bestemming van stderr; daarna kan een andere redirect b.v. een nieuwe bestemming geven aan stdout, maar dat verandert niets meer aan die van stderr:
	$ opdracht 2>&1 > /tmp/uit
	- stderr schrijft naar de oorspronkelijke stdout, maar de nieuwe stdout-bestemming is /tmp/uit

- als ge de volgorde omkeert, geeft ge eerst stdout een nieuwe bestemming, en die neemt ge over als bestemming van stderr:
	$ opdracht > /tmp/uit 2>&1
	- de nieuwe stdout-bestemming is /tmp/uit, en die van stderr ook

- een pipe '|' is geen redirect, maar koppelt de /dev/stdout van wat er links van staat aan de /dev/stdin van wat er rechts van staat (en ontkoppelt dus beiden van de terminal)
	- de pipe '|&' koppelt ook /dev/stderr van links aan /dev/stdin van rechts
		- '|&' is hetzelfde als "2>&1 |"

==== echo naar stderr ">&2"  "1>&2" ====

- echo stuurt standaard naar stduit (fd 1). Die omleiden naar stderr (fd 2) gebeurt met de redirect operator 1>&2 ("stuur 1 mee naar 2"). Maar alle redirects '>' zonder fd voor, worden verondersteld vanuit stduit (fd 1) te gebeuren:
	>&2 is hetzelfde als 1>&2

- bij een enkelvoudige opdracht mogen redirects overal staan, b.v. in het begin maakt het heel leesbaar
	$ 1>&2 echo "error"
	$ echo "error" 1>&2
	- hetzelfde geldt voor elke opdracht afzonderlijk van een samengestelde opdracht, zie volgende vb.

- bij een samengestelde opdracht (pipeline, list) mag redirect enkel achteraan; b.v.
	$ 1>&2 for n in {1..2};do echo "nummer $n"; done
		>>> bash: syntax error near unexpected token `do' <<<
	$ for n in {1..2};do echo "nummer $n"; ...; done 1>&2  ## alle output op stderr
		>>>
		nummer 1
		nummer 2
		<<<
	$ for n in {1..2};do 1>&2 echo "nummer $n"; ... ; done  ## enkel echo's op stderr
		>>>
		nummer 1
		nummer 2
		<<<

==== analyse van redirects ====

- stdin, stdout en stder zijn respectief file descriptors 0, 1 en 2 van een door bash gesimuleerde terminal, /dev/pts/#. Met "stat" of ls -l kunt ge de verwijzing naar die terminal zien (maar niet welke 'poort') :
	$ stat -c %N /proc/self/fd/[012]
	>>>
		'/proc/self/fd/0' -> '/dev/pts/6'
		'/proc/self/fd/1' -> '/dev/pts/6'
		'/proc/self/fd/2' -> '/dev/pts/6'
	<<<
	OF
	$ ls -l /proc/self/fd/[0-2]
	>>>
	lrwx------ 1 dirk dirk 64 nov 17 11:29 /proc/self/fd/0 -> /dev/pts/6
	lrwx------ 1 dirk dirk 64 nov 17 11:29 /proc/self/fd/1 -> /dev/pts/6
	lrwx------ 1 dirk dirk 64 nov 17 11:29 /proc/self/fd/2 -> /dev/pts/6
	<<<
	- elke gelijktijdige bash shell heeft een ander pts-nummer
- de redirect "2>&1" kopieert de file descriptor van 2 naar 1, zodat die beide naar dezelfde 'poort' van die terminal schrijven
	- enkel poort verandert, is niet zichtbaar in stat
		$ 2>&1 stat -c %N /proc/self/fd/[012]
			>>>
			'/proc/self/fd/0' -> '/dev/pts/6'
			'/proc/self/fd/1' -> '/dev/pts/6'
			'/proc/self/fd/2' -> '/dev/pts/6'
			<<<
- de redirect "2>bestand" verandert de verwijzing van fd 2: die gaat nu naar bestand
	$ 2>/tmp/mijnstderr stat -c %N /proc/self/fd/[012]
		>>>
		'/proc/self/fd/0' -> '/dev/pts/3'
		'/proc/self/fd/1' -> '/dev/pts/3'
		'/proc/self/fd/2' -> '/tmp/mijnstderr'
		<<<
- de redirect "1>bestand" of ">bestand" doet hetzelfde met fd 1: die gaat nu naar bestand
	$ 1>/tmp/mijnstdout stat -c %N /proc/self/fd/[012]
		>>>
		'/proc/self/fd/0' -> '/dev/pts/8'
		'/proc/self/fd/1' -> '/tmp/mijnstdout'
		'/proc/self/fd/2' -> '/dev/pts/8'
		<<<
- de redirect "0<bestand" of "<bestand" doet hetzelfde met fd 0, maar voor invoer: die komt nu van bestand
	$ 0</tmp/mijnstdin stat -c %N /proc/self/fd/[012]
		>>>
		'/proc/self/fd/0' -> '/tmp/mijnstdin'
		'/proc/self/fd/1' -> '/dev/pts/7'
		'/proc/self/fd/2' -> '/dev/pts/7'
		<<<
- een pipe, naar b.v. grep, verandert de verwijzing van fd 1 :
	$ stat -c %N /proc/self/fd/[012] | grep -
		>>>
		'/proc/self/fd/0' -> '/dev/pts/6'
		'/proc/self/fd/1' -> 'pipe:[258096]'
		'/proc/self/fd/2' -> '/dev/pts/6'
		<<<
- een pipe, samen met de redirect "2>&1" doet dit voor fd 2 en fd 1
	$ 2>&1 stat -c %N /proc/self/fd/[012] | grep -
		>>>
		'/proc/self/fd/0' -> '/dev/pts/9'
		'/proc/self/fd/1' -> 'pipe:[258098]'
		'/proc/self/fd/2' -> 'pipe:[258098]'
		<<<
- redirects zijn volgorde-gevoelig :
	- als ge VOOR "2>&1" ook een redirect van fd 1 doet, gaan ze beide naar de nieuwe bestemming van fd1 :
		- cfr. het voorbeeld "een pipe, samen met de redirect "2>&1""
		$  1>/tmp/mijnstdout 2>&1 stat -c %N /proc/self/fd/[012]
			>>>
			<<<
		$ cat /tmp/mijnstdout
			>>>
			'/proc/self/fd/0' -> '/dev/pts/7'
			'/proc/self/fd/1' -> '/tmp/mijnstdout'
			'/proc/self/fd/2' -> '/tmp/mijnstdout'
			<<<
	- als ge NA "2>&1" ook een redirect van fd 1 doet, blijft 2 uitvoeren naar de oorspronkelijke bestemming van fd1, terwijl fd2 naar de nieuwe gaat :
		$ 2>&1 1>/tmp/mijnstdout stat -c %N /proc/self/fd/[012]
			>>>
			<<<
		$ cat /tmp/mijnstdout
			>>>
			'/proc/self/fd/0' -> '/dev/pts/7'
			'/proc/self/fd/1' -> '/tmp/mijnstdout'
			'/proc/self/fd/2' -> '/dev/pts/7'
			<<<

==== exec met redirect ====

- exec also allow us to manipulate the file descriptors. If you don't specify a program, the redirection after exec modifies the file descriptors of the current shell:
	$ exec 2>/tmp/exec-stderr
	[ $ stat -c %N /proc/self/fd/[012] ]
		- opdrachtlijn is onzichtbaar, die komt blijkbaar via stderr op het scherm, en nu dus niet; stdin en stdout zijn onaangeroerd :
		>>>
		'/proc/self/fd/0' -> '/dev/pts/8'
		'/proc/self/fd/1' -> '/dev/pts/8'
		'/proc/self/fd/2' -> '/tmp/exec-stderr'
		<<<
	[ $ exit ]
	$ cat /tmp/exec-stderr
		>>>
		$ stat -c %N /proc/self/fd/[012]
		$ exit
		exit
		<<<


All the the errors sent to stderr by the commands after the exec 2>file will go to the file, just as if you had the command in a script and ran myscript 2>file.

exec can be used, if, for instance, you want to log the errors the commands in your script produce, just add exec 2>myscript.errors at the beginning of your script.

=== redirect password naar sudo ====

- sudo bestuurt zelf terminal voor invoer paswoord; met optie -S wordt paswoord echter vanstdin gelezen

- whiptail (alternatief "dialog") toont mooie textmode invoerpopups voor interactie vanuit scripts
	- om nog uit te zoeken reden voert onderstaande opdracht zonder "sudo -k" vooraf, al direct de "sudo -S ..." uit als sudo-credentials nog in cache zitten
	$ sudo -k;echo "$(whiptail --title "SUDO WACHTWOORD" --passwordbox "sudo wachtwoord: " 10 50  3>&1 1>&2 2>&3-)" | sudo -S ls -al /root
		- sudo -k : sudo credentials vergeten
		- 3>&1 1>&2 2>&3- : whiptail zet resultaat in stderr, deze truk wisselt stderr met stdout :
			- 3>&1 : opent een fd (file descriptor 3), als kopie van 1 (stdout)
			- 1>&2 : kopieert de fd van 2 (sterr) naar 1 (stdout)
			- 2>&3- : kopieert de fd van 3 (originele stdout) naar 2 (stderr), en sluit 3
		- sudo -S : prompt op stderr zoals gebruikelijk, maar input van stdin i.p.v. via terminal

=== trace van script tonen ===

- toon elke opdracht van een script op de terminal tijdens uitvoer (cfr. displays in een C-programma):
	$ bash -x mijnscript
	- elke opdracht van een pipeline wordt getoond

- toon elke opdracht van een sectie van script op terminal tijdens uitvoer (cfr. displays in een C-programma):
	- in het script volgende opdrachten opnemen rond die sectie:
		set -x
		#sectie met display van opdrachten
		set +x
	- de afsluitende "set +x" wordt ook getoond
	- set -f, set -o noglob : Disable file name generation using metacharacters (globbing).
	- set -v, set -o verbose : Prints shell input lines as they are read.
	- set -x, set -o xtrace : Print command traces before executing command.

=== script debuggen met de bash debugger ===
	$ bashdb mijnscript
	- "?" voor lijst van opdrachten
	- "help opdracht" voor hulp
	- "q" om af te sluiten

=== eigen map bepalen in het script ===
- zie https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within :
	zelfdir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

=== script beperken tot root ===

- een script moet niet uitvoerbaar zijn (chmod +x) om het te kunnen uitvoeren: in "bash scriptnaam" moet alleen bash uitvoerbaar zijn, en is scriptnaam gewoon een invoerbestand. Idem voor "source scriptnaam" of ". scriptnaam". Daarom moet ge soms in het script zelf testen of een root-gebruiker het uitvoert.

- bash (andere shells mogelijk niet) zet de variabelen UID en EUID (effective user id); in Ubuntu zijn die readonly, dus veilig, in andere OS mogelijk niet

- OPL. 1 : controle op uitvoer door roor :
	>>>
		if [ "$(id -u)" -ne 0 ]
		then
			echo 'This script must be run by root' 1>&2
			exit 1
		fi
	<<<<
	- OPM : dit is niet zomaar te testen met sudo op de commandolijn, omdat bash de $()-expansie doet voor sudo wordt aangeroepen :
		$ id -u
		 >>> 1000
		$ sudo id -u
		 >>> 0
		$ echo $(id -u)
		 >>> 1000
		$ sudo echo $(id -u)
		 >>> 1000
		$ bash -c 'echo $(id -u)'
		 >>> 1000
		$ sudo bash -c 'echo $(id -u)'
		 >>> 0

- OPL. 2 : script herstart zichzelf als root
	>>>
		# display user, mag weg na test
		echo "$(whoami)"
		# als niet root, herstart als root met sudo
		[ "$UID" -eq 0 ] || exec sudo "$0" "$@"
	<<<
	- zie ook sectie "redirect password naar sudo"

=== loop over lijnen van tekstbestand ===
	$ while read woord1 woord2 ... ; do echo $woord1 $woord2 ... ; done < tekst.txt
	- OPGELET: er is maar 1 stdin, opdrachten na de 'do' die daaruit lezen, stelen die lijnen van de read-opdracht weg
	- woord1 ... : variabelen waarin de woorden van een lijn uit tekst.txt gelezen worden; default $REPLY. The characters in IFS are used to split the line into words using the same rules the shell uses for expansion
	- als lijn in tekst.txt meer woorden bevat dan opgegeven voor read, dan komt rest in laatste woord#
	- andere read opties :
		-a arrayname : woorden in array i.p.v. benoemde variabelen
		-d delimchar : t.b.v. opsplitsen tekst.txt in lijnen, default newline
		-r : lees backslash niet als escape (i.e. \LF is geen vervolglijn)
		-e : (enkel interactief) gebruik readline
		-i default : (enkel met readline) zet "default" al in input buffer, en toont die
		-p prompt : (enkel met readline) toont prompt
		-n ## : leest ## chars, of hele lijn als die korter is
		-N ## : leest ## chars
	- voorbeeld :
	>>> flc2mp3.cfg
		2 "doel1.mp3" "1ste bestand.flac" "2de bestand.flac" "3de bestand.flac"
		3 "doel2.mp3" "4de bestand.flac" "5de bestand.flac"
	<<<
	$ while read kwal mp3 flacs ; do echo Q=$kwal ; echo MP3=$mp3 ; echo FLC=$flacs ; done < flc2mp3.cfg
	>>>
		Q=2
		MP3="doel1.mp3"
		FLC="1ste bestand.flac" "2de bestand.flac" "3de bestand.flac"
		Q=3
		MP3="doel2.mp3"
		FLC="4de bestand.flac" "5de bestand.flac"
	<<<

=== menu maken met select ===
	$ PS3="prompt voor select-menukeuze"
	- default leeg
	- PS3 behandelt geen escapes, dus zonder truukje geen kleuren, piepen, bold, ...
		- truukje :
			$ vet=$(tput smso) vetuit=$(tput rmso)
			$ PS3="${vet}Kies${vetuit} het nummer van ... : "
	$ select var in EINDE [value1]... ; do if [ "$var" = "EINDE" ] ; then exit; if [ -z "$var" ] ; then echo "keuze is niet geldig" else echo $var; break; fi; done
	- toont de menukeuzes in kolommen, met een volgnr. i ervoor
	- aantal kolommen is afh. van de variable COLUMNS, die gezet wordt in een terminal, maar niet (altijd?) bij het uitvoeren van een shellscript. Zelf zetten in het script als volgt:
		$ [ -v COLUMNS ] || COLUMNS=$(tput cols)
	- bij enter zonder keuze wordt het menu ververst, zonder in de do-loop te komen
	- bij enter met iets ingetikt, wordt de keuze verwerkt in de do-loop; moeten zelf "break"-opdracht uitvoeren om de loop te beeindigen, maar select-lijst wordt niet opnieuw geprint
		- bij enter van geldig keuzenr heeft $var de overeenkomede waarde uit de select-lijst, en $REPLY het ingetikte nummer
		- bij enter van ongeldige waarde heeft var de waarde null, "$var" = "", en $REPLY het ingetikte
	- EINDE is een zelfgekozen naam voor een laatste menukeuze die het afbreken wat gebruikvriendelijker maakt (anders Ctrl-C)
	- select is een 'shell builtin command', en komt op een andere plaats dan andere commando's in de parsing van een opdrachtlijn. Daardoor kunnen de menukeuzes [value1]... enkel blanco's bevatten in de volgende gevallen :
		- tussen ""
		- door globbing
	- VOORBEELDEN:
		$ select optie in EINDE "eerste optie" "tweede optie" ...
		- literal opties tussen "" kunnen spaties bevatten
		OF
		$ opties=("optie 1" "optie 2")
		$ select optie in EINDE "${opties[@]}" ...
		OF
		$ select bestand in EINDE ./*.jpg ...
		- opties t.g.v. shell globbing kunnen spaties bevatten
		- GEEN SPATIES bij enig ander voorbeeld :
		- voor een ononderbroken array opties ([0], [1], ...) is ook $REPLY nuttig, het gekozen volgnr. van de menukeuze
		$ select optie in EINDE $(ls globbingpattern) ...
		- GEEN SPATIES mogelijk:
			- niet met $(ls -Q globbingpattern)
				-Q, --quote-name
			- niet met $(ls -Q --quoting-style=shell globbingpattern)
				- met geen enkele van word=: literal, locale, shell, shell-always, shell-escape, shell-escape-always, c, escape
			- niet met $(find ...) i.p.v. $(ls ...)

=== menus maken met het dialog-commando ===
	- volgorde van argumenten heeft zijn belang, in groepen: eerst algemene opties, dan boxopties (dan widgetopties?)
	- let op de pipe, lijkt nodig om het menu zichtbaar te maken : " 2>&1 >/dev/tty"
	- VOORBEELD kiezen uit inhoud van een directory
	$ KEUZE=$(dialog --clear --fselect "/pad/[defaultkeuze]" $HEIGHT $WIDTH 2>&1 >/dev/tty)
	- --clear : maakt het scherm leeg na keuze
	- --fselect : keuze uit bestanden in een directory
	- --dselect : keuze uit directories in een directory
	- [defaultkeuze] (OPGELET: zonder eind-'/') wordt voorgeselecteerd in het menu, kan globbing wildcards bevatten, maar die bepalen NIET welke bestanden/directories getoond worden en gekozen kunnen worden
	- KEUZE bevat wat in het invoerveld onderaan staat. Een bestands/directorynaam uit de lijst met de spatiebalk naar dat invoerveld kopiëren
	- navigeren naar andere mappen (ook  '.' en '..') kan door ze te selectern naar het invoerveld en er een / achter te typen
	- ook leuk: --backtitle "venstertitel" --title "menutitel"
	- VOORBEELD kiezen uit een lijst (array of literal) van even lengte: "label1" "omschrijving1" ...
	$ OPTIES=("label 1" "Uitleg 1" "Label 2" "Uitleg 2")
	$ KEUZE=$(dialog --clear --menu "menuprompt" $HEIGHT $WIDTH $LIJSTHOOGTE "${OPTIES[@]}" 2>&1 >/dev/tty)
	- KEUZE bevat het gekozen label

=== menu-maatwerk met 'ls' voor lijst van bestanden of directories, en 'read' om 1 te kiezen met autocompletion ===
	- vanwege autocompletion enkel werkbaar in de working directory waar die bestanden/directories staan
	- zelf een loop scripten, met daarin
		- voor bestanden:
			$ ls -C globbingpattern
			- -C : list entries by columns
		- voor directories:
			$ ls -Cd globbingpattern\
			- -d, --directory : list directories themselves, not their contents
		$ read -ep "mijn prompt: " var
		- -e : doe autocompletion ("use Readline to obtain the line in an interactive shell")
		- -p : een prompt
		- $var bevat de ingevoerde waarde voor het menu-script

=== zenity dialogen voor interactieve scripts ===

- popup om meerdere bestanden of mappen te selecteren
	- basisopdracht: zenity --file-selection --multiple --filename="$pad"/ [--separator=c]
		--filename : initiëel geselecteerd bestand of directory, zenity opent dan op de parent directory. Maar als pad eindigt op /, is pad/ de parent directory en opent zenity dus op die directory, met niets geselecteerd.
		--separator=c : separator character (default '|') tss. de geselecteerde bestanden
		- zenity zet de geselecteerde bestanden gewoon op stdout, met de separator ertussen. Om ze in een array te krijgen, splitsen op de separator. B.v. met de default '|' :
			$ IFS="|" sel=($(zenity --file-selection --multiple))
			OF als ge zeker zijt dat er geen newlines in de bestandsnamen staat :
			$ IFS="\n" sel=($(zenity --file-selection --multiple --separator="\n"))
				- NIET '\n', want tss. '' worden escapes niet omgezet; evt. wel $'\n'
			- OPM: bash command substitution $() deletes any trailing newline
	- om alle bestandsnamen aan te kunnen, gebruiken andere programmas de (char)0x00 als separator; helaas aanvaardt zenity (v.3.28.1) wel --separator=$'\0', maar die geraakt niet tot in output (bug wschlk. veroorzaakt door ASCIIZ strings zoals in C). Als ge zeker zijt dat er b.v. geen control char 0x01 in de bestandsnamen staat: dit werk wel :
			$ IFS=$'\1' sel=($(zenity --file-selection --multiple --separator=$'\1'))
	- bijna oplossing: zenity blijkt altijd volledige paden vanaf root "/" te geven. Dus als we zenity '/' laten gebruiken als separator, staat er "//" aan het begin van 2de en volgende bestandsnamen. '/' is niet geldig in bestandsnamen, en in paden wordt '//' wel aanvaard in linux, maar nooit als resultaat gegeven (o.a. ook doordat namen van directories (en andere bestanden) niet "" kunnen zijn. Dus dan kunt ge met sed de '//' vervangen door $'\0/' om de bestandsnamen te splitsen op '0x00'.
		- OPM: sed aanvaardt de (char)0x00 niet die bash er zet als ge b.v. $'s|//|\0/|g' probeert, maar sed heeft wel zijn eigen hex escape. Maar bash reclameert :
			NIET $ IFS==$'\0' sel=($(zenity --file-selection --multiple --separator=/ --filename="$PWD"/ | sed -E 's|//|\x00/|g'))
			>>> bash: warning: command substitution: ignored null byte in input <<<
	- OPLOSSING: niet command substitution, maar process subsitution gebruiken: gaat via virtueel bestand, daar mag 0x00 in. Dat bestand redirecten naar "readarray -d $'\0'" (delimiter (char)0x00). OPGELET: redirect, niet pipen, want dat is readarray a.k.a. mapfile in een subprocess en gaat de resulterende array direct verloren. Let wel: process substitution verwijdert trailing newline van zenity NIET, en vanwege delimiter 0 zet readarray die newline gewoon achteraan in het laatste array element. We  moeten de trailing newline dus zelf verwijderen. Door sed de optie '-z', '--null-data' of '--zero-terminated' te geven, splits sed de input niet op newlines maar op 0-chars (die er nog niet zijn, dus is alles 1 lijn), dus kunnen we de newline achteraan zoeken en weglaten :
		$ readarray -d $'\0' -t sel < <(zenity --file-selection --multiple --separator=/ --filename="$PWD"/ |sed -zE 's|\n$||;s|//|\x00/|g')
		- geselecteerde bestandsnamen staan nu in array sel.

=== here-document ===

- gebruikt here-document (met naam HERE-DOCUMENT) om sommige bestanden te maken :
	- begin :
		<<naam
		OF
		<<-naam : alle voorlooptabs worden verwijderd (handig voor indendatie)
		OF
		<<'naam' : omgevingsveranderlijken in tekst here-document worden niet vervangen (anders dus WEL)
	- gevolgd door lijnen met tekstinhoud van het document
	- afgesloten door lijn met de naam herhaald (zonder blanks of tabs voor noch na):
		naam
	- als naam, noch om het even welke letters ervan, niet tussen '' of "" staat, dan gebeuren in het hele here-document parameter expansion, command substitution, en arithmetic expansion, the character sequence \<newline> is ignored, and \ must be used to quote the characters \, $, and `. Als naam tussen quotes staat, niet; naam zelf ondergaat dan wel quote removal

- voorbeeld van here-document met de naam "HERE-DOCUMENT", met pipe naar bestand :
	cat <<-einde_heredoc > doelbestand
		een lijn
		en nog een
		...
		laatste lijn is die waarna de naam "HERE-DOCUMENT" herhaald wordt
	einde_heredoc

==== block comment in shell script ====

- linux shells kennen meestal alleen lijn-commentaar, met '#' als commentaarteken; formattering van lijncommentaar wordt door b.v. geany niet ondersteund, enkel fold/unfold van opeenvolgende lijnen die met # beginnen. Met een here-document is hieraan te verhelpen, b.v. :
	: <<'BLOCKCOM'
		dit is vrije tekst
BLOCKCOM
	- man bash
	>>> : [arguments] : No effect; the command does nothing beyond expanding arguments and performing any specified redirections. A zero exit code is returned.	<<<
	- 'BLOCKCOM', om geen $-expansies e.d. te doen in de commentaar; b.v. voorbeelden van command substitution zouden neveneffecten hebben.
	- de ":" en de tekst mogen vrij inspringen, de afsluitende marker (b.v. BLOCKCOM) moet wel op kolom 0 staan (tenzij de redirectoperator "<<-" is i.p.v. "<<" is)
	- andere toegelaten here-doc namen zijn b.v. '#', '##', '_', '/**' (helaas dan ook afsluiten met /**, niet met */)

- hightech help-display :
	- gebruik evt. de redirectoperator "<<-" is i.p.v. "<<", om voorloop-tabs te verwijderen als die geen betekenis hebben (alleen dienen om het script zelf leesbaar te maken)
	- redirect naar een if-statement i.p.v. naar de dummy opdracht ":"
	- voorbeeld:
		if [[ "-h" = "$1" || "--help" = "$1" ]]
		then cat;exit
		else :
		fi <<-'_'
			dit is helptekst
		_
		OF compact maar onleesbaar
		{ [[ "-h" = "$1" || "--help" = "$1" ]] && { cat;exit; } || :; } <<-'_'
			dit is helptekst
		_

	- cat is eerste commando dat stdin leest, en leest hem helemaal leeg, zodat exit niets meer krijgt
	- ':' is gewoon het kortste en snelste (bash built-in) commando dat niets doet; het maakt dus ook stdin niet leeg, maar daar is geen 1 simpel commando voor.

=== bestanden sparse concateneren ===

0 gewoon concateneren gebeurt in linux met cat en redirect (en niet zoals in dos met copy):
	$ cat bestand1 bestand2 > bestand1+2
	- bestand1+2 is nooit sparse, zelfs als 1 en 2 dat wel zijn

0 in principe kunt ge dat met 2 keer dd doen, met "oflag=append,notruncate conv=sparse bs=$schijfsysteemblocksize", (sparse gebeurt per output block size), maar
	- BUG: kopieert een staart van zeroes niet mee
	- BUG: de 2de dd blijkt (altijd?) bij het begin van het 2de deel bytewaarden te veranderen!!

- WERKT WEL: pipe van cat naar copy van file descriptor 0, vb.:
	$ ll -s *
		>>>
		21636 -rw-rw-r-- 1 dirk dirk 4294967296 mrt 25 23:21 bestand1
			0 -rw-rw-r-- 1 dirk dirk      36864 mrt 25 23:21 bestand2
		<<<
	$ cat bestand1 bestand2 | cp --sparse=always /proc/self/fd/0 bestand1+2
	$ ll -s *
		>>>
		21272 -rw------- 1 dirk dirk 4295004160 mrt 25 23:23 bestand1+2
			0 -rw-rw-r-- 1 dirk dirk      36864 mrt 25 23:21 bestand1
		21636 -rw-rw-r-- 1 dirk dirk 4294967296 mrt 25 23:21 bestand2
	<<<

=== $IFS nakijken ===

- IFS bevat meestal controle-characters, niet te zien met echo $IFS, daarom
	- octaal printen
		$ printf "%s" "$IFS" | od -c -t x1
		>>>
		0000000      \t  \n
				 20  09  0a
		0000003
		<<<
	OF
	- als here-string catten, met expansie van tabs (als ^I) e.a. non-printing characters, en aanduiding van lijneinde door '$'
		$ cat -et <<<"$IFS"
		>>>
		 ^I$
		$
		<<<

=== IFS tijdelijke waarde ===

- IFS kan, zoals andere variabelen, iets als een tijdelijk waarde toegewezen krijgen, als prefix van een opdracht:
	$ naam=waarde opdracht"
	- die 'tijdelijke waarde' wordt aan de opdracht doorgegeven via het environment dat het krijgt; in C-termen is dit als char envp[], cfr. main(char argv[]). Voorbeeld:
	>>>
		$ test=1,2,3,4
		$ IFS=, read -a entries <<<"$test"
		$ echarr entries
		entries[0]=1=
		entries[1]=2=
		entries[2]=3=
		entries[3]=4=
	<<<
	- OPGELET woordsplitsing en expansies van variabelen gebeuren in de shell voor de opdracht wordt uitgevoerd, dus heeft die tijdelijke waarde van IFS daarop geen effect. Enkel in een speciale constructie, b.v. door een variabele tussen '' als argument van eval op te geven, zodat de expansie pas door de 'eval' gebeurt, is dat zichtbaar :
		$ reeks=(1 2 3)
		$ echo "${reeks[*]}"
			>>>1 2 3<<<
		$ IFS=, echo "${reeks[*]}"
			>>>
			1 2 3
			<<<
		$ IFS=, eval 'echo "${reeks[*]}"'
			>>>
			1,2,3
			<<<
		$ IFS=, eval 'echo "$IFS"'
			>>>
			,
			<<<
	- OPM : tijdelijke waarde van IFS is WEL nuttig voor b.v. woordsplitsing in een read
	- OPM : brace expansion, o.a. {1..5}, gebruikt altijd een gewone spatie als separator, NIET $IFS

=== array sorteren ===

- zie (https://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash)
	>>> man bash
	Words of the form $'string' are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard.
	<<<
	- waarden MET evt. spaties :
		- NIET IFS tijdelijke waarde geven door assignment vooraan opdracht: zie sectie "IFS tijdelijke waarde"
		$ [ -v IFS ] && ifsOld="$IFS" || unset ifsOld
		$ IFS=$'\n'
		$ array=($(sort <<<"${array[*]}"))
		$ [ -v ifsOld ] && IFS="$ifsOld" || unset IFS
			- gebruikt here-string "<<<"
			- OPGELET : [*], NIET [@] : wordt anders gequote :
			>>> man bash
				"${name[*]}" expands to a single word with the value of each array member separated by the first character of the IFS special variable, and "${name[@]}" expands each element of name to a separate word.
       		<<<
			- sort -u : unique
			- OPGELET IFS= array= : 2 assignments op 1 lijn, worden opeenvolgend en definitief toegewezen
				- is anders dan bash-statement "naam=tijdelijke_waarde opdracht"
				- daarom IFS bewaren en herstellen via ifsOld
	- ENKEL waarden ZONDER spaties :
		$ array=($(IFS=$'\n';sort <<<"${array[*]}"))
			- werkt juist vanwege [*] niet met spaties in waarden
			- maakt er gebruik van dat sort toch in subshell gebeurt:
				- toewijzing aan IFS blijft daar
				- NIET IFS tijdelijke waarde geven door assignment vooraan opdracht: zie sectie "IFS tijdelijke waarde"
				- array assignments mogen over meer dan 1 lijn gebeuren, t.e.m. afsluitende ')'

=== random nummers genereren ===

- beperkt bereik: bast variabele $RANDOM: random integer between 0 and 32767

- groot bereik:
	>>>
	/dev/random, /dev/urandom and /dev/arandom are special files that serve as pseudorandom number generators. They allow access to environmental noise collected from device drivers and other sources.
	- /dev/random typically blocks if there is less entropy available than requested;
	- /dev/urandom typically never blocks, even if the pseudorandom number generator seed was not fully initialized with entropy since boot.
	- /dev/arandom blocks after boot until the seed has been securely initialized with enough entropy, and then never blocks again.
	<<<
	- b.v.
	$ dd if=/dev/urandom count=12 bs=8 2>/dev/null | od -vt x8 -w8 -A n
		- od : octal dump
			-v, --output-duplicates : do not use * to mark line suppression
			-t x8 : --format=TYPE[SIZE], x hexadcimaal, 8 bytes per integer
			-w8 : 8 bytes per lijn
			-A n : geen radix voor address, betekent ineens geen adres (maar wel nog de spatie voorzien tussen adres en dump)
	>>> OPM: heeft voorloop-spatie
	 056ebc59d8333376
	 5970a74cc2d5c2fc
	 d3c1326625a74b65
	 41e49b06dda0146f
	 d85ba0c49bde545b
	 9eab58b106cd0ce1
	 c6dedafc1b53c912
	 891dc2756ae7385a
	 489713e2fa85556f
	 08308483cfadfd51
	 453f5d6f9aa8d78e
	 a4553731d7e1140c
	<<<

- OPGELET met sorteren. Als ge b.v. enkel unieke nummers wilt, en ze zijn in hex formaat, dan NIET 'numeriek' sorteren die sort stopt op 1ste hex letter en bepaalt van dat stukje de uniciteit
	- b.v. met UUIDs, gesorteerd in array en uniek gemaakt:
		$ unset rnds;rnds=($(for (( i=0 ; i < 1000 ; ++i ));do uuidgen;done | sort -u)); echo  "${#rnds[@]}" = "${rnds[@]}"

=== shell script afdrukken zonder commentaar ===
- pijp het hele script naar bash in de body van een functie, en gebruik de bash builtin "type" om het mooi geformateerd en zonder commentaar te tonen; tail en head verwijderen de functie-enveloppe terug;
	$ echo "f() { $(< ~/Documents/shellscripts/avidemux2ffmpeg.sh); }; type f;" | bash | tail -n +4 | head -n -1
	OF
	$ { echo "f() {"; cat ~/Documents/shellscripts/avidemux2ffmpeg.sh; echo "}; type f;"; } | bash | tail -n +4 | head -n -1

== PROGRAMMEREN ==

=== C compileren en linken ===
	$ gcc -o test test.c
	-o test : naam uitvoerbestand (is direct ook uitvoerbaar)

=== C compileren en linken met -dev packages ===

- vb. : GEZIPTE.PRG/UBUNTU/bsdiff/bsdiff-4.3.tar.gz
	- makefile aanpassen
		- dit vb. heeft syntax-variant die mijn make niet lust:
			- verander .ifndef en .endif in ifndef en endif, zonder voorloop-'.'
	- benodigde libraries : -lNAAM, in dit vb. -lbz2 dus NAAM=bz2, betekent dat
		- library libNAAM.so nodig is bij uitvoeren
		- symbolenindex libNAAM.a nodig is om het gecompileerde programma te linken aan de library
		- het bijhorende .h headerbestand voor het compileren van de broncode
			- de naam van het headerbestand staat in een #include-clausules van de .c-broncodebestanden; zoals in de oude tijd zoekt '#include <xx.h>' een header in het include-pad van de compiler, en '#include "yy.h"' een eigen header in de directory van de broncode zelf
			- de meeste #include <> -headers zijn van de standaard bibliotheken van de compiler zelf, en zijn samen daarmee geïnstalleerd
			- een beetje gezond verstand en kennis van c laat toe om in dit vb. "#include <bzlib.h>" te herkennen als nodige extra header, en anders zal de compiler wel reclameren dat hij die niet vind
			- de naam bzlib.h in dit vb. is dus niet te construeren uit NAAM=bz2
		- de symbolenindex .a en header bzlib.h kunnen geinstalleerd worden met het package xx-dev.versie.deb dat hoort bij het package xx-.versie.deb waaruit de library .so geinstalleerd is
			- .a en .so moeten van compleet dezelfde versie zijn, want .a bevat offsets in .so
				- .h is ten 1ste minder veranderlijk tot zelfs redelijk stabiel, en, als gewoon tekstbestand, wat vrijer van formaat
				- .a en .h zitten samen in xx-dev.versie.deb
			- als de library niet geïnstalleerd is: installeren samen met zelfde versie van package.versie.deb en package-dev.versie.deb, of dezelfde versie van -dev pseudo-installeren zoals hieronder beschreven
			- als de library al geïnstalleerd is: zoek package op dat de library installeerde :
				- zie sectie "welk package installeerde dit bestand"
					$ dpkg -S libbz2.so
						>>> libbz2-1.0:amd64: /lib/x86_64-linux-gnu/libbz2.so.1.0.4 <<<
						- :amd64 is de architectuur, is geen deel van de package-naam
			- welke versie van package is/wordt default geinstalleerd :
				$ apt policy libbz2-*
			- om uw systeem niet te vervuilen, kunt ge
				- in een VM de library en -dev installeren, het programma compileren, en de binary en man-bestand naar VM-host kopiëren, b.v. in /opt of in eigen ~/bin als het op $PATH moet staan
				- pseudo-installeren :
					- package downloaden en uitpakken
						- b.v. van [verzamelsite van Ubuntu](http://archive.ubuntu.com/ubuntu/pool/main/b/bzip2/)
						- NIET laten installeren, gewoon opslaan
						- data.tar.xz eruit uitpakken (fileroller, ...)
						- data.tar.xz zelf uitpakken (fileroller, ...)
							- hebben niet de hele directory-structuur nodig, zet de bestanden b.v. gewoon in ./include en ./lib
					- makefile aanpassen :
						- in CFLAGS bijzetten, om deze (vooraan) toe te voegen aan library-path en include-path van compiler (gcc) :
							-L ./lib/
							-I ./include/
							[-v] : verbose, laat o.a. zien hoe die paden worden samengesteld en afgezocht
					- compileren en linken :
						$ make
						[$ sudo make install] : installeert, na make, in systeem-directories
						- zie voor fout "undefined reference" volgende paragraaf
					- PROBLEEM programma's die niet voor Ubuntu en Debian geschreven werden (b.v. bsdiff voor FreeBSD) geven zelfs als de library en header gevonden worden, boodschappen zoals
							>>> bsdiff.c:(.text.startup+0x2b0): undefined reference to `BZ2_bzWriteOpen' <<<
							- zie [ToolchainTransition](https://wiki.ubuntu.com/NattyNarwhal/ToolchainTransition)
							- door default linker-instelling van Ubuntu (en Debian) moeten de broncodes .c VOOR de -lLIBRARYNAAM staan
							- ik weet nog niet hoe de makefile (CFLAGS) hiervoor kan aangepast worden, want dat is 1 parameter
					- OPLOSSING : make toont de uitgevoerde opdrachten; die gewoon kopiëren, en de -lxxx argumenten na de yyy.c argumenten zetten

=== assembler maken van C ===
	$ gcc -Wa,-adhln -masm=intel -g test.c > /media/ramdisk/test.asm
	-Wa,-options: Pass options to the assembler :
		a: turn on listings
		d: omit debugging directives;
		h: include high-level source
		l: include assembly
		n: omit forms processing
	-masm=intel : assembler min of meer in Intel MASM formaat (anders GAS Gnu Assembler)
	-g: Produce debugging information

=== alleen preprocessor laten lopen ===
	$ cpp test.c > /media/ramdisk/test.c.c

=== C stacktrace krijgen van crashend programma ===
	- met gdb (GNU debug) het programma laten lopen, en hopen dat het terug crasht
	$ gdb programma
	(gdb) run
	(gdb) backtrace

== APT en DPKG ==

=== apt of apt-get? ===

- apt voor commandolijn : is gebruiksvriendelijk, maar 'man apt' toont niet alle mogelijke opties
- apt-get voor scripts : heeft stabiele syntax, meer opties, en is ook vollediger gedocumenteerd

- NOOT : "axi-cache search" is een betere vervanger voor "apt search" en "apt-cache search"

>>> man apt(8):
	The `apt` command is meant to be pleasant for end users and does not need to be backward compatible like apt-get(8). Take a look at this post for more information on the new tool: http://mvogt.wordpress.com/2014/04/04/apt-1-0/
	A synopsis of the above link
		The big news for this version is that we included a new “apt” binary that combines the most commonly used commands from apt-get and apt-cache. The commands are the same as their apt-get/apt-cache counterparts but with slightly different configuration options.

	Currently the apt binary supports the following commands:
		list: which is similar to dpkg list and can be used with flags like --installed or --upgradable.
		search: works just like apt-cache search but sorted alphabetically.
		show: works like apt-cache show but hide some details that people are less likely to care about (like the hashes). The full record is still available via apt-cache show of course.
		update: just like the regular apt-get update with color output enabled.
		install,remove: adds progress output during the dpkg run.
		upgrade: the same as apt-get dist-upgrade -with-new-pkgs.
		full-upgrade: a more meaningful name for dist-upgrade.
		edit-sources: edit sources.list using $EDITOR.
<<<

=== apt[-get] update niet blind gebruiken ===

- "apt[-get] update" installeert niets, werkt alleen de database bij van wat beschikbaar is in de repositories

- dikwijls vindt ge commando's zoals
	0 sudo apt update && apt-get install ...
 maar soms geeft update belangwekkende waarschuwingen (met of zonder foutcode?) die ge eerst wilt oplossen. Dikwijls moet ge daarvoor gewoon update een 2de keer uitvoeren. Dus :
	# apt update
	[# apt update]
	# apt-get install ...

==== info van package ====

- geinstalleerde en beschikbare versies, en hun repository
	$ apt-cache policy packagenaam
- info zoals in USC (Ubuntu Software Center)
	$ apt-cache show packagenaam
- dependencies (andere packages nodig voor packagenaam)
	$ apt-cache depends packagenaam
	[--installed]
	[--recurse]
- reverse dependencies (nodig voor welke andere packages)
	$ apt-cache rdepends packagenaam
	[--installed]
	[--recurse]
- beschikbare versies en (reverse) dependencies
	$ apt-cache showpkg packagenaam

=== details van een package ===

- zie ook sectie "uit welke repository komt een package"

	$ dpkg-query -s e2fsprogs
		OF
	$ dpkg -s e2fsprogs
	-s, --status package-name... : Report status of specified package.
	>>>
		Package: e2fsprogs
		Essential: yes
		Status: install ok installed
		...
		Version: 1.42.13-1ubuntu1
		...
		 /etc/mke2fs.conf f3de4385c498ee9e01d1d703f0c3795d
		Description: ext2/ext3/ext4 file system utilities
		 The ext2, ext3 and ext4 file systems are ...
	<<<

=== versie van een package ===

- moet niet geinstalleerd zijn, maar gewoon beschikbaar in de geconfigureerde resources (zie sectie "lijst van alle definieerde repositories (ppa)"

- met wildcards als ge de naam maar ongeveer kent
	$ dpkg-query -l e2fs*
	OF
	$ dpkg -l e2fs*
	 -l, --list [package-name-pattern...] : List packages matching given pattern.
	>>>
		Desired=Unknown/Install/Remove/Purge/Hold
		| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
		|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
		||/ Name                        Version            Architecture       Description
		+++-===========================-==================-==================-===========================================================
		un  e2fsck-static               <none>             <none>             (no description available)
		ii  e2fslibs:amd64              1.42.13-1ubuntu1   amd64              ext2/ext3/ext4 file system libraries
		ii  e2fsprogs                   1.42.13-1ubuntu1   amd64              ext2/ext3/ext4 file system utilities
	<<<
	- packages met "ii" in 1ste kolom zijn geinstalelerd

- op exacte naam
	$ apt-cache policy e2fsprogs
	OF
	$ apt policy e2fsprogs
	e2fsprogs:
	  Installed: 1.42.13-1ubuntu1
	  Candidate: 1.42.13-1ubuntu1
	  Version table:
	 *** 1.42.13-1ubuntu1 500
			500 http://archive.ubuntu.com/ubuntu xenial/main amd64 Packages
			100 /var/lib/dpkg/status

- zie ook sectie "details van een package"

- systemrescuecd heeft die progs niet, zie gewoon :
	- bij download
	- http://www.system-rescue-cd.org/Detailed-packages-list

=== list all installed packages ===
	$ apt list --installed

=== welk package installeerde dit bestand ===

- voor executables kunnen we which het volledige pad laten bepalen van de versie die uitgevoerd zal worden (zoekt $PATH af)
	$ dpkg-query -S $(which qvlc)
	OF
	$ dpkg -S $(which qvlc)
	 -S, --search filename-search-pattern... : Search  for packages that own files corresponding to the given pattern
	>>> vlc-plugin-qt:amd64: /usr/bin/qvlc <<<

- maar pad is niet nodig :
	$ dpkg -S libbz2.so
	>>>
		libbz2-1.0:amd64: /lib/x86_64-linux-gnu/libbz2.so.1.0.4
		net.downloadhelper.coapp: /opt/net.downloadhelper.coapp/converter/build/linux/64/libbz2.so.1.0
		libbz2-1.0:amd64: /lib/x86_64-linux-gnu/libbz2.so.1.0
		libbz2-1.0:amd64: /lib/x86_64-linux-gnu/libbz2.so.1
	<<<
		- in dit vb. zijn /lib/x86_64-linux-gnu/libbz2.so.1.0 en /lib/x86_64-linux-gnu/libbz2.so.1 symlinks naar /lib/x86_64-linux-gnu/libbz2.so.1.0.4

=== van welke andere packages hangt een package af ===

	$ apt-cache depends vlc-plugin-qt:amd64
	[--installed]
	[--recurse]
	>>>
	vlc-plugin-qt
	  Depends: libc6
	  Depends: libgcc1
	  Depends: libqt5core5a
	  Depends: libqt5gui5
	  Depends: libqt5svg5
	  Depends: libqt5widgets5
	  Depends: libqt5x11extras5
	  Depends: libstdc++6
	  Depends: libvlccore9
	  Depends: libwayland-client0
	  Depends: libx11-6
	  Depends: <vlc-plugin-abi-3-0-0f>
		libvlccore9
	  Breaks: vlc
	  Recommends: vlc-bin
	  Replaces: vlc
	<<<

=== welke andere packages hangen van deze package af ===

	$ apt-cache rdepends libqt5webkit5
	[--installed]
	[--recurse]
	- lijst wordt samengesteld uit de package database; moeten niet geinstalleerd zijn, maar gewoon beschikbaar in de geconfigureerde resources (zie sectie "lijst van alle definieerde repositories (ppa)"

=== apt cache opruimen ===

- /var/cache/apt, hier komen .deb die apt-get download ()kan veel worden)
	- NIET bruutweg deleten of leegmaken, bij nood zie sectie "apt cache herstellen"
	- WEL
		# apt-get clean
		- laat enkel archives/, archives/partial/ en archives/lock staan

- apt wordt geconfigureerd in /etc/apt/apt.conf.d
	- ondervragen :
		# apt-config dump
		- b.v. enkel cache-instellingen:
			# apt-config dump | grep "^Dir\( \|::Cache\)"

- apt houdt lijst bij van wat repositories beschikbaar hebben in /var/lib/apt/lists
	- best afblijven, ook al is het 232MB

- apt houdt index van beschikbare gedownloade *.deb-installatiepakketten bij in /var/cache
	- /var/cache/apt/pkgcache.bin en /var/cache/apt/srcpkgcache.bin : ±100MB
		- lookup cache voor packages en source packages
		- mag verwijderd worden, worden opnieuw gemaakt bij opstarten en bij 'apt update'
		- definitief uitschakelen (apt-bewerkingen duren dan wat langer) :
			$ echo -e 'Dir::Cache::pkgcache "";\nDir::Cache::srcpkgcache "";' | sudo tee /etc/apt/apt.conf.d/00_geen_lookupfiles_cache
	- /var/cache/apt/archives/
		- bevat .deb, een lock-file, en een directory "partial" voor downloads die bezig zijn
		- kan zeker na een dist-upgrade 2GB groot zijn
		- mag symlink naar andere locatie zijn, maar met volledige rechten voor root
			- dus opgelet met netwerkschijven en VM shared folder
			- anders fouten zoals "chown to _apt:root of directory /var/cache/apt/archives/partial failed"
		- definitief uitschakelen :
			$ echo -e 'Dir::Cache "";\nDir::Cache::archives "";' | sudo tee /etc/apt/apt.conf.d/00_geen_packages_cache
			- worden opnieuw gedownload wanneer ze nodig zijn, b.v. mislukte installatie, of remove en toch terug installeren
		- volledig leegmaken (als geen apt* bezig is) :
			# apt-get clean
		- alleen verouderde weggooien :
			# apt-get autoclean
	>>> https://www.unixtutorial.org/ubuntu-clean-apt-cache/
		APT (Advanced Package Tool) keeps a cache of previously downloaded and installed packages even after they've been uninstalled. To save disk space the apt cache can be cleaned. This can be done in one of two ways. First will do it partially:
			# apt-get autoclean
		This command will remove only the outdated packages, like those superseded by a recent update, making them completely unnecessary. This may free up some disk space, but if you want to clean out the cache in its entirety you would run:
			# apt-get clean
		This command will remove all of the cached packages, saving the most space. This just means that if you were to ever need a package that was cached it will simply have to be downloaded again. Depending on your connection speed and data plan this may or may not be of concern. Other than that, it is safe to do.
		Perhaps noteworthy is that the apt cache resides in /var/cache/apt/archives/. You can see them if you run the ls command on that path or view it in a file manager. Manually removing packages from this directory should be safe, but with the simpler and faster methods above there's no need.
	<<<

=== apt cache herstellen ===

- gebeurt normaal door elke apt* opdracht die de cache benadert.
	- expliciet herstellen:
		# apt-cache gencaches
	- desnoods met de hand herstellen:
		# richt een goede cache in voor apt
		sudo mkdir -p /var/cache/apt/archives
		sudo mkdir -m 0700 /var/cache/apt/archives/partial
		sudo chown _apt:root /var/cache/apt/archives/partial
		# voor de zekerheid dit ook, maar ik denk niet dat die nodig is
		sudo touch /var/cache/apt/archives/lock
		sudo chmod 640 /var/cache/apt/archives/lock

- OPM: _maakVMvanBackup_gestript.sh maakt config-bestand in /etc/apt/config.d om de cache
	- elders te zetten, b.v. in /tmp/apt
	OF
	- niet te gebruiken, ook nadat de cache terug goed ingericht is
		- het apt cache "lock"-bestand en alle deb's komen dan in de / (maar worden wel schoon opgekuist)
		- die configs verwijderen:
			# rm /etc/apt/apt.conf.d/00_geen_apt_cache
	- apt cache-configuratie nakijken:
		$ apt-config dump | grep -i cache

=== .deb package installeren ===
- aanbevolen :
	# apt update
	# apt install ./mijnpackage.deb
	- OPM : steeds een absoluut of relatief pad voor mijnpackage.deb opgeven, anders gaat apt gewoon het internet op om die package te zoeken in de repositories
	- apt install zorgt ook voor alle dependencies

- brute kracht; niet aanbevolen, omdat "apt-get install -f" soms wat driest te werk gaat :
	# dpkg -i mijnpackage.deb
	- installeert rechttoe-rechtaan, zonder evt. nodige extra packages te installeren
	# apt update
	# apt-get install -f
	-f : fix dependencies

=== .deb package uitpakken/inpakken/bewerken ===

- DEB files are ar archives, which always contains the three files: debian-binary, control.tar.gz, and data.tar.gz.

- wijzigen manier 1
	$ dpkg-deb -R original.deb /media/ramdisk/doelmap
	-R, --raw-extract : Extracts the filesystem tree from a package archive into a specified directory, and the control information files into a DEBIAN subdirectory of the specified directory. The target directory (but not its parents) will be created if necessary. The input archive is not (currently) processed sequentially, so reading it from standard input (-) is not supported.
	- edit the extracted files
	- You should add a changelog entry (.../doelmap/usr/share/doc/<library>/changelog.Debian.gz) and change the version number in ("DEBIAN/control") if you modify anything in the package. The infrastructure to manipulate Debian packages assumes that if two packages have the same name and version, they're the same package. Add a suffix to the debian_revision part at the end of the version number; for sorting reasons the suffix should start with ~, e.g. 1.2.3-4.1 becomes 1.2.3-4.1~johnjumper1
	$ dpkg-deb -b /media/ramdisk/doelmap fixed.deb
	-b, --build directory [archive|directory] : Creates a debian archive from the filesystem tree stored in directory. directory must have a DEBIAN subdirectory, which contains the control information files such as the control file itself. This directory will not appear in the binary package's filesystem archive, but instead the files in it will be put in the binary package's control information area. If the second argument is a directory then dpkg-deb will write to the file package_version_arch.deb, or package_version.deb if no Architecture field is present in the package control file.

- wijzigen manier 2
	- Beware that unless your script is running as root, the files' permissions and ownership will be corrupted at the extraction stage. Rather than mess with permissions, you can keep the data archive intact and modify only the control archive. dpkg-deb doesn't provide a way to do that. Fortunately, deb packges are in a standard format: they're ar archives. So you can use ar to extract the control archive, modify its files, and use ar again to replace the control archive by a new version.
	- You should add a changelog entry (? in DEBIAN/templates ?) and change the version number in ("DEBIAN/control") if you modify anything in the package. The infrastructure to manipulate Debian packages assumes that if two packages have the same name and version, they're the same package. Add a suffix to the debian_revision part at the end of the version number; for sorting reasons the suffix should start with ~, e.g. 1.2.3-4.1 becomes 1.2.3-4.1~johnjumper1
	# mkdir tmp
	# cd tmp
	# ar p ../original.deb control.tar.gz | tar -xz
	- edit the extracted files
	# cp ../original.deb ../fixed.deb
	# tar czf control.tar.gz *[!z]
	# ar r ../fixed.deb control.tar.gz

=== repositories (ppa) ===

- dpkg beheert de database van packages voor Debian, en installeert ze van verschillende bronnen (repositories) naargelang prioriteiten

- apt, apt-get en apt-cache zijn frontends voor dpkg; ze bekijken ook de afhankelijkheden tussen packages
	- ppa repositories voor Ubuntu zelf worden bewaard in
		/etc/apt/sources.list
	- bijkomende ppa repositories best per leverancier apart in :
		/etc/apt/sources.list.d/%leverancier%.list

- sommige ontwikkelaars onderhouden een eigen repository met packages, volg de instructies aldaar

- Canonical biedt op "https://launchpad.net/" een plek, waar iedereen eigen repositories kan bijhouden: Personal Package Archive (PPA)
	- ZIE ook "Add launchpad PPA repository to Ubuntu.txt"
	- de gekozen broncode wordt door launchpad gecompileerd voor verschillende versies van Ubuntu. Dat wordt gepubliceerd in een ppa (personal package archive) repository.

- 4 manieren om repositories toe te voegen:
	- launchpad repo's : add-apt-repository
		- voegt ook ineens de verificatiesleutel toe
		- maakt zoals het hoort een apart .list-bestand in /etc/apt/sources.list.d
		0 Make sure you have the following python utility installed :
			0 apt-get install python-software-properties
		# add-apt-repository ppa:[USERNAME]/[REPOSITORY NAME]
		b.v. # add-apt-repository ppa:semiosis/ubuntu-glusterfs-3.4
	- andere methodes : eerst verificatiesleutel toevoegen vb.:
		OFWEL met de hand vanop launchpad
			- "Signing key" XXXXXX (zonder de prefix b.v. "1024R/") kopiëren van repository-webpagina van launchpad, na de hoofding "Technical details about this PPA", en dan
			$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys XXXXXX
		OFWEL van url naar keybestand op website ontwikkelaar
			$ wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -
			-q : quiet
			-O- : naar stdout
		OFWEL idem met curl (alternatief voor wget)
			$ curl -L https://www.virtualbox.org/download/oracle_vbox_2016.asc | sudo apt-key add -
			-L : volg redirect van evt. http-300 response
	- met 'Settings/Software & updates/other software'
		- ALTIJD verificatiesleutel toevoegen : zie hierboven
		- hiermee kunnen repositories ook tijdelijk disabled worden: worden dan uitgecommentariëerd in hun sources.list.d/repo.list
	- repo in eigen .list-bestand (extensie .list vereist) in /etc/apt/sources.list.d/REPONAAM.list :
		- syntax zie repository-webpagina van launchpad, na de hoofding "Technical details about this PPA"
			$ man sources.list
		- formaat "deb URL UBUNTU-VERSIE suite component..." of "deb-src ..."
			- suite : "xenial", "xenial-updates", ...
			- component : main, universe, contrib, ...
		- lijnen met "# deb" zijn niet actief, kunnen met 'Settings/Software & updates/other software' of met editor geactiveerd worden
		- andere commentaarlijnen gewoon beginnen met "##" of "#"
			- b.v. sourcecode repo kan al direct inactief toegevoegd worden voor evt. latere activatie
		- ALTIJD verificatiesleutel toevoegen : zie hierboven
		- .list-bestand maken :
			OFWEL met echo :
				# echo "deb http://download.virtualbox.org/virtualbox/debian xenial contrib" > /etc/apt/sources.list.d/oraclevirtualbox.list
			OFWEL met een editor:
				- OPGELET: altijd eindigen met een new-line, anders lopen de andere manieren mis
				>>> # mousepad /etc/apt/sources.list.d/virtualbox.lst
					deb http://download.virtualbox.org/virtualbox/debian xenial contrib
				<<<
		- ALTIJD :
			$ sudo apt update
			- uitvoer nakijken, bij fouten 2de keer proberen
	0 AFGERADEN : alle repo's samen in /etc/apt/sources.list
		0 echo "deb http://download.virtualbox.org/virtualbox/debian xenial contrib" > /etc/apt/sources.list

- als ge een ppa repository gebruikt om 'voor te lopen' op Ubuntu-ondersteunde updates van een programma, kan dat mislopen. Ge kunt dan de oudere, wel ondersteunde versie installeren als volgt, met ppa-purge :
	# apt-get install ppa-purge
	- ppa-purge moet natuurlijk maar 1 keer geïnstalleerd worden
	# ppa-purge ppa:otto-kesselgulasch/gimp-edge

- bij upgrade van ubuntu worden alle externe ppa’s and third-party repositories uitgeschakeld; na upgrade elk apart terug aanklikken in Software & Updates
	- ppa's behouden door een cfg-file aan te maken in /etc/update/update-manager/release-upgrades.d
		>>> https://support.system76.com/articles/ppa-third-party/
			There are two ways to tell update-manager to keep PPAs enabled. For both, create a file in /etc/update-manager/release-upgrades.d/ with a .cfg extension. You should give it a descriptive and unique name since other packages may provide their own config files. Users who want to keep all PPAs/repos enabled can put the following into that .cfg file:
				[Sources]
				AllowThirdParty = yes
			To keep one specific ppa/repo enabled, create a key = value pair inside a [ThirdPartyMirrors] section:
				[ThirdPartyMirrors]
				myppa = http://ppa.launchpad.net/myppa/stable/ubuntu/
			The key 'myppa' can be any string that is unique within the section. The value is the url of the ppa you want to keep enabled. You can find this url in the .list file for the PPA, which can be found in /etc/apt/sources.list.d/
		<<<

- voorbeeld : development versies van gimp installeren via ppa :
	# add-apt-repository [-r] [-s] ppa:otto-kesselgulasch/gimp-edge
	-r, --remove :			Remove the specified repository
	-s, --enable-source :	Allow downloading of the source packages from the repository (om zelf te compileren)
	- ppa:otto-kesselgulasch/gimp-edge : ppa van user otto-kesselgulasch voor programma gimp-edge
	# apt-get update
	# apt-get install gimp

==== lijst van alle definieerde repositories (ppa) ===
	$ grep -vrhE "^[ \t]*(#.*| *)$" --include "*.list" /etc/apt/sources.list /etc/apt/sources.list.d/*  | sort -u
	- zie sectie "cat zonder commentaar en lege lijnen"
	[-h] : print zonder bestandsnaam

==== lijst van packages uit niet-officiele repository ====
- selecteert (ruw script) packages die van elders dan http://[archive|security].[ubuntu|canonical].com/ geinstalleerd zijn/kunnen worden :
	$ bash ~/bin/ppa-installed.sh

==== uit welke repository komt een package ====
	$ apt-cache policy package_name
		- heeft bash completion (tab)
		- zie https://web.archive.org/web/20121024134944/http://carlo17.home.xs4all.nl/howto/debian.html
		>>> apt-cache policy package_name
		A general output would be:
				package-name:
				  Installed: <installed-version>
				  Candidate: <version-installed-when-doing-apt-get-upgrade>
				  Package-Pin: <version-of-Pin-in-etc-apt-preferences>
				  Version table:
				 *** <some-version> <minimum-priority-to-consider>
					   <priority-of-this-instance> <repository1>
					   <priority-of-this-instance> <repository2>
				 *** <some-other-version> <minimum-priority-to-consider>
					   <priority-of-this-instance> <repository3>
					   <priority-of-this-instance> <repository4>
		<<<
		- b.v.
		>>> $ apt-cache policy samba
			samba:
			  Installed: 2:4.3.11+dfsg-0ubuntu0.16.04.11
			  Candidate: 2:4.3.11+dfsg-0ubuntu0.16.04.16
			  Version table:
				 2:4.3.11+dfsg-0ubuntu0.16.04.16 500
					500 http://archive.ubuntu.com/ubuntu xenial-updates/main amd64 Packages
				 2:4.3.11+dfsg-0ubuntu0.16.04.15 500
					500 http://security.ubuntu.com/ubuntu xenial-security/main amd64 Packages
				 2:4.3.11+dfsg-0ubuntu0.16.04.12+lliurex1 500
					500 http://ppa.launchpad.net/llxdev/xenial/ubuntu xenial/main amd64 Packages
			 *** 2:4.3.11+dfsg-0ubuntu0.16.04.11 100
					100 /var/lib/dpkg/status
				 2:4.3.8+dfsg-0ubuntu1 500
					500 http://archive.ubuntu.com/ubuntu xenial/main amd64 Packages

			The /var/lib/dpkg/status stands for the installed package. The highest priority is thus 1000 for the (local) repository ./ (as we listed in the sources.list file).
		<<<
		- *** duidt de geinstalleerde versie aan, en zijn bron eronder
		- de 100 en 500 zijn prioriteiten : 500 installable, 100 installed
		- /var/lib/dpkg/status

== ONDERHOUD ==

=== upgraden (binnen zelfde release) ===

- apt-get update, upgrade en dist-upgrade worden gestuurd door de keuzes in launcher 'Settings/Software & Updates' (Configure the sources for installable software and updates)
	# spawn software-properties-gtk

- upgrade is soms nodig vooraleer packages succesvol nieuw bij te kunnen installeren, b.v. mysql zou hier al eens gevoelig aan zijn

- "apt-get upgrade" installeert nieuwste versie van packages voor huidige release, inclusief hele point release upgrade, b.v. van 16.04 naar 16.04.1
	- BELANGRIJK : installeert ook nieuwe kernelversie, en wijzigt daarom /boot/grub/grub.cfg; ofwel submenus voor alle bootschijven configureren in /etc/grub.d. ofwel alle bootschijven aansluiten zodat makegrub die ziet, ofwel reservekopie maken en van daaruit secties voor niet-aangesloten bootschijven terug kopiëren naar nieuwe grub.cfg
	- OPM: kunt ge geen packages voor opgeven (geeft geen fout, maar negeert dat gewoon)
		- de GUI update manager (launcher 'Settings/Software updater') toont welke upgrades beschikbaar zijn, en laat toe om daaruit te kiezen wat wel/niet bijgewerkt moet worden
		- met de hand kunt ge zien of er voor een package een nieuwe versie is:
			$ apt-cache policy packagenaam
		en dan enkel dat package "upgraden" met
			# apt-get install packagenaam
	- Alvorens bij te werken vanop de command line, eerst
		# apt-get update
			- herhalen bij foutboodschappen is dikwijls genoeg als oplossing
	- Dan pas
		# apt-get [--with-new-pkgs] [--auto-remove] upgrade
			[--with-new-pkgs] : om ook de nieuwe packages te installeren nodig om de kept-back packages te upgraden
			[--auto-remove] : verwijder direct overbodige packages
			[-y, --yes, --assume-yes] : Automatic yes to prompts
			- OPM: boodschap "The following packages have been kept back" :  'apt-get upgrade' vernieuwt alleen geïnstalleerde packages. Als de afhankelijkheden van geïnstalleerde software veranderd zijn, kunnen er nieuwe packages nodig zijn (boodschap 'packages held back' bij apt-get upgrade), of geïnstalleerde packages overbodig
		- als --with-new-packages niet voldoende is, met de nodige voorzorgen:
			# apt-get dist-upgrade
				- gebruikt packages binnen dezelfde releasenaam (b.v. xenial), want zo is dat geconfigureerd in /etc/apt/sources.list; doet dus geen upgrade naar andere releasenaam zonder die naam te veranderen in /etc/apt/sources.list (zie sectie "release upgrade, b.v. van 16.04.x naaar 18.04.x"
	>>>https://askubuntu.com/questions/81585/what-is-dist-upgrade-and-why-does-it-upgrade-more-than-upgrade
		apt-get upgrade is restricted to the case where packages are to be replaced by newer versions, but no package needs to be added or removed. A new version of Firefox, for instance, should be installable with apt-get upgrade.
		However apt-get upgrade will refuse to work when there are additions or removals required by the updated versions. For example, when you have kernel linux-image-3.2.0-10-generic installed and linux-image-3.2.0-11-generic appears, the linux-image-generic package gets updated to depend on the newer version. In order to install the new kernel, you need to run apt-get dist-upgrade.
		Notice how an apt-get upgrade will say that the kernel packages have been held back. That's the cue for using apt-get dist-upgrade.
	<<<
	>>>man apt-get
		update
			update is used to resynchronize the package index files from their sources. The indexes of available packages are fetched from the location(s) specified in /etc/apt-get/sources.list. For example, when using a Debian archive, this command retrieves and scans the Packages.gz files, so that information about new and updated packages is available. An update should always be performed before an upgrade or dist-upgrade. Please be aware that the overall progress meter will be incorrect as the size of the package files cannot be known in advance.
		upgrade
			upgrade is used to install the newest versions of all packages currently installed on the system from the sources enumerated in /etc/apt-get/sources.list. Packages currently installed with new versions available are retrieved and upgraded; under no circumstances are currently installed packages removed, or packages not already installed retrieved and installed. New versions of currently installed packages that cannot be upgraded without changing the install status of another package will be left at their current version. An update must be performed first so that apt-get knows that new versions of packages are available.
	   dist-upgrade
		   dist-upgrade in addition to performing the function of upgrade, also intelligently handles changing dependencies with new versions of packages; apt-get has a "smart" conflict resolution system, and it will attempt to upgrade the most important packages at the expense of less important ones if necessary. The dist-upgrade command may therefore remove some packages. The /etc/apt-get/sources.list file contains a list of locations from which to retrieve desired package files. See also apt_preferences(5) for a mechanism for overriding the general settings for individual packages.
	   full-upgrade (is nog niet beschreven in man-page)
			full-upgrade performs the function of upgrade but may also remove installed packages if that is required in order to resolve a package conflict.
	<<<

=== release upgrade, b.v. van 16.04.x naar 18.04.x ===

- The command apt-get dist-upgrade will not automatically upgrade you from one release to another unless you have also updated your sources (/etc/apt/sources.list) to point at a newer release.

- "Dirty" upgrades, from one release to another, don't always go as planned :
	- Back up your current system.
	- Update your current system with
		# apt-get update
		# apt-get full-upgrade.
	OFWEL
	- Make sure you have the update-manager-core package installed:
		# apt-get install update-manager-core
	- Upgrade to the current release:
		# do-release-upgrade
	OFWEL
	- schakel alle repositories van derden uit (Software & Updates)
	- verander repositories van oude (b.v. xenial) naar die voor nieuwe (b.v. bionic) release
		# sed -s --in-place=xenial~ 's/xenial/bionic/g' /etc/apt/sources.list /etc/apt/sources.list.d/*.list
			- backupextensie : NIET ".list" als backupextensie, best wel iets dat eindigt op ".save", anders waarschuwingen van apt-get
		- doordat nu (in dit vb.) bionic staat in /etc/apt/sources.list, doet dist-upgrade een upgrade die een stap verder gaat : alle paketten van oude release (xenial) vervangen door die van nieuwe release (bionic)
		# apt update
		- OPM: apt update kan nu een waarschuwing geven dat hij de backup-bestanden negeert omdat ze een rare extensie hebben. Maar hij negeert ze dus
	- upgrade naar de nieuw ingestelde distributie :
		# apt-get dist-upgrade
			- b.v. voor door uzelf gewijzigde configuratiebestanden vraagt apt-get wat hij moet doen: vervangen, afblijven, eerst vergelijken
			0 beter niet als ge al wat aan uw systeem gewijzigd hebt :
			 [-y, --yes, --assume-yes] : Automatic yes to prompts
	- waarschijnlijk best heropstarten
	- schakel de nodige repositories van derden terug in (Software & Updates); update zou bij "OK" achter de schermen moeten gebeuren, kan geen kwaad dat te herhalen :
		# apt-get update
	- installeer nieuwe software

=== Where can I find the source code of Ubuntu ===

	>>> https://askubuntu.com/questions/167468/where-can-i-find-the-source-code-of-ubuntu
	The source code for every package in the main and universe archives is in Launchpad, or you can get it by enabling Sources in the Software Properties dialog, and then doing apt-get source $packagename in a terminal, after refreshing the package information.
	<<<

- Linux Kernel Source Code:
	$ apt-get source linux-source-3.2.0

- Ubuntu Source Code:
	[Ubuntu archive](http://archive.ubuntu.com/ubuntu/)

- Specific Software Source Code for package $package:
	- in Settings/Software & Updates/tab [Ubuntu Software] source code aanvinken :
		v Source code
	# apt-get build-dep $package
		- install/remove packages in an attempt to satisfy the build dependencies for a source
           package
	$ apt-get source $package
		- download into the current directory the newest available version of that source package while respecting the default release, set with the option APT::Default-Release, the -t option or per package with the pkg/release syntax, if possible.
		- Source packages are tracked separately from binary packages via deb-src lines in the sources.list(5) file. This means that you will need to add such a line for each repository you want to get sources from; otherwise you will probably get either the wrong (too old/too new) source versions or none at all.
		- If the --compile option is specified then the package will be compiled to a binary .deb using dpkg-buildpackage for the architecture as defined by the --host-architecture option. If --download-only is specified then the source package will not be unpacked.
		- A specific source version can be retrieved by postfixing the source name with an equals and then the version to fetch, similar to the mechanism used for the package files. This enables exact matching of the source package name and version, implicitly enabling the APT::Get::Only-Source option.
		- Note that source packages are not installed and tracked in the dpkg database like binary packages; they are simply downloaded to the current directory, like source tarballs.
	- For instance:
		# apt-get build-dep ffmpeg
			- 300MB
		$ apt-get source ffmpeg

- You can download the complete source code ISOs from the Ubuntu download servers:
    http://cdimage.ubuntu.com/releases/<version>/release/source/ for currently-supported releases. For example, http://cdimage.ubuntu.com/releases/12.04/release/source/ for 12.04.
    http://old-releases.ubuntu.com/releases/<version>/release/source/ for obsolete/EOL releases. For example, http://old-releases.ubuntu.com/releases/12.10/source/ for 12.10. However, source ISOs seem to be available only for 12.10 onwards.

=== oude versies van kernel verwijderen ===

- laat enkel laatste 2 staan :
	- BELANGRIJK : ofwel alle bootschijven aansluiten, ofwel reservekopie /boot/grub/grub.cfg, want die wordt bijgewerkt
	$ sudo apt-get update
	- herhalen bij foutboodschappen is dikwijls genoeg als oplossing
	$ sudo apt-get autoremove
	- OPM: duurt minuten
	- NADIEN : indien nodig secties voor niet-aangesloten bootschijven terughalen uit reservekopie /boot/grub/grub.cfg
	- OPM: misschien best herstarten nadien
	- Laat oude headers staan in /usr/src, >50MB per versie. Daarom van tijd tot tijd voor alle oude versies (vergelijken met /boot) met de hand opkuisen:
		$ sudo apt-get purge linux-headers-4.4.0-34

=== programma installeren naar eigen pad ===

- als ge weet naar welke paden het progr. installeert, kunt ge die op voorhand vervangen door links naar de gewenste installatiedirectory
	- b.v. FlighGear zet gigabytes databestanden in /usr/share/games/flightgear/

- veel programmas zijn te krijgen in een portable formaat appimage. Die kopiëert ge gewoon waar ge wilt, b.v. mijn SDATA/.stacks/. Alternatieven zijn snap, sterk geïntegreerd in Ubuntu en verspreid over heel de directory-structuur, en flatpack, minder goed geïntegreerd maar even zeer verspreid.
	- zie sectie "appimage"
	- zie sectie "flatpak"
	- zie sectie "snap"

- met dpkg i.p.v. apt install
	- goed testen in VM snapshot
	>>>  https://askubuntu.com/questions/392644/install-program-to-home-folder-not
		There doesn't seem to be any option on apt-get for this. But there is for dpkg! (Untested as I'm doing this from memory. This DOES NOT WORK for packages that install stuff in weird places.)
		- download the .deb package
			# apt-get download hetprogramma
			# dpkg -i --instdir=mijnpad hetprogramma_versiestring.deb
		- WARNING. Using the following incorrectly (or even correctly) will probably destroy your system.
			- The man page for dpkg also has a --admindir= flag that, quote: "Change default administrative directory, which contains many files that give information about status of installed or uninstalled packages, etc. (Defaults to /var/lib/dpkg)" So in theory, if dpkg is complaining about package conflicts and dependencies, you can use the above to build a completely separate dependency tree, containing required libraries that would otherwise conflict with your system's main libraries and dependencies. (Do not use --admindir=YOURDIR without --installdir=YOURDIR. It'll mess things up)
		- Also look at the --root=dir option in the dpkg manual page. It's probably safer than using --admindir=YOURDIR and --installdir=YOURDIR
	<<<

==== appimage ====

- een AppImage is een klein stuk executable (het bestand "runtime") in de eerste 16 (ongebruikte) sectoren van een ISO-9660 image (deprecated) met zizofs compressie (bestand per bestand), of geconcateneerd voor een gewoon squashfs-bestand
	- zizofs maken met "mkzftree"
	- niet installeren: gewoon uitvoerbaar maken en uitvoeren
	-  geen sandbox of andere beveiliging van de pc, dus alleen vertrouwde bronnen gebruiken om appimages te zoeken
		- zie [Firejail sandbox voor AppImages]( https://firejail.wordpress.com/documentation-2/appimage-support/)
	- in de root van het AppImage image staat de zogenaamde AppDir, b.v. aanmaken met [linuxdeployqt](https://github.com/probonopd/linuxdeployqt), d.w.z. alle nodige bestanden van de toepassing, en hun directorystructuur (/etc, /usr etc.), en verder o.a.
		- een icon .DirIcon
		- een .desktop voor de toepassing
		- een verplicht uitvoerbaar bestand (script of binary) "AppRun", dat b.v.
			- PATH en LD_LIBRARY prefixt met de ./usr/bin ./usr/games ... resp. ./usr/lib ... v.d. appimage
				- in flexibele toep. staan geen harde paden naar /usr enz. gecompileerd, en zoeken het nodige relatief tot de directory vanwaar ze gestart zijn
				- voor andere toep. gebruikt appimage 1 van 2 hacks om toep. zijn libs enz. te laten vinden:
					- binary patch bij het maken van de appimage, waarbij in de binaries van de toepassing "/usr" vervangen wordt door de even lange string "././", het pad waar appimage's bin/ lib/ enz. staan
					OF
					- library die voor de toep. een unionfs simuleert, die doet alsof de ./usr etc. van de appimage over /usr enz. gemount zijn
			- hoofdprogramma van de toepassing opstart, b.v. met "exec programma $@"
				- hard gecodeerd, of b.v. geparsed uit het 1ste Exec= statement van die .desktop
		- sommige gebruiken een generiek wrapper-script (van appimage maker), dat b.v. vraagt of ge een .desktop-bestand wilt om de toep. mee op te starten :
			- als root in "/usr/local/share/applications"
			- als gebruiker in "$HOME/.local/share/applications"
			- die vraag wordt overgeslagen als env.-variabele DESKTOPINTEGRATION om het even welke waarde heeft
			- die vraag wordt overgeslagen als een (mag leeg) bestand %appnaam%no_desktopintegration bestaat in een van : (b.v. ZimDesktopWiki_no_desktopintegration)
				"~/.local/share/appimagekit/"
				"/usr/share/appimagekit/"
				"/etc/appimagekit/"
	- mount zichzelf bij uitvoering op een zelf gemaakte /tmp/.mount???, en start daar ./AppRun met alle parameters van de opdrachtlijn. Daar zijn b.v. ook een .desktop en een icon te vinden, om b.v. zelf een menu-item mee te maken in de desktop-omgeving
	- als AppRun een shellscript is i.p.v. een binary, is het gebruikelijk dat die met grep in de Exec=-lijn van ./???.desktop het uit te voeren programma + default-parameters opzoekt.

- portable gebruik:
	$ for ai in *.AppImage;do [ -L "$ai" ] || mkdir $(realpath "$ai").{config,home};done
		- zoek naam van fysiek AppImage bestand, niet van de symlink die ernaar verwijst, en maak directories $naam.AppImage.config en $naam.AppImage.home
	>>>
		if you invoke an AppImage built with a recent (2017 en later) version of AppImageKit and have one of the following special directories in place, then the configuration files will be stored alongside the AppImage. This can be useful for portable use cases, e.g., carrying an AppImage on a USB stick, along with its data.
		- If there is a directory with the same name as the AppImage plus .config, then $XDG_CONFIG_HOME will automatically be set to it before executing the payload application
		- If there is a directory with the same name as the AppImage plus .home, then $HOME will automatically be set to it before executing the payload application
	<<<
		- $HOME ook voor b.v. ~/.cache)
		- OPM: appimages kunnen ook o.a. systeembrowser aanroepen, b.v. vanuit about, maar dan krijgt ge in uw AppImage.home/ een heel firefox profiel met o.a. ./.mozilla/ en ./.cache/mozilla/
	- om toch in b.v. desktop-bestanden een generieke naam te gebruiken, b.v. zim.appimage i.p.v. zim-9.0.99-gclib-7.d.-x86-64a.appimge :
		- hernoem de gedownloade appimage
		OF
		- zet er een hard link naar (op dezelfde schijf) met de eenvoudige naam
		OF
		- zet er een symlink naar, en maak bovengenoemde directories met de volledige naam
		OF
		- zet er een symlink naar, en maak bovengenoemde directories met de eenvoudige naam, en symlinks daarnaar met de volledige naam
	- werkt NOG NIET voor (mogelijk wel met zelf herpakken in squashfs)
		- Audacity-2.1.2.glibc2.15-x86_64 : Type 1 (iso), met binary AppRun
		- FBReader-0.99.4.glibc2.14-x86_64 : Type 1 (iso), met binary AppRun
	- WERKT voor
		- AppImageKit/pkg2appimage-1793-x86_64
		- audacity 3.1.2
		- avidemux : eigen of herverpakte appimages (niet officiele 2.7.6, is nog Type 1: iso)
		- Mapton-2.0.1-x86_64
		- slowmoUI-0.6-x86_64.AppImage
		- Stellarium-0.19.1-x86_64
		- waterfox-classic-2020.09-90.1.Build90.5.glibc2.17-x86_64
		- Zettlr-1.7.5-x86_64
			- opent links in browser, firefox maakt dan profiel in fake Zetrl*.AppImage.home/.mozilla/ en Zetrl*.AppImage.home/.cache/mozilla/
				- ofwel die vervangen door symlinks naar echte $HOME/...
				- ofwel gewoon geen *.AppImage.home en conf, want we maken tenslotte gewoon documenten die in backup-proc moeten
				- ofwel zie (https://github.com/darealshinji/AppImageKit-checkrt/issues/3#issuecomment-345523909)
		- Zim_Desktop_Wiki-0.67.glibc2.15-x86_64
		- Zoom-5.3.469451.0927.glibc2.17-x86_64
	- NIET GETEST voor
		? FlightGear-2020.2.1-x86_64 : te testen
		- eigen LibreOffice 6.4, want ik wil juist wel mijn $HOME gebruiken

===== appimage zelf mounten ===

- door de appimage zelf (als ge hem vertrouwt)
	$ xxx.appimage --appimage-mount
	- blijft gemount wachten tot Ctrl-C, dan terug prompt
OF
- met mount : nuttig als ge de appimage eerst wilt nakijken voor ge hem uitvoert
	- ISO image : de appimage runtime staat gewoon in de eerste 32k (0x8000) bytes, de System Area ("Unused by ISO 9660"); het appimage bestand kan gemount worden zoals elk ander cd-image, b.v.
		# mount -o ro -t iso9660 xxx.appimage /cdrom
		- evt. eerst testen of het een appimage met ISO image is: op offset 32768 (0x8000) staat dan 0x01 gevolgd door "CD001" :
		- zie sectie "bytes op offset in binary file"
			$ 2>/dev/null dd skip=32768 iflag=skip_bytes,count_bytes count=6  if=xxx.appImage | hexdump -e '1/1 "%02X" 5 "%c""\n"' | grep 01CD001
			OF (minder efficient)
			$ strings -t d *.AppImage | grep "32769 CD001" && echo Dit is een ISO-appimage || Dit is (wschlk) een squashfs-appimage
	- squashfs-bestand als ge de offset daarvan in de appimage opzoekt
		- vertrouwde appimage :
			$ offset=$(xxx.appimage --appimage-offset)
		OF
		- veilig met linux-tools : 2de voorkomen van squashfs magic word 0x73717368 ("hsqs") staat op offset 0 van het squashfs-bestand (1ste staat in het runtime-prefix) in het appimage-bestand
			- Zie sectie "offset van string in binary file"
		# mount -o ro,offset=$offset -t squashfs xxx.appimage /mnt
		- OPM: offset van 2de "hsqs" komt in alle squashfs-appimages die ik onderzocht overeen met de lengte van gekende appimage-runtime-versies, dus met die offset kunt ge de 2 scheiden en terug aaneen plakken:
			$ 2>/dev/null dd iflag=count_bytes count=$offset  if=xxx.appimage of=xxx.runtime
			$ 2>/dev/null dd skip=$offset iflag=skip_bytes if=xxx.appimage of=xxx.squashfs

===== appimage uitpakken =====

- zie sectie "appimage zelf mounten"
OF
- de appimage uitvoeren, en de inhoud kopiëren uit zijn /tmp/.mountxxxx/ mountpoint
OF
- met zijn eigen "runtime" (als ge de bron vertrouwt) :
		$ pad-naar/xxx.AppImage --appimage-extract

===== AppImage wijzigen ====

- zie sectie "AppRun script of exe"

- AppImage runtime maken de volgende variabelen beschikbaar voor AppRun script:
	- ISO (Type 1, deprecated)
		- APPIMAGE : (Absolute) path to AppImage file (with symlinks resolved)
		- APPDIR : Path of mountpoint of the image contained in the AppImage
		- OWD : Path to working directory at the time the AppImage is called
	- Squashfs runtime (Type 2) bijkomend :
		- ARGV0 : Name/path used to execute the script. This corresponds to the value you’d normally receive via the argv argument passed to your main method. Usually contains the filename or path to the AppImage, relative to the current working directory. ARGV0 provides information how the AppImage was called. When you call an AppImage through a symlink for instance, you can get the path to this symlink through ARGV0, while APPIMAGE would contain the absolute path to the file behind that symlink.
			- Scenarios where ARGV0 is really useful involve so-called multi-binary AppImages, where the filename in ARGV0 defines which program is called inside the AppImage. This concept can be implemented in a custom AppRun script

- ISO-appimage: het runtime-prefix van de/een originele ISO-appimage gewoon over de 1ste 32k bytes van de nieuwe zetten :
	$ dd if=originele.appimage of=/media/ramdisk/nieuwe.appimage bs=32k count=1
	$ dd if=gewijzigde.iso of=/media/ramdisk/nieuwe.appimage bs=32k seek=1 skip=1

- squashfs-appimage
	- ge kunt een nieuwe/gewijzigde squashfs-appimage zomaar achter zijn originele of een andere runtime te plakken, voor b.v. extra data, parameters in .desktop, of andere config-bestanden :
		- het runtime-prefix van squashfs-appimages is langer dan die van ISO-9660-appimages, want langer dan in de vrije 1ste 32k van een ISO zou passen (?omdat ISO mounten in elke linux zit?)
	- mksquashfs-opdracht van AppImageKit
		- is al v.4.4, bevat opties -offset die mijn v.4.3 nog NIET heeft, en -mkfs-time die in mijn v.4.3 nog -fstime heet, b.v. :
			>>>
				mksquashfs commandline: /tmp/.mount_appima0gB5Fs/usr/bin/../lib/appimagekit/mksquashfs /media/ramdisk/LibreOffice/LibreOffice.AppDir LibreOffice-6.4.6.standard.help-x86_64.AppImage -offset 188456 -comp gzip -root-owned -noappend -mkfs-time 0
			<<<
			- mksquashfs v.4.3
				-fstime <secs> :	Set fs time to seconds since epoch. Default to current time
			- mksquashfs v.4.4
				-mkfs-time <time> :	set mkfs time to <time> which is an unsigned int
				-fstime <time> :	synonym for mkfs-time
				-o, -offset <offset> :	Skip <offset> bytes at the beginning of <dest>. Optionally a suffix of K, M or G can be given
			- met 188456 de lengte van de runtime binary, waar appimagekit het squashfs image ineens achter plakt.
		-offset : niet nodig als ge eerst een gewone squashfs maakt en die dan met cat achter de runtime plakt

	- zie sectie "appimage zelf mounten", mounten op b.v. /cdrom
		$ offset= ..., voor gebruik verderop
	- bestanden wijzigen of toevoegen in aparte directory, met zelfde subdir-structuur
	- directory met gewijzigde/toegevoegde bestanden erover mounten met unionfs:
		$ unionfs -o cow mijnmap:/cdrom /mnt
	- nieuwe squashfs maken, met exclude van bestanden/directories die eruit mogen in de nieuwe versie
		$ mksquashfs /mnt /media/ramdisk/nieuwe.squashfs -comp gzip -root-owned -noappend -fstime 0 -e exclude1 exclude2 ...
			 -comp gzip : default, veruit de snelste decompressie
			 -noappend : evt. bestaande appimage (van eerdere poging) overschrijven, NIET bijplakken (zou gewoon bestaande items in root-directory genummerd hernoemen)
			 -root-owned : ken de reden niet, maar kan alvast geen kwaad, want image is toch read-only
	- achter zijn originele runtime zetten en nieuwe squash erachter plakken :
		- offset zoals gevonden voor mount
		$ dd iflags=count_bytes count=$offset if=oude.appimage of=/media/ramdisk/nieuwe.appimage
		$ dd oflags=seek_bytes seek=$offset if=/media/ramdisk/nieuwe.squashfs of=/media/ramdisk/nieuwe.appimage
	OF
	- achter b.v. de meest recente runtime zetten, b.v. van de appimagekit.appimage (zie .stacks/appimages/AppImageKit/*/) of gedownload van de website :
		$ cat nieuweruntime /media/ramdisk/nieuwe.squashfs /media/ramdisk/nieuwe.appimage
	- unmounten
	OF
	- met uitpakken: zie sectie "appimage uitpakken"
		- bestanden wijzigen, deleten of toevoegen
		- terug inpakken naar squashfs
			$ mksquashfs werkdir/ /media/ramdisk/nieuwe.squasfs -comp gzip -root-owned -noappend -fstime 0
		- verder zoals in procedure met mount van oude appimage

===== zelf AppImage maken ====

- zie sectie "AppRun script of exe"

- met [AppImageKit](https://github.com/AppImage/AppImageKit/releases), dat zelf een appimage is, en dus geen installatie nodig heeft
- gescript met [pkg2appimage](https://github.com/AppImage/pkg2appimage) :
	- heeft verzameling ["recipes"](https://github.com/AppImage/pkg2appimage/tree/master/recipes) (yaml scripts) die op hun beurt door het pkg2appimage script verwerkt worden
	- vb. (https://forum.flightgear.org/viewtopic.php?f=6&t=37527)
		>>>
		I used the pkg2appimage tool on ubuntu, it has a recipe for building an appimage of flightgear using the ppa.
		All you have to do is on a Ubuntu machine clone the repo:
			https://github.com/AppImage/pkg2appimage
		and then run
			$ bash -ex ./pkg2appimage recipes/FlightGear.yml
		<<<

===== AppRun script of exe ====

- AppRun in de '/'  van een appimage kan een binary of een shellscript zijn, of een symlink naar de toepassing zelf.
	- de huidige aprun.c (https://github.com/AppImage/AppImageKit/tree/master/src) is heel simpel, slechts 1 broncode-bestand, en bevat niets dat de in omloop zijnde aprun shellscripts niet ook kunnen en doen.
	- BESLUIT: er is geen reden om niet met een script te werken, als ge zelf appimages maakt of wijzigt.

- variabelen ter beschikking van een AppRun script: zie (https://docs.appimage.org/packaging-guide/environment-variables.html)
	- voor type 2 (squashfs) :
		>>>
		APPIMAGE :	(Absolute) path to AppImage file (with symlinks resolved)
		APPDIR :	Path of mountpoint of the SquashFS image contained in the AppImage
		OWD :		Path to working directory at the time the AppImage is called
		ARGV0 :		Name/path used to execute the script [kan naam v.e. symlink zijn].
					This corresponds to the value you’d normally receive via the argv argument passed to your main method. Usually contains the filename or path to the AppImage, relative to the current working directory.
		<<<

==== flatpak ====

- in vergelijking met appimage neemt flatpak GIGANTISCH VEEL SCHIJFRUIMTE in
	- package flatpak moet vooraf geïnstalleerd worden (~10MB)
	- b.v. Audacity appimage is 20MB, Audacity flatpak (als enige flatpak) zet 2,2GB op de schijf
	- elke toepassing heeft een runtime nodig, die zowat overeenkomt met een virtual machine (zonder de virtualisatie-technieken) of een docker; meerdere toepassingen/versies kunnen in principe dezelfde runtime gebruiken, maar dat zal wel de uitzondering zijn

- distributie-onafhankelijk app distributieformaat van Fedora (Red Hat)
	- draait in een zandbak, die naar believen (van gebruiker of toepassing) toegang kan krijgen tot de pc (directories, geluid, webcam, ...)
	- toepassingen worden verpakt met alle nodige bibliotheken
	- niet opgesloten in een grote exe, zoals AppImage, die gemount wordt, maar in gewone directories :
		- default flatpak-map is (met optie --system, default, voor alle users) : /var/lib/flatpak
		- persoonlijke flatpak-map is (met optie --user, persoonlijk) : ~/.local/share/flatpak
		- custom flatpak-map is (met optie --installation=customnaam) : "Path" in /etc/flatpak/installation.d/customnaam.conf
		- per flatpak-map :
			├── repo : gegevens over repositories, en een cache voor lopende installaties (repo flathub zet zo 1GB op de schijf)
			├── runtime
			│   └── [per runtime bibliotheek die voor meerdere toep. dient]
			├── app
			│   └── [per flatpak toepassing]
			└── exports
				└── share
					├── applications
					├── dbus-1
					└── icons
		- persoonlijke gegevens per flatpak (ongeacht flatpak-map)
			~/.var/ : per user, zowel voor flatpaks geinstalleerd met --system als met --user
			└── app
				└── [ per toepassing, data directory which persists over app upgrades]

- backup nemen van een flatpak : gewoon de directories uit [flatpakmap]/app,  [flatpakmap]/runtime en ~/.var/app kopiëren

- eigen flatpak-map maken, b.v. op HDD of externe schijf :
	- zie man flatpak-installation
	# mkdir /etc/flatpak/installations.d/
	- maak eigen installatie-plek voor flatpaks (is wel voor alle users) :
	>>> /etc/flatpak/installations.d/stacks.conf
		[Installation "stacks"]
		Path=/media/sdata/.stacks/flatpaks
		DisplayName=Harddisk flatpaks op SDATA
		StorageType=harddisk
	<<<
		- kan meerdere namen bevatten, lijkt me simpeler om per naam 1 gelijkgenoemde x.conf te maken
		- StorageType : network, mmc, sdcard, harddisk
		- hiernaar wordt nu verwezen door voor elke flatpak-opdracht "--installation=stacks" op te geven :

- flatpak toepassingen worden uit repositories aangeboden, die aangemeld moeten zijn bij uw flatpak-map (--user, --system of "/etc/flatpak/installation.d/*.conf"). De meest gebruikte is flathub.org :
	$ flatpak [--installation=stacks] remote-add flathub https://flathub.org/repo/flathub.flatpakrepo
		[--installation=stacks] : voor installaties in de flatpak-map ingesteld in "/etc/flatpak/installation.d/stacks.conf", komt daar in de repo-subdirectory
		- repo wordt geregistreerd in [flatpak-map]/repo
	$ flatpak [--installation=stacks] install flathub flightgear
	$ flatpak run flightgear
		--installation=stacks niet nodig als er maar 1 versie is

==== snap ====

- snap is veel meer dan AppImage en Flatpak geïntegreerd in het systeem, met de toepassing zelf in /snap, een collectie basislibraries eveneens daar in een snap, automatische updates, en ondersteunende directories verspreid over de linux directory tree. Snap maakt daardoor wel de distributie van een toepassing gemakkelijker (door maar voor 1 systeem te moeten compileren), maar zijn niet uit een slanke backup procedure te houden.

=== programma uitvoerbaar maken zonder installeren ===

- b.v. om alternatieve versie te gebruiken, cfr. programma's Independent Jpeg Group hebben meer opties /zijn verder ontwikkeld, maar niet zo snel als de turbo versie :
	- downloaden (en bijhorende libraries ook)
		- zie sectie "programma installeren naar eigen pad"
		OF
		- zie [https://packages.ubuntu.com/bionic] of ineens [https://packages.ubuntu.com/bionic/allpackages]
	- uitpakken met fileroller o.i.d. naar pad van keuze
	- pad naar bijhorende libraries instellen, en uitvoeren MET padprefix, al is het maar "./"
		$ export LD_LIBRARY_PATH=...
		$ ./opdracht
		OF
		$ LD_LIBRARY_PATH=... ./opdracht

=== eigen programmas en man pages toevoegen ===

- eigen programma's moeten niet geïnstalleerd worden, als het pad ~/bin bestaat, wordt dit door de .bashrc scripts van Ubuntu aan PATH= toegevoegd. Voor man pages bestaat zoiets niet. De opdracht man gebruikt de opdracht manpath om man-bestanden te vinden. Als de variabele MANPATH bestaat, en begint met ':', b.v. ':mijnmanpad', wordt 'mijnmanpad' toegevoegd achteraan het resultaat van de opdracht manpath; anders geeft manpath gewoon de inhoud van MANPATH. In de mappen van MANPATH mogen ge-gzipte man broncode staan, b.v. fdupes.1.gz, of (een symlink naar) de broncode zelf.
Voorbeeld:
	$ mkdir ~/bin/man/man1
	- man1 : directory voor manpages van sectie 1, executables en shell built-ins
	$ ln ~/Documents/c/fdupes-master/fdupes.1 ~/bin/man/man1/fdupes.1
	>>>~/.pam_environment
		MANPATH=~/bin/man
	<<< (terug aanmelden of zo)
	$ man fdupes

- syntax : ZIE
	$ man 7 man
	$ man man-pages

=== core dumps verwijderen ===

Bij sommige problemen dumpt linux het geheugen in een bestand /core of /core.1234, soms in andere directories zoals /root. Die bestanden kunnen vrij groot worden (cfr. beschikbaar RAM), maar blijken gewoon weg te mogen.

http://www.linuxnix.com/how-to-find-and-remove-core-files-in-linux/ :
>>>
	Why we system administrators are interested in that core files?
	Ans : This is because of their size. As we do monitoring of systems on daily basis but suddenly your disk is full one day when you came to office, you are total blank thinking how come disk is full though there is no much user activity etc. So core files are one reason which will eat up our disk. Which you have to check for when sudden disk activity is observed.

	How to find core files ?
	#  find / -mount -type f -name core -print0 | xargs -0 ls -l

	This find command will search entire filesystem for core files.. once you find them use rm command to remove those files..
	# rm -rf core
<<<

=== USB of andere schijf checken op bad blocks ===

- slecht werkende stukken geheugen komen al eens voor op oude of goedkope usb-sticks. Is zeker lastig wanneer we die als herstelstick willen gebruiken. Best vooraf checken op slechte blokken. Kan zowel per partitie als voor hele schijf

b.v.
	OFWEL
	$ sudo badblocks /dev/sdc1
	OFWEL
	$ sudo badblocks /dev/sdc
	- doet enkel een readtest
	- optie -n : non-destructive write test (schrijft orig. block terug na schrijf -en leestest)
	- optie -w : destructive write test (sneller dan non-destructive, maar natuurlijk alle info kwijt)

=== langlopende reeks problemen met ttf-mscorefonts-installer ===

- Van tijd tot tijd is er een pop-up scherm dat zegt dat er download nodig is om de basis fonts van microsoft voor Windows XP te downloaden, die op veel websites gebruikt worden, en daarom ook in Ubuntu, Debian e.a. linux distris geinstalleerd worden naar pad
	/usr/share/fonts/truetype/msttcorefonts/

- Bij mij staan die fonts er, op de juiste plaats, maar de update van package "3.4+nmu1ubuntu2" of "ttf-mscorefonts-installer_3.4+nmu1ubuntu2_all.deb" triggert dat die van tijd tot tijd een popup toont dat ze als dependencies opnieuw gedownload en geinstalleerd moeten worden. Dat zijn bij elke update dezelfde bestanden, het zijn .exe bestanden van Microsoft zelf, uit de Windows XP tijd, die niet meer geupdate worden:
	. andale32.exe, arial32.exe, arialb32.exe, comic32.exe, courie32.exe, georgi32.exe, impact32.exe, times32.exe, trebuc32.exe, verdan32.exe, webdin32.exe

- bij die download via de Ubuntu package manager, loopt het dikwijls mis, zodat die update van het package mislukt, en de volgende keer opnieuw de popup triggert. Op zich is dit geen probleem, de fonts staan er en alles werkt, alleen is die popup erg vervelend. Dit is een of andere oude weerkerende bug die niemand wil oplossen:
	https://bugs.launchpad.net/ubuntu/+source/msttcorefonts/+bug/1607535

Sommigen zegggen dat de fout zit in de url in het .deb-package: ".../the fonts/...", zou  ".../the%20fonts/..." moeten zijn, kunt ge zelf niet veel aan veranderen.

Anderen zeggen dat ze de repository van Debian gebruiken, en zo ineens updaten naar versie 3.6 van dat package:
>>>
	ttf-mscorefonts-installer 3.4+nmu1ubuntu2 fails to install core fonts and should be updated to version 3.6 from Debian Edit
	I solved the problem by downloading (manually) the 3.6 version of ttf-mscorefonts-installer from debian
	(https://packages.debian.org/de/sid/all/ttf-mscorefonts-installer/download). installing that package with gnome's software center (and probably also ubuntu's software center) works perfectly.
	Probably this is a workaround and not a solution
<<<

- als de fonts nog niet geinstalleerd zijn, zelf downloaden (wschlk. NIET de verzameling "wd97vwr32.exe" downloaden) van b.v.
	https://sourceforge.net/projects/corefonts/files/the%20fonts/final/
	https://freefr.dl.sourceforge.net/project/corefonts/the%20fonts/final/
allemaal naar dezelfde, voor het overige lege, directory (bij mij staan ze b.v. al klaar in /home/dirk/.PlayOnLinux/fonts om naar nieuwe wine-versies te installeren). Dan een terminal openen in die map, en volgende commando's uitvoeren:
	$ sudo apt-get update
	$ sudo apt-get remove --purge ttf-mscorefonts-installer
	$ sudo apt-get install ttf-mscorefonts-installer
	- dit probeert weer dezelfde downloads van de .exe's, die waarschijnlijk weer mislukt (zie verder voor voorbeelden van fouten bij de download). Maar deze stap is wel nodig om de EULA (end-user license agreement) van Microsoft te aanvaarden. Opgepast, het scherm daarvoor wordt naar verluidt soms verborgen, bij mij verscheen het gewoon in het terminal-venster. Om te aanvaarden, met [tab] naar de <OK>-knop gaan, [enter], en nog eens [tab] naar de <Yes>-knop en [enter>
	$ sudo dpkg-reconfigure ttf-mscorefonts-installer
	- deze stap had normaal vanzelf na "install ttf-mscorefonts-installer" moeten volgen, doen dit nu manueel
	- in tekst-veld op terminal de directory met de font-.exe's tikken of plakken
	- met [tab] naar <OK>-knop
	- pakt nu alle bestanden van die directory uit (en mislukt als 1 daarvan geen font-.exe is !) en installeert de fonts erin

- behandeling van de vervelende pop-up:

Via die popup om installeren vragen, vraagt om root-paswoord en opent dan een terminal met :

	ttf-mscorefonts-installer: processing...
En dan volgen de downloads voor elke .exe apart. Als een download goed loopt, volgt er altijd/meestal toch een Warning:
	ttf-mscorefonts-installer: downloading http://downloads.sourceforge.net/corefonts/andale32.exe
	Get:1 http://downloads.sourceforge.net/corefonts/andale32.exe [198 kB]
	Fetched 198 kB in 1s (160 kB/s)
	W: Can't drop privileges for downloading as file '/var/lib/update-notifier/package-data-downloads/partial/andale32.exe' couldn't be accessed by user '_apt'. - pkgAcquire::Run (13: Permission denied)

Sommigen besluiten hieruit dat gebruiker _apt (de package-beheerder) eigenaar moet worden van de downloadmap:
	0 chown _apt /var/lib/update-notifier/package-data-downloads/partial/
maar dat helpt niets. Bovendien blijkt deze waarschuwing goedaardig te zijn, de download loopt goed af (zoals ook gebeurde, voor dezelfde fonts, bij installatie van PlayOnLinux)

Maar als niet ALLE downloads lukken, mislukt de update van de package en komt de popup weer. De fouten zien eruit als volgt, en na de eerste wordt het proces afgebroken:
	Err:1 http://downloads.sourceforge.net/corefonts/arial32.exe
	  404  Not Found
	E: Failed to fetch https://freefr.dl.sourceforge.net/project/corefonts/the fonts/final/arial32.exe 404  Not Found
	E: Download Failed
   OF
	Err:1 http://downloads.sourceforge.net/corefonts/andale32.exe
	  Protocol "http" not supported or disabled in libcurl
	E: Failed to fetch https://kent.dl.sourceforge.net/project/corefonts/the fonts/final/andale32.exe Protocol "http" not supported or disabled in libcurl
	E: Download Failed
   OF
	Err:1 http://downloads.sourceforge.net/corefonts/andale32.exe
	  The HTTP server sent an invalid Content-Range header
	E: Failed to fetch https://netcologne.dl.sourceforge.net/project/corefonts/the fonts/final/andale32.exe The HTTP server sent an invalid Content-Range header
	E: Download Failed

De update van het package kan ook manueel uitgevoerd worden:
	# /usr/lib/update-notifier/package-data-downloader
dit geeft dezelfde fouten.

OPM: misschien kan het probleem omzeild worden door een alternatieve repository toe te voegen
	https://launchpad.net/ubuntu/+source/msttcorefonts
   OF	(vanop die pagina via de link "Other versions of 'msttcorefonts' in untrusted archives")
	https://launchpad.net/ubuntu/+ppas?name_filter=msttcorefonts

=== map archiveren met tar ===

- niet met thunar, beter met tar op de commandolijn:
	. Thunar's 'create archive' dereferencet symbolic link mappen, i.p.v. de link in te pakken
	. 'Archive Manager' (fileroller) pakt beduidend groter in

- archief maken met naam hoofdmap (ook als dat ./ is)
	$ tar -cJf pad-naar-archief -C pad-naar-moedermap map-in-moedermap/
	- Compressieopties
		. z: gz		snel
		. J: xz/lzma	goed, pakt heel traag in maar snel uit
		. j: bz2		goed, pakt traag in en uit

- archief maken zonder naam hoofdmap
	. OPGELET niet met parameter '-C pad-naar-bestanden', want wildcard '*' wordt voordien al geëxpandeerd naar het commando door de shell, naar alle bestanden en mappen op het uitvoeringspad, i.p.v. pad-naar-bestanden
	$ cd pad-naar-bestanden ; tar -cJf pad-naar-archief  *
	- OPM na uitvoering van dit commando staan we op pad-naar-bestanden

- archief uitpakken (h om uit te pakken in doelmap van symbolische link, met behoud van de link, i.p.v. die link te vervangen door een map met dezelfde naam)
	- OPGELET: altijd eerst "tar --list -f archief"; NIET UITPAKKEN als basispad in archief '/' is, WEL als dat './' of '' is
	$ tar -xhf pad-naar-archief -C doelmap [--anchored --exclude=PATTERN]
	--exclude=PATTERN : moet zoals pad in archief zijn; b.v. typisch is een tar van heel het systeem zonder voorloop-/, dus om b.v. /usr niet uit te pakken : --exclude=usr, NIET --exclude=/usr
	 --anchored : exclude-pattern begint van root van archief (d.w.z. "" of "/"; anders wordt gematched vanaf elk sub-pad

=== 7z commando gebruiken ipv peazip-gui ===

- 7z comprimeert meerdere bestanden, i.p.v. zoals bzip2 en xz een enkel bestand (b.v. een hele tar)

- peazip heeft nukken en werkt ondoorgrondelijk, mijn geinstalleerde versie 6.0.0 gebruikt bovendien een beta van 7z : 7-Zip [32] 15.09 beta

- beste 7z-compressie
	$  7z a -t7z -m0=LZMA2 -mmt=on -mx9 -md=64m -mfb=64 -ms=4g [-mqs] ['-wbasispad'] padnaararchief.7z pad1/ pad2/*
	- -wbasispad : set working directory, stript basispad van pad gecomprimeerde mappen
	- -mqs: vanaf versie 15.12, sorteer per bestandsextensie voor
	- pad1/ : de volledige subtree pad1/ , met prefix 'pad1/'
	- pad2/* : de volledige subtree pad2/ , zonder prefix 'pad2/'
	- ZIE file:///usr/share/doc/p7zip-full/DOCS/MANUAL/switches/method.htm voor -m[parameters]

=== bestanden uit .Trash herstellen ===

- spacefm ondersteunt zelf geen .Trash
	- verwijderen met door Ubuntu geleverde gvfs-trash
	- thunar ondersteunt .Trash fout, herstelt bestanden verwijderd door gvfs-trash niet naar de juiste plaats
	- beheer en herstel met programmas van trash-cli :
		- restore-trash werkt enkel op .Trash-directory van mountpoint voor current directory

- interactief per bestand :
	$ restore-trash
	- presenteert lijst met alle bestanden origineel onder current directory, met verwijdertijdstip:
		>>> vb.
		... (genummerde bestandspaden)
		What file to restore [0..17]:
		<<<
	- Per 1 te restoren door hun volgnr. in te tikken

- alle bestanden herstellen die vernietigd zijn uit current directory en subdirectories:
	$ restore-trash
	>>> vb.
	... (genummerde bestandspaden)
	What file to restore [0..17]:
	<<<
	- aanvaardt maar 1 nummer, dus dat doen we niet met de hand, gewoon [Enter]. "restore-trash" geeft ook geen returncode als er geen verwijderde bestanden zijn onder di directory, dus daarmee kunnen we in een script niets doen. In de plaats daarvan laten we bash een sequence van alle nummers genereren als een soort teller (d.w.z. we gebruiken $i niet, verwijderen altijd nr. 0) :
	$ for i in {0..17} ; do ( echo '0' | restore-trash ) ; done;

=== bootvolgorde beheren ===

- blijvende instellingen in UEFI bios setup ([Esc] of [de]) sectie 'Boot'
	- laat bootbare devices (soms?) pas de 2de keer zien

- tijdelijke boot override in UEFI bios setup ([Esc] of [de]) sectie 'Save & Exit'
	- eerst 'save changes' voor evt. andere wijzigingen in setup
	- 'Boot Override' kiezen met cursor pijltjes
	- enteren op de keuze voor deze boot
	- geldt enkel voor deze boot

- boot menu openen met [F11] tijdens UEFI gedeelte van opstart (direct een paar keer F11 drukken kan geen kwaad)
	- is ook tijdelijk, maar zo blijft ge uit bios setup
	- langer tijd geven voor F11, door UEFI time-out in te stellen vanuit Ubuntu :
	$ sudo efibootmgr -t [seconden]
	- heeft geen effect bij UEFI bios setup/Advanced/Windows configuration/MSI fast boot of .../fast boot

- uefi boot volgorde kan ook ingesteld worden met Ubuntu's efibootmgr

=== boot-verloop ===

- zie /var/log/kern.log, met tijdstampen

- prints the time spent in the kernel before userspace has been reached, the time spent in the initial RAM disk (initrd) before normal system userspace has been reached, and the time normal system userspace took to initialize
	$ systemd-analyze time
	>>>
	Startup finished in 7.291s (firmware) + 6.439s (loader) + 35.389s (kernel) + 5.420s (userspace) = 54.541s
	graphical.target reached after 5.415s in userspace
	<<<

- print a list of all running units, ordered by the time they took to initialize
	$ systemd-analyze blame
	>>>
          3.544s NetworkManager-wait-online.service
           635ms media-sdata-.swapfile.swap
           473ms apt-daily.service
           458ms apt-daily-upgrade.service
	...
             2ms home.mount
             1ms snapd.socket
	<<<
		- OPM : samen 10.125s voor zelfde boot als "systemd-analyze time" hierboven

=== execute-toelating intrekken van directory tree die uit Windows gekopiëerd werd ===

- Blijkbaar krijgen alle bestanden dat van een Windows-pc overkomen (?unzip, kopiëren van NTFS-schijf of via netwerk?) write- en execute-toelating voor all. Is niet alleen gevaarlijk, ook vervelend voor inkleuring van 'ls' opdracht (kleur voor executable heeft voorrang). Die toelating kan ingetrokken met
	0 chmod -R o-w,a-x,a+X
	-R : recursief
	- o-w: niet writable voor other
	- a-x: niet executable voor all (of u=user, g=group, o=other)
		- OPM: voor directory betekend niet-executable eigenlijk dat ge er niet inkunt; daarom herstellen met +X als volgt:
	- a+X: directories wel executable voor all (opm.: +X op bestanden die voor niemand x-toelating hebben is een no-op, maar als ze voor u, g of o al een x-toelating hebben, geeft +X ze ook een x-toelating voor de gevraagde groep, hier all)

=== user toevoegen aan groep ===
	$ sudo usermod -aG groepnaam usernaam

=== toevoegen aan opstartmenu grub ===

- De opdracht grub-mkconfig maakt een nieuwe grub.cfg, in stdout
	[-o nieuwegrub.cfg] : naar nieuwegrub.cfg i.p.v. stdout (wordt overschreven)
	- "update-grub" is een alias voor "grub-mkconfig -o /boot/grub/grub.cfg"
	- eerst worden /etc/default/grub en /etc/default/grub.d/*.cfg gesourced
		- *.cfg komt in globbing-volgorde van de shell (d.w.z. gesorteerd op naam)
		- die moeten dus niet executable zijn, maar wel geldige bash syntax bevatten
		- doordat ze met "source" (".") worden uitgevoerd, komen alle variabelen die in die scripts gezet worden, in de shell die grub-mkconfig uitvoert
		- "/etc/default/grub" wordt standaard vervangen bij systeemupgrade (apt-get dist-upgrade), maar omdat die als eerste wordt uitgevoerd (en enkel variabelen zet), is dat gemakkelijk te herroepen/aanvullen door eigen scripts in /etc/default/grub.d te plaatsen
	- dan worden alle executables in /etc/grub.d  uitgevoerd in globbing-volgorde, en hun gezamenlijke stdout vormt de nieuwe grub.cfg
	- /etc/grub.d/40_custom is een simpele template, die alles vanaf lijn 3 naar stdout kopiëert; is gemakkelijk om vaste menu-entries in grub.cfg te krijgen
	- /etc/grub.d/41_custom voegt tenslotte syntax toe om een extra /boot/grub/custom.cfg of .../EFI/ubuntu/custom.cfg toe te voegen aan het grub menu

- menu entry toevoegen aan /etc/grub.d/40_custom (naar de vb. die daar al in staan)
	- vb. zie "_Xubuntu.adoc" sectie "systemrescuecd toegevoegd aan opstartmenu grub 2"
	- eerst de nodige modules laden voor
		- gpt-partitietabel
			insmod part_gpt
		- mbr-partitietabel (soms "ms-dos" genoemd)
			insmod part_msdos
		- ext2/3/4 partities
			insmod ext2
		- FAT (16,32) partities
			insmod fat
	- de schijfnaam waarvan er geboot moet worden, wordt gezocht met grub-opdract search :
		- op bestandsnaam die op de opstartschijf moet staan (pad vanaf root van bestandssysteem)
			search --set=root --file /PAD
		- op label van bestandssysteem (!= label van partitie)
			search --set=root --label LABEL
		- op uuid van bestandsssysteem (zonder {}), b.v.
			search --set=root --fs-uuid 88e332dc-deb9-4c9c-9dfc-e0afe7ad45bd
		- al deze opdrachten zetten dan de schijf- en partitienaam in de variabele root
	- als die opstartschijf een linux is met een eigen grubmenu
		- vb. met typisch pad naar een grub.cfg :
			configfile $root/boot/grub/grub.cfg
	- als die opstartschijf b.v. EFI-opstartbaar is, zonder eigen grubmenu
		- vb. met typisch pad naar een .efi boot image :
			chainloader (${root})/EFI/memtest86/bootx64.efi
			OF
			chainloader /efi/Microsoft/Boot/bootmgfw.efi
	- als die opstartschijf een linux-systeem heeft, rudimentair vb. :
		linux /boot/vmlinuz-VERSIE.efi.signed root=UUID=UUID_VAN_ROOT_PARTITIE ...
		initrd /boot/initrd.img-VERSIE

- de nieuwe 40_custom opnemen in de grubconfiguratie :
	- alle USB-schijven waarvan ge ooit wilt booten, insteken (mounts niet nodig), zodat ze gevonden worden door de 30_os-prober en zo in grub-menu komen
	- nieuwe grub.cfg eerst naar tijdelijke locatie maken, dan pas kopieren naar definieve plaats
		# grub-mkconfig -o /media/ramdisk/grub.cfg
		- dan backup maken van werkende grub.cfg
			# cp /boot/grub/grub.cfg /boot/grub/grub.cfg~
		- nieuwe erover kopieren
			# cp /media/ramdisk/grub.cfg /boot/grub/grub.cfg
		- OPM : update-grub is a stub for running "grub-mkconfig -o /boot/grub/grub.cfg" to generate a grub2 config file

- OPM: goed om te onthouden: grub-commandline heeft geen more, maar na "set pager=1" wordt er toch een soort more uitgevoerd voor elke opdracht

=== grub.cfg maken in chroot ===

- eerst volledige systeem (root, ESP, en zeker /usr en /var als die op aparte partitie staan) mounten in b.v. /mnt

- dan /mnt als nieuwe root gebruiken
	# chroot /mnt
		- wat in /mnt staat, is nu in /
- vervolgens speciale bestandssystemen mounten op (lege) voorziene directories
	# ls /dev /proc /sys
		- moeten nog leeg zijn
	# mount udev -t devtmpfs /dev
	# mount proc -t proc /proc
	# mount sysfs -t sysfs /sys
- reservekopie nemen
	# cp /boot/grub/grub.cfg /boot/grub/grub.cfg~herstel~
- nieuwe grub maken
	# update-grub
	OF
	- eerst nakijken, dan grub.cfg vervangen
		# grub-mkconfig -o-
		# grub-mkconfig -o /tmp/grub.cfg
			- nakijken
		# cp /tmp/grub.cfg /boot/grub/
- uit chroot gaan
	# exit

=== GUI theme ===

- XFCE (Xubuntu) thema configuratie :
	- Settings/Window Manager (Configure window behaviour and shortcuts) :
		- kiest lettertypes en plaats van icons op de titelbalk
		- kiest het xfwm4-thema voor vensterversiering (titelbalk, vensterranden en -hoeken, knop-tekeningen, ...) en hun kleuren
			- de thema's met een ./xfwm4/ subdir
			- "./xfwm4/themerc" bepaalt de kleuren (voor zover die niet in de grafische bestanden in die dirctory vastliggen)
				- kent kleurnamen uit .config/gtk3/gtk.css (@define-color, zie verder)
					- pas effect na uitloggen
		- direct effect
	- Settings/Appearance (customize the look of your desktop) :
		- kiest lettertypes, iconverzamelingen e.a.
		- kiest het thema voor gtk-toepassingen (mousepad, spacefm, geany, ...)
			- de thema's met een ./gtk-2.0/ subdir
				- lijkt ook voor gtk-3 toepassingen te dienen
			- de 3 kleuren links van themanaam zijn "bg_color", "fg_color" en "selected_bg_color" van sleutel gtk-color-scheme uit "./gtk-2.0/gtkrc"
			- bepaalt o.a. de kleuren van menus; o.a. Greybird haalt die (niet die van menubalk zelf) uit "custom menu clr" en "custom highlight clr") van "Theme Configuration", zie hieronder
	- Settings/Theme Configuration (configure GTK theme colours) :
		- zet in ".config/gtk3/gtk.css" secties "select-on" (hightlight), "panel-on" en "menu-on" in of uit block-comment (keuze ON/OFF), en definiëert daar eigen kleuren in; Die kunnen ook gebruikt worden in xfwm4-thema (zie hoger)
		- detailinstellingen zijn mogelijk met .config/gtk3/gtk.css (in Xenial toch, in Bionic niet meer :
			>>> Xubuntu 18.04 Release Notes :
			This release, we decided to remove the GTK Theme Configuration tool. It is no longer possible to override colors in all themes with a single application due to recent developments in GTK. It may return in a later release, but with limited functionality or theme support.
			<<<
		- in Xenial zet dit bovenaan in .config/gtk3/gtk.css een mooie menukleur, in Bionic niet meer
		>>>
			GtkMenuBar.menubar,
			GtkMenuBar.menubar.menuitem {
				background-color: #ffe55e;
				color: #0000ff;
			}
		<<<

- eigen themas in ~/.themes hebben voorrang op gelijkgenaamde themas in /usr/share/themes
	- elk thema is een directory, met in subdirectories themas voor verschillende gui-aspecten :
		- ./xwm4/ en ./gtk-2.0/ : zie hierboven
		- ./gtk-3.0/ : heeft subdir met b.v. kleurvarianten, assets (b.v. grafische elementen), ./apps met gtk.css e.a. bestanden per toepassing, ...
		- ./balou : splash popup van Xubuntu
		- ./xfce-notify-4.0/,  ./gtk-2.0-key : ??

=== boot Ubuntu into the console [i.p.v. GUI] ===

- zie ook sectie "in tty of console de display draaien"

- via grub :
	- Advanced Options ......
	- Ubuntu .... (recovery mode)
	? root : Drop in root shell prompt
	- system is read only at the moment, mount as rw so edits to files can be made
		# mount -o rw,remount /
	OF
	- "e" : edit boot options, op het opstartmenu-item naar keuze
	- als dit een Ubuntu-opstart is :
		- Voeg het volgende toe in de lijn "linux /boot/vmlinuz-... ... quiet splash $vt_handoff" na "quiet splash" : init=/bin/bash
			- wijzigt /boot/grub/grub.cfg NIET
		- F10 om met die opties op te starten; nu wordt NIET systemd geladen om o.a. alle services, zoals X, en de GUI te laden, maar wordt na /etc/fstab te interpreteren (zo goed als) onmiddelijk bash gestart in de terminal
			- als er problemen zijn met mounten, of misschien altijd (in grub.cfg-lijn linux ... staat er immers een "ro"), dan is / read-only gemount. Om wijzigingen kunnen te bewaren:
				# mount -o remount,rw /
				- OPM : doe dit pas als het root filesystem OK is, zodat het niet verder gecorrumpeerd wordt
			- nano e.d. is beschikbaar
			- voor opdrachten zoals reboot en poweroff moet /usr gemount zijn (anders "libip4tc.so niet gevonden"); sysctl-opdrachten werken niet, omdat de init bash is, niet sysctld
			- om evt. door te starten als het probleem opgelost is :
				# exec /sbin/init

- via systemd, is sinds Ubuntu 15.04 het systeem om services te starten en te stoppen :
	>>> https://linux.m2osw.com/boot-command-line-console-ubuntu-1604-and-newer
	- systemd has a list of variables you can tweak using the systemctl command.
		-to know what the current status is:
			$ systemctl list-units --type target --all
			--all : show the inactive targets as well
		- To boot in the console, you have to set that as the default:
			# systemctl set-default multi-user.target
			- prevents the graphical boot and starts using the console instead.
		- To go back to graphical boot, use the graphical target instead:
			# systemctl set-default graphical.target
			- boots to the usual lightdm (or gmd) prompt instead of a console.
		- to start X11 once in a while (I actually work in X11, but log out nightly so that way memory is not as tight and X11 is reset at least daily). Instead of startx (zie b.v. system rescue cd), we now want to run X11 with systemd which will make sure that all the necessary parts get loaded as expected.
			0 startx would start the X11 screen but not Unity/XFCE; you have to do that manually (setsid unity) ?? xfce
			# systemctl start graphical.target
			- starts X11 and Unity (Xfce voor Xubuntu)
			- won't give you the option of logging out of X11 as you could before with the log out menu. Instead, you have to switch back to multi-users with a similar command:
				# systemctl isolate multi-user.target
				- switches you back to the standard super fast text consoles.
				- will generally take you to TTY 7 or 8 which is likely to be a black screen or have some boot logs, not a login prompt or the console you started from. To fix that problem, you may use the chvt command line option:
					# chvt 1 && systemctl isolate multi-user.target
					- chvt N : change foreground virtual terminal; Ctrl+LeftAlt+FN (with N in the range 1-12) usually has a similar effect.
	<<<
	- zie ook sectie "GUI starten in een tty"

=== Swap file instellen ===
- zie (https://www.digitalocean.com/community/tutorials/how-to-add-swap-space-on-ubuntu-16-04)

- Maak de swapfile aan
	0 fallocate -l 16G /media/sdata/.swapfile
	>>> man swapon
		The swap file implementation in the kernel expects to be able to write to the file directly, without the assistance of the filesystem. This is a problem on preallocated files (e.g. fallocate(1)) on filesystems like XFS or ext4, and on copy-on-write filesystems like btrfs. It is recommended to use dd(1) and /dev/zero to avoid holes on XFS and ext4.
	<<<
	- het argument is niet overtuigend (geldt misschien alleen voor de --*-hole opties van fallocate), maar swapfile maken is zo zelden nodig, dat ik het maar bij de aanbevelingen houdt :
	# dd bs=1M count=16k if=/dev/zero of=/media/sdata/.swapfile
		- size en count in 'b' blocks van 512 bytes, 'c' 1-byte (char), 'w' 2-byte (word) of in 1024^n (K, M, G, ...; enkel k mag kleine letter)
		- beter grote bs en kleine count dan omgekeerd (b.v. bs=1 count=12G duurt eeuwen), maar (zeker voor /dev/zero) <= 1G (2G is te groot)
		>>>  info '(coreutils) dd invocation'
			The numeric-valued strings above (N and BYTES) can be followed by a multiplier: ‘b’=512, ‘c’=1, ‘w’=2, ‘xM’=M, or any of the standard block size suffixes like ‘k’=1024 (*note Block size::). Any block size you specify via ‘bs=’, ‘ibs=’, ‘obs=’, ‘cbs=’ should not be too large—values larger than a few megabytes are generally wasteful or (as in the gigabyte..exabyte case) downright counterproductive or error-inducing.
		<<<
- Defragmenteren
	- zie "_Xubuntu truuks & commandos.adoc" sectie "fragmentatie van bestand"
	 # e4defrag -c /media/sdata/.swapfile
- Beperk tot root
	# chmod 600 /media/sdata/.swapfile
- Maak er een swapfile van
	# mkswap -L SSWAPFILE /media/sdata/.swapfile
	- zet o.a. een UUID en een paar codes in .swapfile, tussen bytes 0x400 en 0x1000, maar verder niets
- Meld aan voor swappen
	# swapon /media/sdata/.swapfile
- Meld aan voor swappen bij elke opstart
	# cp /etc/fstab /etc/fstab~
	# mousepad /etc/fstab
	- lijn toevoegen:
		/media/sdata/.swapfile none swap sw 0 0
- Verlaag swapgretigheid van default 60 (servers) naar 10 (desktop pc):
	- maak custom sysctl-script, of voeg er een lijn aan toe :
	# echo "vm.swappiness=10" >> /etc/sysctl.d/40_mijn_swappiness.conf
- Na opstarten checken met
	$ cat /proc/sys/vm/swappiness
	$ cat /proc/swaps
	OF
	$ sudo swapon -s
- Afzetten met
	# swapoff /media/sdata/.swapfile
	OF
	# swapoff -a
	-a --all : alles in /etc/fstab, behalve "noauto"

=== systeeminstellingen configureren ===

- Ubuntu gebruikt hiervoor sysctl, b.v. swapgretigheid :
	- instellingen te zien in pseudo-bestanden onder /proc/sys/ :
		$ cat /proc/sys/vm/swappiness
	- instellingen voor lopende sessie te wijzigen met sysctl :
		# sysctl vm.swappiness=60
	- instellingen voor elk opstarten te wijzigen in /etc/sysctl.conf en /etc/sysctl.d/*.conf
		# echo "vm.swappiness=60" >> /etc/sysctl.d/40_mijn_swappiness.conf
	- zie [Documentation for /proc/sys/](https://www.kernel.org/doc/Documentation/sysctl/)

== BACKUP ==

=== backup met squashfs ===

- zie ook .../.backups/_backup.sh

- squashfs maken
	# cd sourcedir ; mksquashfs . archief.squashfs -comp xz -wildcards -e dev/* sys/* proc/* run/* tmp/*
	-comp xz : compressie; compressors available: gzip (default), lzo, xz
	-e /dev/* ... : sluit wel inhoud van /dev uit, maar /dev-map zelf staat in het archief
		- OPGELET : deze optie staat niet in manpage, wel in --help bij SYNOPSIS : "[-e list of exclude dirs/files]"
	[-no-duplicates] : do not perform duplicate checking.
	- om te gebruiken als een soort mountbaar iso- of zip-bestand, waarbij attributen e.d. geen rol spelen :
		-no-xattrs : don't store extended attributes
		-no-exports : don't make the filesystem exportable via NFS
		-always-use-fragments : use fragment blocks for files larger than block size
		[-noD] : data niet comprimeren (b.v. reeds gecomprimeerde media)
		[-b 4096] : kleinere or grotere blocks dan de standaard 128kB, groter geeft betere compressie (behalve natuurlijk bij -noD)
		0 [-nopad] : KAN NIET GEMOUNT WORDEN : do not pad filesystem to a multiple of 4K
		- voorbeeld :
		$  mksquashfs ./~Fotos fotos.squashfs -noD -always-use-fragments -b 4096 -no-recovery
	- aan bestaande squash worden bestanden gewoon toegevoegd :
	 	[-noappend] : do not append to existing filesystem, maar overschrijf het gewoon.
		- dank zij duplicates checking (tenzij -no-duplicates) vragen ongewijzigde bestanden geen extra plaats
		-  dubbels krijgen suffix _1 enz. :
			"Source directory entry bestand.ext already used! - trying bestand.ext_1"
		[-root-becomes NAME] : when appending source files/directories, make the original root become a subdirectory in the new root called NAME, rather than adding the new source items to the original root.
		[-no-recovery] : don't generate a recovery file; anders boodschap zoals
		>>>
			Recovery file "squashfs_recovery_mijnbackup.sqfs_13768" written
			If Mksquashfs aborts abnormally (i.e. power failure), run
			mksquashfs dummy /media/ramdisk/diverse.sqfs -recover squashfs_recovery_mijnbackup.sqfs_13768
			to restore filesystem
		<<<
		[-recover NAME] : recover filesystem data using recovery file NAME
	- OPM mksquashfs bewaart chmod en chown toegangsrechten en xattr, maar GEEN ACL, zoals mask:
		# getfacl ORIGINEEL/media/guest-tHmpt3/
		file: ORIGINEEL/media/guest-tHmpt3/
		owner: root
		group: root
		user::rwx
		user:guest-tHmpt3:r-x
		group::---
		mask::r-x	<<<<<<<<<<<<<<<<<<<
		other::---

		# getfacl ARCHIEF/media/guest-tHmpt3/
		file: ARCHIEF/media/guest-tHmpt3/
		owner: root
		group: root
		user::rwx
		group::r-x
		other::---
	- you can save the ACL by running getfacl -R at the root of the original filesystem and restore them after extracting the files with setfacl --restore.

- squashfs mounten
	# mount -t squashfs -o loop archief.squashfs /mnt

- info van squasbestand :
	$ unsquashfs -s archief.squashfs
	>>>
		Filesystem size 757549.93 Kbytes (739.79 Mbytes)
		...
		Number of inodes 31357
	<<<

- squasfs uitpakken :
	# unsquashfs -f -d /media/ramdisk archief.squashfs
	-f : force overwrite (zonder pakt unsquashfs niet naar bestaande directories uit)
	-d : doeldirectory

=== backup met rsync ===

- maakt gewoon kopie van heel het bestandssysteem, uitgez. machine-gebonden directories, o.a. die met speciale mount, die live gevuld worden door het actieve systeem, i.p.v. een schijfinhoud te tonen :
	>>> mount
		sysfs on /sys
		proc on /proc
		udev on /dev
		tmpfs on /run
	<<<

- zie "~/Documents/_installatie/knowhow Backup/Full system backup with rsync - ArchWiki.mht" (origineel op  https://wiki.archlinux.org/index.php/full_system_backup_with_rsync)
	- best vanaf recovery boot medium, maar
		>>>
		This method will work even while the system is running, but files changed during the transfer may or may not be transferred, which can cause undefined behavior of some programs using the transferred files.
		<<<
	# rsync [-n] [--delete] [-l] -aASXx -iv --exclude={"/sys/*", "/proc/*", "/dev/*", "/run/*", "/lost+found", "/tmp/*", "/mnt/*", "/cdrom/*", "/media/*"} bron/ doel
	- uitleg paramaters zie sectie "RSYNC"
		- OPGELET: bron/ MET '/' voor inhoud van die directorie, i.p.v. de directory bron zelf
	- is tegelijk backup EN restore, als op de doeldirectory de hele directory tree van doelsysteem gemount wordt, incl. de EFI boot-partitie (typisch gemount op /boot/efi).
		- wel in /boot/efi/EFI/ubuntu/grub.cfg en in /boot/grub/grub.cfg de file-system UUID van de partitie met de ubuntu-installatie vervangen door die van de doelschijf (de partitie waar /boot/grub/grub.cfg terecht komt) :
		>>> /boot/efi/EFI/ubuntu/grub.cfg
			search.fs_uuid 88e332dc-deb9-4c9c-9dfc-e0afe7ad45bd root
		<<<
		- deels geautomatiseerd:
			# doelfs=IN TE VULLEN
			# bootfs=$(sudo sed -nE '/.*search.fs_uuid/s/.* ([-a-z0-9]{36,36}) .*/\1/p' /boot/efi/EFI/ubuntu/grub.cfg)
			# for b in "$doel"/boot/{grub,efi/EFI/ubuntu}/grub.cfg;do echo -e "$b\n${b//?/=}"; sed -Ei=rsync~ "s%$bootfs%$doelfs%g" "$b";done
			- NIET VERGETEN: doel/etc/fstab aanpassen om zeker de doelpartitie te mounten op '/', en andere aanpassingen
			- na het opstarten van de doelschijf grubconfiguratie vervolledigen, of beter nog vooraf na een chroot (maar die ken ik niet goed genoeg) :
				# grub-mkconfig -o /media/ramdisk/grub.cfg
					- nakijken, en in plaats van (!!! DOEL !!!)/boot/grub/grub.cfg zetten
		- zie ook verder op archlinux-wiki om te booten vanaf die backup

=== backup met tar ===
- tar maken
	- tar BEWAART GEEN SOCKETS
	# tar -C /mnt --anchored --exclude=./tmp/* exclude=./lost+found/* --exclude=./dev/* --exclude=./sys/* --exclude=./proc/* --exclude=./run/* --acls --warning='no-file-ignored' -capf doel/archief.tar.xz .
	 -C, --directory /mnt : change directory to /mnt
		- OPGELET: bron-wildcards worden door shell in huidige shell geglobbed, dus in dat geval beter vooraf van werkmap veranderen: # cd /mnt ; tar ...
	-c, --create
	-a,  --auto-compress: compressie op basis van doel-extensie
	-p, --preserve-permissions : extract information about file permissions (default for superuser)
	-f, --file : pad naar archiefbestand ( -f- : stdout, is ook default in meeste compiles van tar)
	--warning='no-file-ignored': om goedaardige "socket ignored" niet op stderr te krijgen (en natuurlijk ook andere ignoreds niet)
	--acls : Enable the POSIX ACLs support
	--exclude /dev/* : sluit wel inhoud van /dev uit, maar /dev-map zelf staat in het archief
	--anchored : patterns match file name start (default for exclusion: patterns match after any '/')
	- usr en home apart:  --exclude=./usr/*  --exclude=./home/*
	0 --atime-preserve : tar leest en herstelt noatime van elk bronbestand. Enkel zin op mounts zonder optie -noatime, als ge progs gebuikt die op de atime lettten. Dus niet als bron nu of bij normaal gebruik met -noatime of readonly gemount is of wordt
		- preserve access times on dumped files, either by restoring the times after reading (METHOD='replace'; default) or by not setting the times in the first place (METHOD='system')

- tar mounten
	- zie "archief mounten" (archivemount) in dit bestand
	- werkt niet vlot met grote gecomprimeerde archieven
	- zonder sudo
	$ archivemount -o readonly /archief.tar.xz /mnt
	- unmounten zonder sudo met
	$ fusermount -u /mnt

- tar uitpakken: gewoon openen als archief
	- OPGELET: altijd eerst "tar --list -f archief"; NIET UITPAKKEN als basispad in archief '/' is, WEL als dat './' of '' is
	#tar -xf archief.tar [--anchored --exclude=PATTERN] -C doel
	OF
	# pushd doel; tar -xf archief.tar [--anchored --exclude=PATTERN] ;popd
	OF
	# cd doel; tar -xf archief.tar [--anchored --exclude=PATTERN]
	-C doel : tar zelf zet tijdens zijn werking current directory op 'doel'
	--exclude=PATTERN : moet zoals pad in archief zijn; b.v. typisch is een tar van heel het systeem zonder voorloop-/, dus om b.v. /usr niet uit te pakken : --exclude=usr, NIET --exclude=/usr
	 --anchored : exclude-pattern begint van root van archief (d.w.z. "" of "/"; anders wordt gematched vanaf elk sub-pad

=== backup met fsarchiver ===

- gebruik ik niet meer

- zie "~/Documents/_installatie/knowhow Backup"/_fsarchiver.txt

- fsarchiver maakt backup ofwel van filesystem, ofwel van directory tree. In het eerste geval kan alleen het hele filesystem gerestored worden, en dat heeft dan dezelfde filesystem UUID en LABEL als het origineel. Dat laatste brengt grub in de war bij restore naar 2de opstartschijf, want zowel in /EFI/grub.cfg als in boot/grub/grub.cfg wordt de UUID gebruikt om het bestandssysteem te kiezen vanwaar geboot wordt.

=== nuttig voor backup en herstel ===

- opletten voor boot- en mount-configuratie:
	- zie sectie "uuid van block devices en partities" :
		# blkid
	- /boot["grub"|"/efi/EFI/ubuntu"]/grub.cfg identifiëert boot-partitie met filesystem-UUID, /etc/fstab naar keuze met o.a. filesystem-LABEL of -UUID
	- als filesystem-UUID mee gearchiveerd wordt (WEL fsarchiver savefs, NIET squashfs, tar of cpio), moet hij bij restore naar andere partitie/schijf veranderd worden door b.v.
		# fsarchiver restfs archief.fsa id=0,dest=/dev/partitie,label=mijn_label,uuid=mijn_uuid
	- ZIE OOK sectie "zelf partition uuid en label instellen", sectie "zelf filesystem uuid en label instellen" en sectie "zelf random-uuid genereren"

==== vergelijk backups of directory trees ====
- b.v. kandidaten voor herstel vergelijken, met origineel en met elkaar
	OFWEL
	# rsync -naiAX kandidaat1/ kandidaat2/
	- uitleg: zie sectie "RSYNC"
	OFWEL
	- Meld Diff Viewer

==== filesysteem maken in een gewoon bestand ====

- zie sectie "bestand als virtuele schijf voorbereiden en mounten"

=== inhoud van systeemdirectories ===

- zie "https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html"
- zie "https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html"

- /usr is shareable, read-only data: should be shareable between various FHS-compliant hosts and must not be written to (behalve bij installaties). Any information that is host-specific or varies with time is stored elsewhere.

- /usr/local : een soort replica van de /usr directory tree voor programmas die buiten de distributie om geïnstalleerd worden
	- in XUbuntu staan /usr/local/sbin en /usr/local/bin in PATH voor /usr/sbin en /usr/bin
		- EN ZELFS voor /sbin en /bin, is dat veilig???
	- de afspraak is dat distributies met hun fikken afblijven van /usr/local

- /tmp directory must be made available for programs that require temporary files.
	- it is recommended that files and directories located in /tmp be deleted whenever the system is booted
	- mag dus gerust tmpfs ramdisk zijn, zeker als er een swapfile of -partitie is: dat laat het systeem zelf bepalen of en wanneer dingen in /tmp naar hard disk verhuizen

- /var/tmp : Temporary files preserved between system reboots
	- it is recommended that deletions occur at a less frequent interval than /tmp

- /var/log bevat (generaties van) logs van allerlei programma's
	- ./syslog wordt blijkbaar door elk programma naar wens bijgevuld
	- andere programma's schrijven hun eigen log, b.v. dpkg houdt een log bij van elke install, remove, upgrade, ...
	- logrotate sluit periodiek logs af, zipt de oude log, en wist zips van nog oudere logs
		- configuratie in etc/logrotate.conf en /etc/logrotate.d
		- laatste rotatiemoment per log in /var/lib/logrotate/status

- grote slokoppen op /var
	/var/cache/apt : cache van recent geinstalleerde packages
	/var/cache/apt-xapian-index : ? ook iets met apt
	/var/lib/apt/lists : index van al het beschikbare in de repositories
	/var/lib/dpkg : idem op dpkg-niveau
	/var/logs : kan serieus opgekuist en beperkt (minder lang bijhouden) worden indien gewenst, maar zolang er schijfruimte genoeg is; minder lang bijhouden heeft in ieder geval geen invloed op aantal schrijfbewerkingen op de schijf
		- zie sectie "journalctl"

- /run/user/1000
	- staat in env. variable $XDG_RUNTIME_DIR
	- base directory relative to which user-specific non-essential runtime files and other file objects (such as sockets, named pipes, ...) should be stored. The directory MUST be owned by the user, and he MUST be the only one having read and write access to it. Its Unix access mode MUST be 0700
	- MUST be created when the user first logs in and if the user fully logs out the directory MUST be removed
	- Files in this directory MAY be subjected to periodic clean-up. To ensure that your files are not removed, they should have their access time timestamp modified at least once every 6 hours of monotonic time or the 'sticky' bit should be set on the file
	- Applications should use this directory for communication and synchronization purposes and should not place larger files in it, since it might reside in runtime memory and cannot necessarily be swapped out to disk.
	- in bionic een tmpfs van 1,6GB

- ~/.cache/upstart bevat logs van userprogrammas
	- logrotate sluit periodiek logs af, zipt de oude log, en wist zips van nog oudere logs
		- configuratie ? (er is b.v. geen ~/.config/logrotate.conf)
		- laatste rotatiemoment per log in /home/dirk/.cache/logrotate/status

- /srv : "contains data served by this system", b.v. web- of ftp-server; leeg bij desktopgebuik
