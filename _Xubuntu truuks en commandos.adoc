= Truuks en commando's in Xubuntu
:description:  handige commando's die te moeilijk en met tevelen zijn om te onhtouden

- DE site voor kernel modules en hardware drivers: https://www.kernel.org/doc/Documentation/

- OPGELET : bash doet geen globbing tussen '' of "", geen $variable-expansie tussen ''

== NOODGEVALLEN ==

=== bootlog van andere linux op andere partitie zien ===

# journalctl -D /mnt/var/log/journal/
	- log wordt helaas pas geschreven als bootproces ver genoeg komt
	- zie sectie "linux logs"

=== Magic Alt Sysrq ===

- zie "https://www.kernel.org/doc/Documentation/admin-guide/sysrq.rst"
- zie "https://askubuntu.com/questions/11002/alt-sysrq-reisub-doesnt-reboot-my-laptop"

- zonder alt-sysrq (b.v.vanop afstand of in VM) :
	# echo "x" > /proc/sysrq-trigger
		- x : een van de sysrq codeletters
		- lijkt alleen te werken in een console (Alt-Ctrl-1 t.e.m. 6, Alt-Ctrl-7 is de Ubuntu GUI), niet in Ubuntu GUI terminal venster
		- de meeste commandos doen niets, hoogstens omschrijven ze zichzelf
		- veilig om te proberen :
			- h : help, werkt (maar zegt heel weinig)
			- s : sync alle gemounte bestandssystemen
			- m : dump kernel memory info to (your console: doet het niet) naar syslog
			- p : dump the current registers and flags .
			- t : dump list of current tasks to (your console: doet het niet) naar syslog
			- w : dump tasks that are in uninterruptable (blocked) state
		- onveilig, eerst veel leren :
			0 b : reboot without sync or umount
			0 e : send SIGTERM to all processes except init (zowat de Alt-F4 van windows: vraagt proces om af te sluiten)
			0 i : send SIGKILL to all processes except init (vraag proces om abort of zoiets)
			0 f : call oom_kill to kill a memory hog process (process dat out-of-memory geeft)
			0 r : zet keyboord 'raw' mode off and sets it to XLATE ???
			0 u : remount alle gemounte filesystems readonly
	- zo veilig mogelijk reboot forceren
		- op voorwaarde dat die letters echt werken
		- als dat in 1 string mag, nog bevestiging van zoeken
			# echo "reisub" > /proc/sysrq-trigger

- huidige status van welke Alt+Sysrq ge kunt doen :
	$ cat /proc/sys/kernel/sysrq
	>>> 176 <<<
	- 176 is 128+32+16
		 0 - disable sysrq completely
		 1 - enable all functions of sysrq
		>1 - bitmask of allowed sysrq functions : 
			  2 =   0x2 - enable control of console logging level
			  4 =   0x4 - enable control of keyboard (SAK, unraw)
			  8 =   0x8 - enable debugging dumps of processes etc.
			 16 =  0x10 - enable sync command
			 32 =  0x20 - enable remount read-only
			 64 =  0x40 - enable signalling of processes (term, kill, oom-kill)
			128 =  0x80 - allow reboot/poweroff
			256 = 0x100 - allow nicing of all RT tasks

- direct meer toelaten of verbieden :
	$ sudo -i
		- gewoon "sudo echo ... > ..." werkt niet, want redirect gebeurt terug buiten sudo
	# echo "bitmask" >/proc/sys/kernel/sysrq

- blijvend meer toelaten of verbieden :
	- Alt+sysrq wordt in Ubuntu gecontroleerd door /etc/sysctl.conf (NIET WIJZIGEN, wordt bij upgrade toch vervangen) en /etc/sysctl.d/*.conf :
	$ grep kernel.sysrq /etc/sysctl.d/*.conf
	>>>
		/etc/sysctl.d/10-magic-sysrq.conf:#   debugging dumps of processes: kernel.sysrq = 10
		/etc/sysctl.d/10-magic-sysrq.conf:kernel.sysrq = 176
		/etc/sysctl.d/99-sysctl.conf:#kernel.sysrq=1
	<<<
	- in /etc/sysctl.d/ een .conf bestand bij zetten dat na 10-magic-sysrq.conf sorteert, met de gewenste toelatingen

== PRODUCTIVITEIT ==

- zie ook "_Xubuntu ComposeKey multikey combinaties.txt"

=== Hele scherm zoomen, panning volgt muis ===

- In Window Manager Tweeks/Accessibility een toets kiezen voor 'key used to grab and move windows', b.v. Alt (niet shift, want dan werkt b.v. selecteren met shift ingedrukt niet meer), en dan zoomt het hele scherm met Alt+scrollwiel

=== panel sneltoetsen ===

- xkb-plugin-11 Keyboard Layouts
	. Shift+CapsLock : wissel keyboard layout (toegevoegd om tss. qwerty en draadloos azerty te wisselen)

=== window manager sneltoetsen ===
(zelf ingesteld, Super = rechter Windows-toets)
	. Super+num		toggle resize window naar scherm-helft of kwadrant, 0 mini, 5 maxi
	. Super+end		venster naar achtergrond
	. Super+omhoog	toggle oprollen tot titelbalk (shade)
	. Super+omlaag	toggle volle hoogte
	. Super+omhoog	toggle volle breedte
	. Super+d		toggle desktop
	. Alt+tab		schakelen tussen vensters
	. Super+tab		schakelen tussen vensters van zelfde programma
	. Shift+Alt+Ctrl+pijl verplaats naar workspace
	. Alt+F8		toggle sticky venster (zichtbaar op elke workspace)

=== window manager tweaks ===

- key used to grab and move windows (ook grab window edge/corners and resize window)
	. 'alt' kiezen in accessibility tab
	. alt + muisklik : grab en verplaats het venster
	. alt + averechtse muisklik : grab en verplaats dichtst bijzijnde vensterrand of -hoek = resize)

=== launcher sneltoetsen (settings/keyboard) ===

	. Super+k		Toon launcher sneltoetsen (settings/keyboard)
	. alt+ctrl+l	vergrendel scherm (paswoord ingeven)
	. alt+ctrl+t	command terminal emulator
	. alt+ctrl+F1-6	terminal 1-6
	. alt+ctrl+F7	X grafische terminal
	. Print			schermafdruk met dialoog voor bestemming
	. Ctrl+Print	schermafdruk naar XnViewMP
	. Super+d		desktop (toggle on/off)
	. Super+t		command terminal emulator
	. Super+a		application menu popup (application finder)
	. Super+q		'quick' run (application finder compact)
		opdracht	opdracht uitvoeren
		>opdracht	opdracht uitvoeren in bash zonder terminal (maar mét aliases)
		<opdracht	opdracht uitvoeren in bash in terminal met output, geen prompt
		?opdracht	manpage van opdracht (-a : all sections)
		??opdracht	info van opdracht
		$texscript	texdoc van (la)tex script
		/pad		filemanager openen in '/pad'
		~/pad		filemanager openen in '~/pad'
		http://		open url in browser
		https://	open url in browser
		file://		open url in browser
	. Super+LftAlt	whisker application menu popup
	. Super+e		editor (geany)
	. Super+shift+e	andere editor (mousepad)
	. Super+f		filemanager (spacefm)
	. Super+shift+f andere filemanager (thunar)
	. Super+b		browser (firefox)
	. Super+m		mail (thunderbird)
	. Super+p		pc monitor aanzetten (script beeldpc)
	. Super+o		tv uitvoer aanzetten (script beeldtv)
	. Super+c		calculator
	. Super+w		'word' (libreoffice writer)
	. Super+x		'excel' (libreoffice calc)
	. Super+g		Goldendict woordenboek
	. Super+z		nzbget met webinterface
	. Super+v		volume controle
	. Super+shift+v	volume controle tab 'playback'

=== bash shell sneltoetsen ===

- zie ook "_bash readline keys.txt"

	. ctrl+d	op prompt: exit
	. ctrl+d	bij lezen invoer van stdin, aan begin van nieuwe lijn : end-of-file
	. ctrl+c	job/script afbreken met SIGINT
	. ctrl+z	job/script stoppen met SIGSTOP: koppelt de job los van de terminal, zodat ze geen in- of uitvoer meer krijgt, en daarom ineens helemaal wordt gepauzeerd, zonder zijn resources vrij te geven. Eerste exit geeft boodschap dat er nog jobs zijn, 2de exit sluit ze af.

- zie ook sectie "Beheer jobs"

=== xfce terminal sneltoetsen ===
	. Ctrl+u	clears from cursor to beginning of line
	. Ctrl+k	clears from cursor to end of line
	. Esc+bspce	clears one word to the left of the cursor
	. Esc+d		clears one word to the right of the cursor
	. Ctrl+left/right jumps to the beginning of the previous/next word

To clear the entire screen add the following alias to your ~/.bashrc file:
	alias cls="echo -ne '\033c'"

=== numeriek toetsenbord gebruiken als muis ===

- is X-feature, zie https://en.wikipedia.org/wiki/Mouse_keys

- driver laden :
	$ setxkbmap -option keypad:pointerkeys
	- activeren/deactiveren : LeftCtrl + LeftShift + NumLock (standaard: R-Alt + L-Shift + NumLock)

- cursor besturen :
	7 8 9
	4   6
	1 2 3
- muisknoppen besturen
	/ * - : selecteer 'gewone', middelste of 'averechtse' (blijvend)
	5 + :  klik of dubbelklik
	0 . :  press of release

=== Xubuntu panel herstarten om veranderingen te laten zien ===
	$ xfce4-panel -r

=== Automatisch uitvoeren bij opstarten ===

- .desktop bestanden in o.a. ~/.config/autostart, /etc/xdg/autostart/ en /etc/xdg/xdg-xubuntu/autostart/
	- schakel autostart uit door "Hidden=true" in de betreffende .desktop te zetten

- die in ~/.config/autostart worden gemaakt/gewijzigd in "Settings/session and startup"

- zie ook "https://specifications.freedesktop.org/autostart-spec/autostart-spec-latest.html"

=== mimetype van bestanden ===

- /usr/share/mime : xml-bestanden in subdirs definiëren mimetypes, globbing patterns voor bestandsnamen, en omschrijvingen
	- wijzigingingen ENKEL IN /usr/share/mime/packages
		- in blok <mime-info>...</mime-info>
		- herkenning bestanden aan extensie :
			~~ <glob pattern="*.extensie"/> ~~
			- meerdere glob-tags toegestaan
		- herkenning bestanden aan magic bytes in bestand, vb. :
			~~ <magic priority="80">	<match value='Content-Type: text/x-zim-wiki' type="string" offset="0"/> </magic> ~~
		- van daar vertalen naar xml's in de rest van de directory tree :
			# update-mime-database /usr/share/mime
	- eigen mime types definiëren in "~/.local/share/mime/packages", die hebben voorrang
		- van daar vertalen naar xml's in de rest van de directory tree :
			$ update-mime-database ~/.local/share/mime
	- minstens sinds Ubuntu 12.04

- Er is ook, maar niet duidelijk wie dat nog gebruikt, /etc/mime.types : mimetype en evt. extensies die daarmee verbonden zijn
	- eigen mime types in "~/.mime.types" hebben voorrang

- zie ook sectie "mimetype default applications"

=== mimetype default applications ===

- zie ook sectie "xfce applications menu"

- Startmenu/Settings/Mimetype editor
	- spacefm "contextmenu/Open/Set as default" wijzigt dit ook
- in "~/.config/mimeapps.list"
- in de bestanden ./applications/default.lst en ./applications/mimeinfo.cache op het pad in de environment variabele XDG_DATA_DIRS, in die volgorde, b.v.:
	. $XDG_DATA_DIRS=/usr/share/xubuntu:/usr/share/xfce4:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop:/usr/share

- zie ook sectie "mimetype van bestanden"

=== Snel openen ===

- exo-open - Open URLs and launch preferred applications
	$ exo-open directory
	- opent directory in filemanager, ook b.v. "exo-open ." of "exo-open ~"
	$ exo-open mailto:user@server
	- opent mailto-url in e-mail programma
	$ exo-open mailto:user@server?attach=bestand
	- opent mailto-url in e-mail programma, met attachment
	$ exo-open http://url
	$ exo-open url
	- opent url in browser
	$ exo-open bestand
	- opent bestand in geassocieerd programma
- gelijkaardige programma's, maar bepalen hun geassocieerd programma op een andere manier:
	$ xdg-open (bestand | url | map)
	$ gvfs-open (bestand | url | map)
	$ gnome-open (bestand | url | map)

=== xfce applications menu ===

- Gemakkelijk menu-items toevoegen door .desktop bestanden te schrijven in ~/.local/share/applications. De 'Categories' bepalen in welk submenus het komt. Eigen submenu met Categories=X
	- ZIE https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-1.1.html
	- ZIE https://specifications.freedesktop.org/menu-spec/menu-spec-1.0.html#category-registry

- environment variable instellen in Exec= van een .desktop (à la bash 'var=waarde opdracht') lukt alleen door er de opdracht 'env' voor te zetten

- bestanden ~/.local/share/applications/userapp-%OMSCHRIJVING%-%HASH%Y.desktop worden automatisch aangemaakt, o.a. door Thunar's "openen met", en krijgen een lijntje bij in /home/dirk/.config/mimeapps.list
	- zie ook sectie "mimetype default applications"
	- voor "Send to, Mail Recipient" helaas een nieuwe, voor elk bestandstype en voor elke keer; Af en toe opkuisen

- spec in https://specifications.freedesktop.org/menu-spec/menu-spec-latest.html; menu's worden beheerd en gewijzigd met xdg-desktop-menu, een (command line tool for (un)installing desktop menu items). Blijken niet voorzien op de menus die Xubuntu per user bijhoudt in ~/.config/menus en ~/.local/share/applications.
	- Mogelijk moet daar voor Xfce een lijntje bij in (ZIE "https://wiki.archlinux.org/index.php/xdg-menu#Adding_desktop_entries_from_other_directories"; voor archlinux heet dat betreffende bestand /etc/xdg/menus/arch-applications.menu)
		- /etc/xdg/menus/xfce-applications.menu
		- /etc/xdg/xdg-xubuntu/menus/xfce-applications.menu

- de GUI-menu-editor van Xubuntu is menulibre, te vinden onder Setup/Menu Editor. Gebruik die heel zorgvuldig, of ge maakt er een zootje van.
	. documentatie op https://wiki.smdavis.us/menulibre-docs (is redelijk waardeloos)
	. hoofdmenu komt in xfce-hoofdmenu
		/home/dirk/.config/menus/xfce-applications.menu
	. menulibre submenus komen in bestanden
		/home/dirk/.local/share/desktop-directories/menulibre-%SUBMENU%.directory
		/home/dirk/.config/menus/applications-merged/user-menulibre-%SUBMENU%.menu
	. menulibre menuentries komen in bestanden /home/dirk/.local/share/applications/menulibre-%ENTRY%.desktop
	. .directory en .desktop bestanden mogen waar echt nodig met de hand beperkt wat gewijzigd worden, .menu enkel ZEER beperkt, daar kunt ge niks zinnigs mee doen dat ge niet beter in menulibre zelf doet.
		. zie https://developer.gnome.org/integration-guide/stable/desktop-files.html.en voor beschrijving van menu organisatie
		. zie https://developer.gnome.org/desktop-entry-spec/ voor beschrijving van .desktop snelkoppelingen en .directory.
	. submenu en entry aanmaken door, met het juiste hoofd/submenu geselecteerd, op de '+' bovenaan rechts van het applicatiemenu te klikken (dus niet de gnome-'+' van maximize). VOORAL NIET VERGETEN op het einde naast die '+' op het gnome-save ⍗ (pijltje naar beneden in een rechthoek) te klikken, MAAR EERST een naam opgeven voor het submenu/menuentry, of ge krijgt een nietszeggende bestandsnaam die ge achteraf niet terugvindt.
	. nieuwe icons als bestandsnaam opgeven, of vooraf van bestand installeren naar de iconfolders met
		. xdg-icon-resource install
	. volgorde van menuentries/submenus wijzigen met pijlen onder de lijst van alle menu-items
	
=== Xubuntu startmenu whisker ===

- De instellingen staan in /home/dirk/.config/xfce4/panel/whiskermenu-1.rc
- whisker neemt voor het overige het xfce applications menu over

=== Searchplugins Firefox wijzigen ===

- zijn xml-bestanden in ~/.mozilla/firefox/4kbxx5f4.default/searchplugins, maar worden gecached in ~/.mozilla/firefox/4kbxx5f4.default/search.json.mozlz4

OFWEL
- search plugin maken met de hand, met andere xml's als voorbeeld
OFWEL
- search plugin laten maken door b.v. Ready2Search http://ready.to/search/en/
	- resultaat niet installeren, maar eerst bewaren om op maat te maken (o.a. icon checken door het even in een html te plakken met <img src="data:...">)
- Firefox : schermafdrukje maken van volgorde searchplugins
- Firefox : alle vensters sluiten
- cache hernoemen (of ineens verwijderen) naar b.v. search.json.mozlz4~
- Firefox : terug opstarten, maakt search.json.mozlz4 terug aan vanuit bron-xml's
- Firefox : volgorde van search plugins terug instellen zoals voorheen

=== spacefm op maat maken ===

- persoonlijke configuratie wordt bewaard in verschillende generaties van ~/.config/spacefm/session; geregeld zelf backupje van maken tot mijn config wat stabiel is.
	- wschlk. een equivalent van Java's Properties (maar dan met secties zoals een .ini), met een parent met defaultinstellingen, en een

- van tijd geraken de kolom-breedtes overhoop, ik heb daarom een scriptje gemaakt :
	$ ~/bin/spacefmherstelconfig

- custom commandos hebben sleutel van de vorm cstm_########-xxxx=..., niet alles daarin is duidelijk, dus gewoon de custom actions van thunar (.config/Thunar/uca.xml) met de hand overbrengen naar spacefm.

- b.v. het "bulk rename" venster van thunar gebruiken :
	- rechtsklikken waar ge nieuw commando wilt in (popup) menu, bookmark, of taakbalkknop, of F2 met menu item highlighted
		- brengt u in 'design menu'
		- kies "New", "Command", een naam geven
		- Command : thunar --bulk-rename %F
		- Context : eerst onderaan voorwaarde (test) editen, dan pas add
			- multiple selected equals true
		- Menu item, icon : All icons, "menu-editor"
	  en klaar is kees. De rename-kracht van thunar, maar zonder de crashes van thunar die zijn bestandenlijst probeert te hersorteren terwijl de bestanden hun nieuwe namen krijgen.

- custom commands toevoegen/wijzigen met [Insert]/[F4]
	- toegevoegde commands zijn gebonden aan menu item waarop de insert gedaan wordt: als dat menu item niet getoond wordt, dan ook het nieuwe toegevoegde commando niet, ongeacht zijn eigen 'context'
	- de command editor toont de %xxx subsituties die gebruikt kunnen worden
		- zie file:///usr/share/doc/spacefm/spacefm-manual-en.html#designmode-props-command
	- daarnaast kunnen ook spacefms eigen shell variabelen $fm_xxx gebruikt worden
		- zie file:///usr/share/doc/spacefm/spacefm-manual-en.html#exvar
		- die WIJZIGEN HEEFT GEEN EFFECT op spacefm; ge kunt dus b.v. geen file selecteren door de list van selected files te wijzigen
	- spacefm's %x substituties verdragen geen quotes errond, enkel noch dubbel: spacefm wil dat zelf regelen. Maar de equivalente shell variabelen van spacefm kunnen wel tss. quotes, b.v. ... -e "tweak -l \"$fm_file\"" ...
	- de toestand van spacefm veranderen (b.v. tabs openen, bestanden selecteren) gaat via spacefm socket : "spacefm --socket-cmd set ..." of "spacefm -s set ..."
		- zie file:///usr/share/doc/spacefm/spacefm-manual-en.html#sockets-invoc-help
		- zie "spacefm -s help"

- zie ook _Xubuntu.adoc sectie "vuilnisbak toelaten"

=== fonts zoeken ===

- https://fonts.google.com/
	- heel goede selectiemogelijkheden (type, breedte, dikte, ...)
	- custom tekst in te stellen voor alle voorbeelden :
		>>> zowat alle letters die ik nodig heb:
			ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzáéíóúýàèìòùỳäëïöüÿâêîôûŷñçÇ ?!:;,.'"`‘’“”()[]{}/\&%*~^|#@<-+÷×=>0123456789®©$€£¥¢
		<<<

- https://www.fontsquirrel.com
	- heel populair

- zie ook http://hivelogic.com/articles/top-10-programming-fonts/

=== fonts installeren ===

- zie ook _Xubuntu.adoc sectie "ATM4 font collectie"

- persoonlijk : kopiëer naar ~/.local/share/fonts (deprecated: ~/.fonts)
	- heb geen ~/.local/share/fonts, dus voorlopig naar ~/.fonts

- voor iedereen : kopieer naar /usr/local/share/fonts

- systeemfonts staan in /usr/share/fonts, gegroepeerd in directories

- activeren zonder heropstart :
	$ sudo fc-cache -f -v
	- zonder sudo kan, voor eigen gebruiker alleen, maar dan wordt /var/cache/fontconfig niet opgekuist

- lijst van alle geinstalleerde fonts
	$ fc-list | grep DejaVu
	>>>
		...
		/usr/share/fonts/truetype/dejavu/DejaVuSans-BoldOblique.ttf: DejaVu Sans:style=Bold Oblique
	<<<
- font bekijken op lettertypenaam (zoals getoond door fc-list)
	$ xfd -fa "DejaVu Sans:style=Oblique"
		- of elk van de andere stijlnamen die fc-list toont
	$ xfd -fn "Abadi MT Condensed"
		- gebruikt gewoon andere functiecall dan -fa, maar nog niet gevonden hoe ge hierbij bold of italic of zo opgeeft

- font bekijken op bestandsnaam, ook niet-geinstalleerd (o.a. .pfb en .ttf)
	$ display /home/dirk/.fonts/truetype/ATM4/ABAC.TTF
		- is progr. van ImageMagick
	OF met eigen proggie, b.v. font gedownload naar /media/ramdisk
	$ java  -Dsun.java2d.debugfonts=true -Dsun.java2d.fontpath=append:/media/ramdisk -jar ~/Documents/java/UTIL/Font2DTest.jar

=== muisknoppen configureren ===

- zie "https://help.ubuntu.com/community/ManyButtonsMouseHowto"
- zie "https://help.ubuntu.com/community/MouseCustomizations"

- zoek de muis-id in
	$ xinput list
	- b.v. mijn Medion-muis is id=12

- achterhalen hoe de knoppen genummerd zijn, b.v. voor muis met id=12 :
	$ xinput test 12
	- elke muishandeling wordt nu getoond in terminal
	- b.v. knoppen Medion-muis (als linkshandig ingesteld) :
		1 : rechts
		2 : scrollwiel
		3 : links
		4 : scroll naar boven (geen release, alleen press, en ook neg. motion as 3)
		5 : scroll naar onder (geen release, alleen press, en ook neg. motion as 3)
		8 : zijknop links
		9 : zijknop rechts
		motion as 0 : naar links-rechts bewegen (altijd positief)
		motion as 1 : naar voren-achter bewegen (altijd positief)

- knoppen wisselel, b.v. :
	 $ xinput set-button-map 12 3 2 1 4 5 6 7 8 9 

== MOUNT  ==
ZIE OO: Filesystem Hierarchy Standard www.pathname.com/fhs/pub/fhs-2.3.html

- Een device zoals een schijf wordt voorgesteld door een bestand in /dev, b.v.:
	- /dev/sda voor HDD 0,
	- /dev/sda1 voor partitie 1 op HDD 0
	- /dev/nvme0n1 voor SSD 0
	- /dev/sr0 voor mijn DVD-lezer/schrijver
	- /dev/cdrom synoniem ('link') voor /dev/sr0
	- /dev/cdrw synoniem ('link') voor /dev/sr0
	- /dev/dvd synoniem ('link') voor /dev/sr0
	- /dev/dvdrw synoniem ('link') voor /dev/sr0

- Voor schijven is dat bestand een 'block device', te zien in b.v. detailweergave van filemanager Thunar, of met commando
	$ sudo lshw -c disk
Dat bestand kunnen we mounten of kopiëren ==>


=== unmount bij busy  ===
	- b.v. fusermount: failed to unmount /media/ramdisk/nw: Device or resource busy
	- zoek open bestanden:
		$ lsof | grep "relevant deel van pad mountpoint"
		- geeft o.a. processen en process id die een bestand op dat pad open hebben
	- met nodige voorzicht en doorzicht die processen beëindigen (eerst natuurlijk zoeken of er nog ergens een terminal of toepassing openstaat voor dat proces);
	- enkel bij gebrek aan beter : kill of terminate proces in "Task Manager", of "$ kill procesnummer"

- zo veilig mogelijk alles unmounten :	zie sectie "Magic Alt Sysrq"

=== veilig verwijderen ===

- verwijderbare schijven/usb-sticks eerst unmounten, dan buffers wegschrijven, dan verwijderen
	$ sudo umount
	$ sync
	- verwijderen

- Thunar's eject zou sync moeten doen

=== readonly mounten mounten ===

- voor de veiligheid is het al eens nodig om read-only te mounten :
	# mount -o ro ...
	OF
	# mount -r ...
	-r, --read-only : Mount the filesystem read-only. A synonym is -o ro.

- als het bestandssysteem niet in orde is, wil hij echter dat op orde brengen, en dan zegt mount -r :
	>>> mount: /mnt: cannot mount ... read-only <<<
	- OPLOSSING :
		$ mount -o ro,norecovery ...

=== lijst van mounts: ===

- volledigste overzicht eerst:
	$ findmnt
	OF
	$ mount [-l]
	-l : toont filesystem labels (mits leestoegang)
	OF
	$ cat /etc/mtab
	- waarschijnlijk zelfde als "mount"
	OF
	$ lsblk
	- alle block devices met evt. mountpoint, geen tmpfs, loop device, fuse mount, ...

- welke bestanden/devices (zoals eigenlijke inhoud van een cd in een cd-device zoals /dev/cdrom) zijn verbonden aan loop device :
	$ losetup -l

- root krijgt meer te zien

=== mount point van een bestand ===
	$ stat -c %m -- bestand
	-c : custom format

=== is iets gemount op directory? ===
	$ mountpoint directory
	>>>
		directory is [not] a mountpoint
	<<<

=== tablet mounten als usb-schijf ===

- tablet aansluiten met usb-kabel en opstarten (om het even welke volgorde), zou vanzelf een toep. moeten opstarten om usb als opslag in te schakelen. Anders in Ubuntu terminal emulator:
	$ lsblk
	- laat de block-devices zien, met in de huidige configuratie 2 extra's: sdc (extsd van tablet) en sdd (interne sd van tablet)
	$ sudo mount /dev/sdc /mnt
	- zou nu read-write op /mnt moeten staan, anders 'mount -o remount,w ...'
	$ pkexec thunar
	- vermits de tablet geen 'dirk' heeft, alleen root

=== mount fat of ander oud bestandssysteem  ===

- Dergelijke oude bestandssystemen hebben geen gebruikers-beveiliging, alleen algemene read en write toestemming. Daarom kan met b.v. mount en in fstab opgegeven worden welke gebruiker/groep toegang heeft tot de hele mount, b.v. uid=1000,gid=1000 (zie sectie lijst-opdrachten)

=== ramdisk maken ===

	$ sudo mount -t tmpfs -o size=10M,user,exec,mode=777 tmpfs /mnt
	-t tmpfs : het moderne ramdisk systeem (bezet o.a. alleen geheugen wanneer nodig)
		- vervangt ramfs
	-o mode=777 : Set initial permissions of the root directory.
	-o [nr_inodes=10k] : expliciet aantal inodes om speciaal veel kleine of weinig grote bestanden te maken
	- tmpfs : dummy devicenaam, mag om het even wat zijn. Door findmnt getoond als SOURCE, door "mount" als "tmpfs on"
	[-o remount,size=100M] : kan zonder probleem vergroot worden met behoud van data

=== archief mounten (zie ook: bestand als virtuele schijf voorbereiden en mounten) ===

- archivemount installeren (USC)
	- mount via fuse (Filesystem in User SpacE), dus zonder sudo
	- leest om te mounten de volgende typen :
		- zip, tar, (tar.)gz, (tar.)bz2, (?tar.)compress, ustar, pax interchange, cpio
		- sommige, lang niet alle ISO9660 CD images (with or without RockRidge extensions)
	- schrijft (pas bij unmount) de gewijzigde bestanden terug naar een archief (originele hernoemd naar *.*.orig)
		- tar, (tar.)gz, (tar.)bz2
		- (?tar.) compress
		- andere formaten (b.v. zip) gewoon naar tar
	- voorlopig veiliger alternatief voor schrijven: unionfs (zit bij Xenial) :
		- !!! geany en zim schrijven niet naar bestaande bestanden in archivemount mountpoint, enkel naar nieuwe, maar doen alsof, zonder te (laten) weten dat het misloopt. Bij geany kan dit opgelost worden door in Preferences/Various "use_gio_unsafe_file_saving" uit te vinken.
			- mijn bugmelding : mail 19.02.2018 naar Andreas Landwehr (auteur archivemount)
			- mijn bugmelding : https://github.com/geany/geany/issues/1774
			- het loopt wschlk. mis doordat zowel "use_gio_unsafe_file_saving" als "use_atomic_file_saving" eerst schrijven naar een tijdelijk bestand (en dat lukt, in ), en als dat lukt, dat dan verplaatsen (mv, d.w.z. linux-rename inclusief pad) naar originele pad/bestandsnaam :
			>>> https://wiki.geany.org/config/all_you_never_wanted_to_know_about_file_saving
				Does not work on all file systems since rename or rename over an existing file is not supported on all file systems
			<<<

- mountpoint moet directory met schrijftoegang zijn, b.v. in ~ of op ramdisk
	- heb /media/zipmnt gemaakt, writable voor dirk, als standaard mountpoint voor archieven
	- indien mountpoint niet leeg (b.v. map met het archief zelf, en niets anders dat ge nodig hebt), mounten met "-o nonempty" :
		- originele inhoud is niet meer zichtbaar en dus ontoegankelijk
		- progs die een bestand in die directory al open hebben en houden, zoals b.v. archivemount zelf, houden wel hun toegang (tot dat open bestand)
		- kunnen dus archief van een directory in die directory zetten, en op die directory mounten alsof er niets gebeurd is

- mounten:
	$ mkdir /media/ramdisk/test && archivemount -o readonly /archief.tar.xz /media/ramdisk/test/
	- mount is default schrijfbaar, dan oppassen met grote archieven
	- herschrijven pas na unmount
	-o readonly : niet schrijfbaar
	-o subtree=pad/in/archief : vanaf daar pas te mounten, is altijd read-only
	-o uid=1000 :

- unmounten (en aanmaken van gewijzigd archief) :
	$ fusermount -u /media/ramdisk/test
	- "Before writing, the original archive is renamed with a '.orig' extension appended to it."
	- unmounten kan ook met umount, maar dan met sudo
	- fusermount zoekt info over de te unmounten mount in /etc/mtab

=== bestand als virtuele schijf voorbereiden en mounten ===

- bestand voorbereiden
	- ruimte maken, ofwel ineens op zijn plaats, ofwel als sparse (schijfblocks worden pas toegewezen als er een niet-0 naar geschreven wordt)
		OFWEL als SPARSE bestand met truncate
		$ truncate -s 8G bestand
			- Shrink or extend the size of each FILE to the specified size
			-s, --size=SIZE : units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).
			[-c, --no-create] : do not create any files
			[-r, --reference=RFILE] : base size on RFILE
		OFWEL als SPARSE bestand
		$ dd if=/dev/zero of=bestand bs=1024 seek=8M count=0
			- bs=1024 :  blocksize, zowel ibs (input) als obs (output)
				- OPGELET : zowel count als seek zijn in aantal blocks
			- seek=N : skip N obs-sized blocks at start of output; dus zo groot is het bestand al (maar sparse) voor count begint : bs=1024 x 8M = 8G
			- count=0 : schrijf 0 blocks
			- check plaatsbeslag :
				$ ls -ls bestand
					- in kB
				$ du bestand
					- in kB
				$ du -B 1 bestand
					- in bytes
		OFWEL niet-sparse (maar dan "mkfs -E nodiscard" om dat zo te houden)
		[$ dd if=/dev/zero of=bestand bs=1G count=10]
			- size en count in 'b' blocks van 512 bytes, 'c' 1-byte (char), 'w' 2-byte (word) of in 1024^n (K, M, G, ...; enkel k mag kleine letter)
			- beter grote bs en kleine count dan omgekeerd (b.v. bs=1 count=12G duurt eeuwen), maar (zeker voor /dev/zero) <= 1G (2G is te groot)
			>>>  info '(coreutils) dd invocation'
				The numeric-valued strings above (N and BYTES) can be followed by a multiplier: ‘b’=512, ‘c’=1, ‘w’=2, ‘xM’=M, or any of the standard block size suffixes like ‘k’=1024 (*note Block size::). Any block size you specify via ‘bs=’, ‘ibs=’, ‘obs=’, ‘cbs=’ should not be too large—values larger than a few megabytes are generally wasteful or (as in the gigabyte..exabyte case) downright counterproductive or error-inducing.
			<<<
	- bestandssysteem in maken
		- OFWEL gepartitioneerd
			- b.v. om te converteren naar virtuele schijf voor virtualbox
			- parted kan partitietabel direct in het bestand maken :
				# parted --script --align optimal bestand -- mklabel gpt mkpart mijnpartlabel ext4 0% 100% unit B print
				--script : na -- komt een hele reeks opdrachten, anders interactief (of via stdin)
				-- hierna komen de script-ipdrachten, allemaal achter elkaar :
					- mklabel gpt :	maak gpt partitietabel
						alternatief : msdos e.a.
					- mkpart mijnpartlabel ext4 0% 100% :
						- mijnpartlabel :
							- met gpt-tabel : een partitielabel (=/= filesystem label)
							- met msdos-tabel : partitietype primary, logical of extended
						- ext4 : is maar een tag, moet nog "geformatteerd" worden (d.w.z. bestandssysteem maken)
							- alternatief : fat32, ...
						- 0% 100% : start en einde zonder risico om ons te misrekenen (parted is nogal een groffe opdracht, zou misschien voorbij bestandseinde kunnen schrijven)
							- alternatief : 4GB, -1s (in sectoren terugtellend van het einde, -1 is is exact laatste sector)
					- [name 1 mijnpartitielabel] : geef alsnog een partitielabel, nodig wanneer partitietabel =/= gpt, want dan hebben we partitietype nodig in mkpart-opdracht
						- 1 : partitienummer (telt vanaf 1)
					- [set 1 esp on] : zet flag om fat32 opstartpartitie voor EFI/ESP als dusdanig te markeren
						- 1 : partitienummer (telt vanaf 1)
					- [unit B] : gebruik 1 byte als eenheid voor volgende opdrachten
					- print : print de partitietabel
			- bestandssysteem maken :
				OFWEL direct in bestand, met offset zoals met de printopdracht van parted (zie hieronder "zonder partitietabel, direct in het bestand")
					- opgelet met eenheden offsets, hier is geen consistentie tss. programmas (1000^n =/= 1024^n, G, GB, GiB, ... en GB=/=GiB)
					- bestandssysteem mounten ook met offset
						# mount -o loop,offset=xxxxxxxx,...
				OFWEL via loopdevice, verbonden MET -P optie, en dan verder gewooon als voor device
					# losetup --show -Pf bestand
						>>> /dev/loop0 <<<
						-P, --partscan : Force the kernel to scan the partition table on a newly created loop device. Hiermee komt er ook /dev/loop#p# voor elke partitie in bestand :
							$ ls /dev/loop0*
							>>> /dev/loop0  /dev/loop0p1 <<<
						-f, --find bestand : Find the first unused loop device. If a file argument is present, use the found device as loop device. Otherwise, just print its [first unused] name.
						--show  : toon de naam van loop-device waaraan "bestand" verbonden is
					- controle :
						$ lsblk
						- met losetup zonder optie -P komen partities niet in lsblk
					# mkfs.ext4 -L mijnfslabel /dev/loop0p1
						- e.a. opties
					# mount [opties] /dev/loop0p1 /mnt
					# umount /mnt
					# losetup -d /dev/loop0
						- als mount zelf loop-device zoekt voor bestand en ermee verbindt, dan koppelt umount de 2 ook los; maar als we zelf bestand verbinden met loop-device, moeten we ook zelf loskoppelen
			- converteren naar VirtualBox vdi-bestand :
				$ vboxmanage convertfromraw bestand bestand.vdi --format vdi
		- OFWEL direct in het bestand
			- voor eigen gebruik, zonder partitietabel is het gemakkelijker te mounten
			- niet nodig om bestand aan /dev/loop# te binden met losetup: direct naar bestand gaat ook (geen vergissingen met /dev/loop nr.; mkfs naar device vraagt sudo, naar eigen bestand niet)
			$ mkfs.ext4 [opties] bestand
				- bereidt ext4 bestandssysteem voor
				- defaults: zie 'cat /etc/mke2fs.conf'
				- andere geïnstalleerde bestandsystemen : zie
					$ cat /proc/filesystems
					- ext2 om zonder verdere opties
						- journaling-overhead van ext3 en ext4 te vermijden
						-  kleinere (128byte) inodes te gebruiken
					- ext3 : geen bijzondere voordelen t.o.v. ext4 (zie http://www.golinuxhub.com/2014/03/what-is-difference-between-ext3-and.html)
					- ext4 is efficienter met grote bestanden :
						- Multiblock Allocator
						- 'extent' is range blocks dat aan bestand toegewezen is, i.p.v. zoals ext3 elk toegewezen block apart in een index bij te houden
				- maakt zonder opties niet-sparse bestand sparse
					[-E nodiscard] : Do not attempt to discard blocks at mkfs time (default is discard)
			- voorbeeld :
				$ mkfs.ext4 -I 128 -N 1048576 -m 0 -L label -O ^huge_file bestand
				>>>
					mke2fs 1.42.13 (17-May-2015)
					Discarding device blocks: done
					Creating filesystem with 2097151 4k blocks and 1048576 inodes
					Filesystem UUID: a0a5c864-9000-4a89-9446-9636e46e6392
					Superblock backups stored on blocks:
						32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632
					Allocating group tables: done
					Writing inode tables: done
					Creating journal (1024 blocks): done
					Writing superblocks and filesystem accounting information: done
				<<<
				[-E optie,optie,...] : extended opties, komma-gescheiden, zoals
					[-E ...,root_owner[=uid:gid]] : Specify the numeric user and group ID of the root directory. If no UID:GID is specified, use the user and  group ID of the user running mke2fs
						- best nakijken bij gebruik, desnoods mounten en na geslaagde mount chown op mountpoint doen, dat werkt zeker (enkel bij geslaagde, anders werkt chown op mountpoint zelf)
					[-E ...,nodiscard] : om virtueel schijfbestand NIET SPARSE te maken, discard is default
					[-E ...,offset=4294967296] : offset van 4GB vanaf start van device of bestand
						- OPGELET : in tegenstelling tot mount en losetup, aanvaardt mkfs.ext4 geen k,m,g of K,G,M suffix voor offset)
						- mke2fs maakt het bestandssysteem %filesize% groot vanaf offset
						>>> man mkfs.ext4
							If fs-size is omitted, mke2fs will create the file system based on the device size.
						<<<
							maar neemt hele huidige grootte van "bestand" in rekening; mkfs doet dan bestand met offset groeien, waardoor deze bug onschadelijk is
						- dienstig voor virtual machine administratie, of om b.v ruimte voor andere partitie of partitietabel o.i.d. te laten.
				[-I 128] : kleinst toegelaten inode-size (moet 2^n zijn), default 256
				-N 1048576 : aantal inodes (is ruwweg max. aantal bestanden en directories op filesysteem)
				[-m 0\ : percentage aantal blocken die gereserveerd moeten worden voor root en systeemutilities (zie ook "tune2fs -r 999" voor exact aantal gereserveerde blocks)
				[-L label] : volume label voor file system
				-O ^huge_file : geen (de '^') bestanden > 2TB
				[-O ^has_journal] geen journal
				[-J size=4] : journaalgroottte in MB (min. blocksize * 1024, typisch 32k blokken)
					- OPGELET : klein journal maakt filesystem zeer traag (zelfs met "mount -o data=writeback") met b.v. cryfs, dat veel metadata maakt omdat het data verspreidt over veel directories en bestanden
			- achteraf label geven :
				# tune2fs -L mijnlabel bestand
				- werkt niet met offset; misschien (read-only?) mounten en i.p.v. op bestand uitvoeren op juiste /dev/loop#

- mounten
	- NA MOUNTEN 1ste keer :
		- vuilbak voorbereiden
			- op FUSE bestandssystemen onderstaande gewoon als user uitvoeren, zelfs root heeft hier geen toegang toe, dus vuilbak voor alleen user zelf volstaat; t.b.v. sommige programmas ook als .Trash-1000 (link)
			$ mkdir /mnt/.Trash /mnt/.Trash/1000
			$ chmod +t /mnt/.Trash
			$ ln -sr /mnt/.Trash/1000 /mnt/.Trash-1000
	# mount -o optie,optie,... bestand /mnt
		- opties :
			exec : Permit execution of binaries under mountpoint
			noatime : geen accesstimes schrijven voor elke bestandstoegang, minder risico op verneuken
			ro : readonly
			norecovery of noload : Don't load the journal on mounting (en dus GEEN HERSTEL van evt. fouten)
			data={journal|ordered*|writeback} : metadata is always journaled, data als volgt :
				- journal : data to journal, then to file system
				- ordered : data directly to file system, then it's metadata to the journal
				- writeback : data may be written to filesystem after it's metadata committed to journal (rumoured as highest-throughput). Bewaart integriteit filesystem op zich, maar na crash + recovery uit journal kunnen de oude data nog in gecrasht bestand staan
			offset=4G : geeft offset door naar impliciete 'losetup'
			- suffix K,M,G of k,m,g voor 1024^n, suffix KB,MB,GB voor 1000^n
			loop : meestal impliciet, doet "losetup -f bestand" (find een /dev/loop#), en mount /dev/loop# op mnt
	# umount /mnt
		- doet impliciete "losetup -d /dev/loop#"

- sparse bestand kopiëren
	- werkt zowel voor sparse bronbestand, als voor niet-sparse bronbestand met 0-blocks
	OFWEL
	$ rsync -S bronbestand sparsebestand
		-S, --sparse : handle sparse files efficiently
		- kan ineens voor directories gebruikt worden :
			$ rsync -rS bronmap doelmap
			- OPGELET: bronmap zonder eind-'/'
	OFWEL
	$ dd conv=sparse if=bronbestand of=sparsebestand
		- zou snelste zijn op locale machine
		- enkel bestand per bestand
		- OPGELET: met expliciete blocksize bekijkt "dd" het sparse-zijn per die blocksize, niet per block van het bestandssysteem
	OFWEL
	$ cp --sparse=always bronbestand sparsebestand
		- OPGELET: zou niet altijd de juiste blocksize gebruiken voor het doel-bestandssysteem, en bekijkt dan zoals "dd" het sparse-zijn per die blocksize, niet per block van het bestandssysteem

- bestanden verwijderen voor sparse virtuele schijf
	- OPGELET : shred is nutteloos op ext3 of ext4 met data=journal mode (is gelukkig niet de default)
	- Fast shredding by overwriting everything with 0s in a single iteration
		$ shred -zn 0 --remove=wipe bestand
		--remove[=HOW] : truncate and remove file after overwriting
			=unlink : standard unlink call
			=wipe : also first  obfuscate bytes in the name.
			=wipesync : (default) wipe, and also sync each obfuscated byte to disk; can be expensive.
		-z, --zero : add a final overwrite with zeros to hide shredding
		-n, --iterations=N : overwrite N times with random values instead of the default (3)
	- Secure shredding using 3 iterations with random numbers and a last one writing 0-s
		$ shred -z -u  bestand

- ongebruikte ruimte vrij maken (kopiëren als sparse)
	OFWEL
	0 ongebruikte bytes op 0 zetten :
		- filsys MOET GEMOUNT, op b.v. /mnt
		[# mount bestand /mnt]
		$ dd if=/dev/zero of=/mnt/nullen
		- disadvantage of dd in this context is that it destroys any sparseness that exists: free blocks that were originally represented as holes in the image file are replaced with actual blocks containing zeroes (NIET in VBox, die 0-blocks in virtuele schijf effectief NIET naar fysieke schijf schrijft)
		$ sync /mnt/nullen
		- sync zorgt dat de geschreven nullen effectief op de schijf gezet worden, vooraleer we met de volgende opdracht (rm) zeggen dat dit niet meer nodig is
		$ rm /mnt/nullen
	OFWEL
	- alleen ongebruikte blocks die niet-0 bevatten, op 0 zetten :
		- filesys NIET of RO gemount, moet wel aan /dev/loop# hangen (b.v. door dus RO te mounten)
			OFWEL
			# losetup -f --show bestand
				>>> /dev/loop#
				- b.v. /dev/loop0
				-f, --find : Find the first unused loop device. If a file argument is present, use the found device as loop device. Otherwise, just print its name.
				--show : Display the name of the assigned loop device if the -f option and a file argument are present
				[-o, --offset offset] : 999K,M,G, ... offset bestandssysteem vanaf begin bestand, in 1024^n (KB,MB, ... voor 1000^n), t.b.v. b.v. partitietabel, andere partities, en VM-beheer
			OFWEL (WERKT NIET voor zerofree)
			# mount -o ro bestand /mnt
			- check aan welk loopdevice bestand verbonden is :
			$ losetup -l
			- maak ongebruikte blokken 0
		- voor de zekerheid bestandssysteem controleren, voor en na
			OFWEL voor ext2, ext3, ext4
			# e2fsck -nfC 0 /dev/loop#
				-f : force checking even if clean
				-n : Open the filesystem read-only, and assume an answer of `no' to all questions
				-C fd : If the file descriptor specified is 0, e2fsck will print a completion bar as it goes about its business.
			OFWEL voor alle ondersteunde bestandssystemen, op loop-device
			- OPM: options to filesystem-specific fsck's are not standardized; the following options are supported by most filesystem checkers:
			# fsck -nC /dev/loop#
				-n : (for some filesystem-specific checkers only) avoid attempting to repair any problems, but simply report such problems to stdout
				-C [fd] : Display completion/progress bars; neemt optioneel file descriptor argument, moet dus laatste optie in een "-opq..." optiestring zijn
				[-r [fd]] : Report certain statistics for fsck when it completes; opgelet, dubbelt met fs-specifieke optie -r : interactive
				- doel-argument fsck kan device name, mount point, ext2 label of UUID specifier zijn
			OFWEL voor alle ondersteunde bestandssystemen, op mountpoint
			- werkt niet met offset in b.v virtual disk van een VM, of partitie in een meer-partitie virtual disk
			# fsck -nC /mnt
		- ongebruikte blokken met 0 overschrijven als ze nog niet 0 zijn
			# zerofree /dev/loop#
			- finds  the unallocated, blocks with non-zero value content in an ext2, ext3 or ext4 filesystem (e.g. /dev/hda1) and fills  them  with zeroes (or another octet of your choice).
			[-n] : Perform a dry run  (do not modify the file-system)
			[-v] : verbose; show the number of blocks (-n : that would be) modified by zerofree, the number of free blocks and the total number of blocks on the filesystem
		- nog eens controleren
			# fsck -rC /dev/loop#
	- filesys loskoppelem van /dev/loop#
		OFWEL (naargelang de hierboven gebruikte methode)
		# losetup -d /dev/loop#
		OFWEL
		# umount /mnt
	- sparse maken of blocks met enkel 0 dealloceren (op NIET GEMOUNT fs)
		OFWEL inline
		$ fallocate -vd bestand
			-d, --dig-holes : Detect and dig holes. Makes sparse in-place. Minimum size of hole depends on fs block size.
			[-v, --verbose] : Enable verbose mode
			- al tegengekomen dat fallocate rapporteert dat gaten gemaakt zijn, zonder dat disk usage verandert.
			- Supported for  XFS, ext4, Btrfs and tmpfs
		OFWEL dupliceren naar nieuw, sparse, bestand
		$ cp --sparse=always bestand bestandNEW
			- op kopie
			--sparse=always : create a sparse DEST file whenever the SOURCE file contains a long enough sequence of zero bytes
			[-sparse=auto] : (is default, maar auto-detectie kan sparse missen) sparse SOURCE files are detected by a crude heuristic and the corresponding DEST file is then made sparse as well

- tussen het bestand en de /dev/loop? (of tussen de /dev/loop? en de mount??) kunnen nog filters gezet worden, b.v. compressie

=== Virtualbox Virtual Drive mounten in Linux ===

- ZIE _VirtualBox.adoc

=== UEFI-bootable usb-stick maken van UEFI-bootable iso (live cd) ===
	- met b.v. gparted USB-stick formatteren in FAT32, flags eps en boot
	# mount cd.iso /cdrom
	# mount /dev/s%USBSTICK% /mnt
	# cd /cdrom
	# rsync -aAXxiv . /mnt/

== CD-DVD ==

=== toegang krijgen tot de bestanden van een cd of dvd, via de standaardmap /cdrom of een andere map (die moet bestaan) ===
	. nu geconfigureerd om cds en dvds automatisch te mounten naar een automatisch aangemaakte map in /media/dirk
kort	$ sudo mount /dev/sr0 /cdrom
voll.	$ sudo mount -o loop,ro /dev/sr0 /cdrom
	- optie "ro" om read-only te mounten; wordt zonder "ro" ook read-only gemount, maar met waarschuwing
	- optie "loop" is kort voor "loop=/dev/loop0", waarbij 0 automatisch gekozen wordt uit de vrije /dev/loop*-devices: de image-file wordt geassocieerd met het device dev/loop0, en dat device wordt dan gemount; mount blijkt ook te werken zonder de optie loop

=== image mounten naar b.v. de gebruikelijke map /cdrom in het file system ===

- kort
	$ sudo mount bronpad/cdimage.iso /cdrom
- volledig
	$ sudo mount -o loop,ro ...

=== image maken van (bootable of niet) cd of dvd ===

- moet misschien gemount zijn, maar ik denk het niet

	$ dd if=/dev/sr0 of=doelpad/cdimage.iso bs=2K
	- de blocksize bs=2K of bs=2048 is waarschijnlijk niet nodig, maar komt overeen met de data-inhoud van 1 mode-1-cd-sector, zal dus sneller gaan; mode-2 cds hebben 2336 bytes per sector
	- if=/dev/cdrom e.a. synoniemen werkt ook

=== algemene image of dvd-video image maken van directory ===

	$ genisoimage -V LABEL -J -r -iso-level 3 -o output_image.iso bronpad [bronmap2]...
		-V : max. 32 chars
		-J : Generate Joliet directory records in addition to regular ISO9660 filenames.
		-r : Rockridge extensions, sterk aanbevolen voor Joliet
			- is ook nodig om meer dan 6 directories diep te gaan
		- bronpad# : inhoud van elk komt in de root van de iso
		-iso-level 3 : Set the ISO9660 conformance level. Valid numbers are 1 to 4.
			- With level 1, files may only consist of one section and filenames are restricted to 8.3 characters.
			- With level 2, files may only consist of one section.
			- With level 3, no restrictions (other than ISO-9660:1988) do apply.
			- With  all ISO9660 levels from 1 to 3, all filenames are restricted to uppercase letters, numbers and underscores. Filenames are limited to 31 characters, directory nesting is limited to 8 levels, and pathnames are limited to 255 characters.
			- Level 4 : not official, genisoimage maps it to ISO-9660:1999, which is ISO9660 version 2. An enhanced volume descriptor with version number and file structure version number set to 2 is emitted. Directory nesting is not limited to 8 levels, there is no need for a file to contain a dot and the dot has no special meaning, filenames do not have version numbers, and filenames can be up to 207 characters long, or 197 characters if Rock Ridge is used.
	- GANGBARE OPTIES :
		-f : Follow symbolic links when generating the filesystem. When this option is not in use, symbolic links will be entered using Rock Ridge if enabled, otherwise they will be ignored.
		-m shell-wildcard-pattern : exclude files volgens pattern
		- tussen "", voorkomt shell globbing
		- met wildcard : toegepast op volledig bronpad
		- zonder wild card : toegepast op naam van file of directory
		- mag herhaald, b.v. -m "*.bak" m "/mnt/overbodig*"
		-no-bak : Exclude  backup files files on the ISO9660 filesystem; that is, filenames that contain the characters `~' or `#' or end in .bak. These are typically backup files for Unix text editors.
		-dvd-video : Generate a DVD-Video compliant UDF filesystem. This is done by sorting the order of the content of the appropriate files and by adding padding between the files if needed. Note that the sorting only works if the DVD-Video filenames include uppercase characters only. Note that in order to get a DVD-Video compliant filesystem image, you need to prepare a DVD-Video compliant directory tree. This requires a directory VIDEO_TS (all caps) in the root directory of the resulting DVD, and usually another directory AUDIO_TS. VIDEO_TS needs to include all needed files (filenames must be all caps) for a compliant DVD-Video filesystem.

=== (X)Ubuntu Live CD uitpakken naar schijf of usb-stick ===

- OPGELET: /dev/sd## vervangen door JUISTE devicenaam van de met gparted als FAT32-geformateerde en als boot,esp ge-flagde usb-stick (b.v. /dev/sdc) of (NOG NIET GEPROBEERD) de devicenaam van de 1ste FAT32-partitie van een schijf (b.v. /dev/sdb1):
	0$ sudo dd if=/path-to-xubuntu-live-cd.iso of=/dev/sd## bs=4M; sync
	- OPM: mijn methode werkt ook:
	. Xubuntu Live CD ISO gemount naar /mnt
	. /mnt gekopieerd naar 1ste (FAT32) partitie van interne schijf of USB schijf/stick. Die was vanuit XUbuntu met gparted-flags gemerkt als boot,esp (EFI system partition), wat misschien nodig is om hem in UEFI boot override te krijgen, maar dat heb ik niet getest.
		$ cd /mnt
		$ rsync -a . /media/doelschijf
			- OPM: duurt een tijdje, want casper/filesystem.squashfs is 1GB groot
			- OPM: FAT32 ondersteunt geen symbolic links, dus daar komen een paar foutmeldingen over:
				rsync: symlink "/media/dirk/2GB/ubuntu" -> "." failed: Operation not permitted (1)
				rsync: symlink "/media/dirk/2GB/dists/stable" -> "xenial" failed: Operation not permitted (1)
				rsync: symlink "/media/dirk/2GB/dists/unstable" -> "xenial" failed: Operation not permitted (1)
	. terminal geopend op de kopie, en gecheckt met
		$ cd /media/doelschijf
		$ md5sum -c md5sum.txt
			OPM: geeft lange lijst met OKs, en als laatste lijn nog een WARNING als er een fout tussen zat, dus ge moet niet die hele lijst overlopen

== LIJST-OPDRACHTEN ==

- wildcard voor shell globbing NOOIT beginnen met * (want dan wordt bestand dat met - begint, b.v. "-R", als optie beschouwd, dikwijls "recursive") :
	./* : veel beter

- In all shells, globs are sorted by default

=== opdrachten ===
	$ info

=== mappen en bestanden ===
	$ ls
	- detail: -l
	- ook verborgen: -a
	- submappen: wildcard **

=== mappen en bestanden in volgorde van tijd ===
	$ find -printf "%TY-%Tm-%Td %TT %p\n" | sort -n

=== mounts ===
	OFWEL
	$ findmnt
	OFWEL
	$ mount

=== ruimtegebruik en vrije ruimte op gemounte bestandssystemen ===
	$ df -k [file]
	- "disk free" : report file system disk space usage
	[file] report file system disk space usage for file systems containing file arguments
	-k : == -BK
	-Bx : blocksize, x=K, M, G, T kilo, mega, ... (2^n), x=KB, MB, ... (10^3n)
	-h : variable blocksize 2^n
	-H : variable blocksize 10^3n

=== block devices ===
	$ lsblk

=== uuid van block devices en partities ===
	# blkid

=== hardware ===
	# lshw
	- alleen van class disk: -c disk (andere classes o.a. bridge, bus, communication, disk, display, generic, input, memory, multimedia, network, power, processor, storage, system, volume, alle vinden met -short)

=== pci-bus en devices (o.a. voor VirtualBox PCI passthrough) ===
	$ lspci

=== logins ===
	$ lslogins
		  UID USER              PROC PWD-LOCK PWD-DENY  LAST-LOGIN GECOS
			0 root               177                   nov21/15:45 root
			1 daemon               0                               daemon
			2 bin                  0                               bin
			3 sys                  0                               sys
		...
		  120 guest-tHmpt3         0                               Guest,,,
		  121 _apt                 0
		 1000 dirk                66                      09:02:10 Dirk,,,
		65534 nobody               1                               nobody

=== gebruikers en groepen ===
	$ users
	- print the user names of users currently logged in to the current host
	$ groups [username]
	- print the groups a user is in

=== gedefinieerde aliassen ===
	$ alias

=== open bestanden ===
	$ lsof | grep gezochtbestand

=== programma's in uitvoering ===

- enkel op programmanaam
	- OPGELET: voor scripts die uitgevoerd worden als 'bash script ...' is de programmanaam 'bash'
	$ pgrep -a "pattern"
	- pattern : regexp
	[-a, --list-full] : List the full command line and process ID (anders alleen process ID)
	[-l, --list-name] : List the process name as well as the process ID.
	[-x, --exact] : Only match processes whose names (or command line if -f is specified) exactly match the pattern. (zoals "^pattern$")
	[-U, --uid uid,...] : Only match processes whose real user ID matches (numerical or symbolical value)
	[-c, --count] : Suppress normal output; instead print a count of matching processes. When count does not match anything, e.g. returns zero, the command will return non-zero value.

- op hele opdracht (nuttig voor o.a. "bash script ...")
	$ pgrep -fa ".*naarh264.*"
	>>>5845 bash /media/ramdisk/naarh264.sh ./viv.15.12.02.mango.a.and.talia.mint.auspice.mp4
	-f, --full : The pattern is matched against the full command line

=== file attributes (nog iets anders dan chmod access mode) ===
	$ lsattr
	append only (a), no atime updates (A), compressed (c), no copy on write (C), no dump (d), synchronous directory updates (D), extent format (e), compression error (E), huge file (h), immutable (i), indexed directory (I), data journalling (j), inline data (N), secure deletion (s), synchronous updates (S), no tail-merging (t), top of directory hierarchy (T), undeletable (u), compression raw access (X), compressed dirty file (Z).

=== andere ls-opdrachten ===
- lsb_release, lscpu, lsipc, lspcmcia, lsusb, lsdiff, lsinitramfs, lslocks, lsmod, lspgpot

=== list all installed packages ===
	$ apt list --installed

=== list filesystems supported by currently running Linux kernel ===
	$ cat /proc/filesystems
	>>> 2018/03/10
		nodev	sysfs
		nodev	rootfs
		nodev	ramfs
		nodev	bdev
		nodev	proc
		nodev	cpuset
		nodev	cgroup
		nodev	tmpfs
		nodev	devtmpfs
		nodev	debugfs
		nodev	tracefs
		nodev	securityfs
		nodev	sockfs
		nodev	bpf
		nodev	pipefs
		nodev	devpts
				ext3
				ext2
				ext4
				squashfs
		nodev	hugetlbfs
				vfat
		nodev	ecryptfs
				fuseblk
		nodev	fuse
		nodev	fusectl
		nodev	pstore
		nodev	efivarfs
		nodev	mqueue
		nodev	autofs
		nodev	binfmt_misc
	<<<
	- bevat niet (noodzakelijk) geinstalleerde fuse bestandssystemen

=== list all executable files installed by given package ===
	$ dpkg-query -L packagename | xargs file | grep executable
  If you want to only see executables installed in /usr/bin, use:
	$ dpkg-query -L packagename | xargs file | grep ^/usr/bin | grep executable

=== zoek bestanden en directories ===

- zie ook sectie "opdracht uitvoeren op alle bestanden van een directory tree"

	OFWEL
	$ find [bronpad] [selectie]...
	[bronpad] : default ".", is letterlijke prefix van elke bestandsnaam in resultaat
	[selectie] :
		-type x : f=bestanden, l=symlinks, d=directories
		-[i]name "*pattern*" : pattern IN QUOTES, anders shell globbing t.o.v. current working directory
			[i] : case insensitive
		-[i]path "*pattern*"
		-[i]lname  "*pattern*" : bestand is symbolic link, met doel volgens pattern
		-regextype posix-extended : default is gnu-emacs, geen zin om die ook te leren
		-[i]regex "pattern" : wordt toegepast op heel pad, en moet helemaal matchen, dus meestal beginnen met ".*" (niettegenstaande een opmerking in "info find" dat '^' en '$' begin- en einde van een string aanduiden)
			- vb. reeks extensies matchen :
				-regextype posix-extended -iregex ".*\.(par[^\./]*|md5|sfv|ffp|sha[^./]*)"
		-maxdepth 2 : max. 2 niveaus onder brondirectory
		[-mount] of [-xdev] : niet over mount grenzen
		-executable
		-size [+,-]235[bckMG] : b: blocks van 512 (default), c: bytes, kMG : kilo,Mega,Gigabytes
		...
	OFWEL (vanuit root of elders waar ge niet in alle directories kunt)
	$ find / ! -readable -prune -o [selectie]... -print
	-readable -prune : als het bestand of de directory niet leesbaar is: niet in afdalen, zodat ge geen lange lijst foutboodschappen 'permission denied' krijgt
	-o : OR, gevolgd door de eigenlijke selectie
	-print : omdat we voor 1ste lid van de OR expliciet -prune doen, moeten we voor het 2de lid ook expliciet zeggen wat er moet gebeuren

- negatieve zoek : zie sectie "opdracht uitvoeren op alle bestanden van een directory tree" subsectie "vb. 11 bestanden zoeken met uitsluiting van bepaalde suffixen"

=== tel aantal bestanden dat aan criteria voldoet, b.v. aantal .cue-bestanden ===
	 $ find -iname '*.cue' | wc -l
	 - wc -l : 'word count' aantal lijnen

=== verbroken links vinden ===
	$ find . -xtype l
	- xtype volgt links als ze bestaan, en test dan het type van het resultaat (file, directory, socket, link, ...); als een link (evt. in een reeks) verbroken is, is het ultieme xtype die verbroken link zelf

=== recent geopende bestanden (over alle progs) ===
	/home/dirk/.local/share/recently-used.xbel

=== dubbele bestanden ===
	$ fdupes -ro path [pad1]...
	-r : recursive
	-o path : binnen duplicate-groep sorteren op volledig pad

== ENVIRONMENT VARIABELEN ==

=== laatste exit code ===

	$ echo $?

=== process id van script ===

- De expansie van "$$" is de process id van het script in uitvoering (of shell bij sourcen van script vanuit shell) :
	$ $$
	>>> 2624 <<<
		- In a () subshell, $$ expands to the process ID of the current shell, not the subshell.

- De speciale variabele ! (gebruiken als "$!") geeft de process id van het meest recente process dat in de achtergrond werd geplaatst, door af te sluiten met een '&' (asynchronous command) dan wel door de bash opdracht "bg" 

=== lijst van bash set opties ===

- met de opties van de built-in bash opdracht "set" stelt ge interne bash attributes in (!= de shell options van shopt), b.v.
	$ set -C
	-C, -o noclobber : geef fout als redirect ">" een bestaand bestand zou overschrijven
	$ set +C
	+C : zet die optie terug uit

- de expansie van "$-" is een lijst met de ingestelde (short) option letters van set

=== shellfunctie tonen ===
	$ type mijnfunctie

=== op naam ===
	$ echo $NAAM

=== op (deel van) naam ===
	$ printenv | grep NAAMDEEL

=== allemaal ===
 	$ set
	- an internal bash command, so it shows all the "shell variables" (unexported environment variables) as well as the exported environment variables.
	$ printenv
	- an external command, so it only knows about (and prints) exported environment variables.
	$ env
	- an external command to run a program in a modified environment (bash can do this without env); also, when no argument given, displays variables like printenv does

=== environment available to any GUI application ===

- in Gnome Shell:
	. press Alt-F2 (application finder)
	. 'xterm -e bash --noprofile --norc'
		to open a terminal with a shell that did not add any environment variables; it only has the environment variables added by the system files, that are available (by inheritance) to all programs in the system.
	$ printenv
	- in that terminal to list all your environment variables

=== environment permanent instellen ===

- zie https://help.ubuntu.com/community/EnvironmentVariables
	- environment variable settings that affect the system as a whole (rather than just a particular user) is /etc/environment. An alternative is to create a file for the purpose in the /etc/profile.d directory.
	- ~/.profile is run after ~/.pam_environment has been read
	- ~/.pam_environment
		(not a script, but list of assignment expressions, one per line. Some variables, like HOME, might not be set at the time ~/.pam_environment is parsed)
	- ~/.profile
		(script, gets executed automatically by the DisplayManager during the start-up process desktop session as well as by the login shell when one logs in from the textual console)
	- OPM: als ik het goed begrijp, roept .profile als BASH wordt uitgevoerd ook .bashrc aan, dat zelf dan weer (en dat is zeker) ~/.bash_aliases uitvoert

=== test of veranderlijke alleen witruimte is ===

- gemakkelijkst door te testen op de echo ervan met standaard IFS " \t\n" :
	$ if [ -z "$(echo $var)" ] ; then echo var is blanco; else echo -${var}- bevat tekens; fi
	- "$(echo $var)" is "" als var alleen IFS-chars " \t\n" bevat

=== prompts en xterm commandos ===

- zie ook https://www.davidpashley.com/articles/bash-prompts/

- bash kent 4 prompts :
	- PS0 : wordt getoond nadat commando gelezen is en voor het wordt uitgevoerd
	- PS1 : prompt wanneer de shell wacht op nieuw commando
	- PS2 : prompt wanneer de shell wacht op vervolglijn van nieuw commando
	- PS3 : prompt voor interne select-opdracht
	- PS4 : prompt tijdens execution trace van script tonen

- prompts kunnen terminal-escapecodes gebruiken (terminal Xubuntu Xenial : xterm, Bionic : $TERM = xterm-256color)
	- 1-teken-escapes : zie man bash sectie "PROMPTING"
	- \[ : Begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt 		
	- \] : End a sequence of non-printing characters 		
		- markeer escapes als non-printing characters door ze tussen \[ en \] (in script \\[ en \\])  te zetten, zodat terminal line editor niet in de war geraakt voor positionering:
			>>> \[...\] tells bash to ignore the non-printing control characters when calculating the width of the prompt. Otherwise line editing commands get confused while placing the cursor. <<<
	- tekstkleur en -decoratie :
		- \e[...m : begin of wijziging, met ... een ';'-gescheiden lijst van 2-cijferige codes
		- zie ~/.dircolors voor de codes
		- \e[m : einde
	- set title patterns :
		- \e]0;titel\a : icon and window
		- \e]1;titel\a : icon
		- \e]2;titel\a : window

== INFORMATIE ZOEKEN ==

=== uid en gid van een gebruiker ===
- van huidige of genoemde gebruiker :
	$ id -u [gebruikersnaam]
	>>> 1000 <<<
		-u : alleen user id
	$ id [gebruikersnaam]
	>>> uid=1000(dirk) gid=1000(dirk) groups=1000(dirk),4(adm),24(cdrom),27(sudo),29(audio),30(dip),44(video),46(plugdev),113(lpadmin),120(scanner),128(sambashare),130(vboxusers),132(xpra) <<<
	- standaard/1ste gebruiker is meestal uid=1000,gid=1000 (o.a. in Ubuntu)

	$ id root
	>>> uid=0(root) gid=0(root) groups=0(root)
	- root is meestal uid=0,gid=0 (o.a. in Ubuntu en systemrescuecd), maar 0 is niet noodzakelijk root

=== zoek bestand ===
	- op naam (eigen shellscript, hoofdtekens-ongevoelig)
		$ zoek deelvannaam
	- zoek tekst in bestanden met een bepaalde extensie (eigen shellscript, hoofdtekens-ongevoelig)
		$ zoekin extensie zoektermen of regex
	- show location of file :
		$ whereis filename
	- show location of file if it is in your PATH :
		$ which filename

=== welke opdracht ===
	- type [-aftpP] name [name ...] : With no options, indicate how each name would be interpreted if used as a command name
	$ type schijven
	>>> schijven is aliased to `lsblk -o NAME,LABEL,PARTLABEL,RM,SIZE,RO,TYPE,FSTYPE,MODEL,MOUNTPOINT' <<<
	$ type beeldpc
	>>> beeldpc is /home/dirk/bin/beeldpc <<<

=== technische gevens van een bestand ===
	$ stat bestand
	- b.v. mount point van een bestand :
	$ stat -c %m -- bestand
	-- : einde opties (voor het geval naam bestand met - begint)
	-c %m : custom format, gevolgd door newline. O.a.
		%m : mount point
		%n : file name
		%N : 'file name' (dereferenced if symbolic link)
		%s : size in bytes
		%i : inode number
	--printf %m : custom format zoals -c, maar met escapes (\n, \t, ...) in formaat. ZELF \n voor newline opgeven

=== huidige kernel ===

	$ uname -r
	>>> 4.4.0-98-generic <<<
	-r, --kernel-release
	-n, --nodename : print the network node hostname

=== geinstalleerde versie Ubuntu ===

- zie ook sectie "ONDERHOUD" - "release bijwerken"

- opm : /proc/version en /proc/version_info gaan over de kernel, niet over de distri, alhoewel er bij Ubuntu wel "Ubuntu" in staat.

- huidige versie :
	- LSB standaard (Linux Standard Base)
		$ lsb_release -a
		>>>
			Distributor ID:	Ubuntu
			Description:	Ubuntu 16.04.1 LTS
			Release:	16.04
			Codename:	xenial
		<<<
		-i, --id : Display the string id of the distributor.
		-d, --description : Display the single line text description of the distribution.
		-r, --release : Display the release number of the distribution.
		-c, --codename : Display the codename according to the distribution release.
		-a, --all : Display all of the above information.
		[-s, --short] : machineleesbaar, b.v. :
			$ lsb_release -sc
			>>> xenial <<<
	- Free Desktop standaard
		$  cat /etc/os-release
		- in NAME=VALUE formaat, zodat ge van daaruit gemakkelijk environment variabelen kunt instellen
		>>>
			NAME="Ubuntu"
			VERSION="18.04.1 LTS (Bionic Beaver)"
			ID=ubuntu
			ID_LIKE=debian
			PRETTY_NAME="Ubuntu 18.04.1 LTS"
			VERSION_ID="18.04"
			HOME_URL="https://www.ubuntu.com/"
			SUPPORT_URL="https://help.ubuntu.com/"
			BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
			PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
			VERSION_CODENAME=bionic
			UBUNTU_CODENAME=bionic
		<<<
		- fallback : /usr/lib/os-release

- originele install :
	$  cat /var/log/installer/media-info
	>>> Xubuntu 15.10 "Wily Werewolf" - Release amd64 (20151021)d
	- werkt natuurlijk alleen als logs bijgehouden zijn

=== welke binary voert een opdracht uit ===

- which zoekt het pad af naar een executable, zoals de shell zelf dat zou doen om die uit te voeren :
	$ which vlc
	>>> /user/bin/qvlc <<<

=== welk package installeerde dit bestand ===

	$ dpkg -S $(which qvlc)
	>>> vlc-plugin-qt:amd64: /usr/bin/qvlc <<<

=== welke libraries zijn nodig voor executable ===

- welke libraries worden dynamisch geladen door programma (cfr. windows dll)
	$ objdump -p $(which ffmpeg) | grep NEEDED
	OF (recursief)
	$ ldd $(which ffmpeg)

- b.v. gebruikt evince gtk of Qt :
	$ ldd $(which evince) | grep -i 'gtk\|qt'

===  welke (versie van) een library is geïnstalleerd ===

- b.v. gtk en python :
	OFWEL
	$ ldconfig -p | grep -e python -e libgtk
	- voor 1 library is de -e niet nodig
	OFWEL
	$ whereis libjpeg

=== van welke andere packages hangt een package af ===

	$ apt-cache depends vlc-plugin-qt:amd64
	>>>
	vlc-plugin-qt
	  Depends: libc6
	  Depends: libgcc1
	  Depends: libqt5core5a
	  Depends: libqt5gui5
	  Depends: libqt5svg5
	  Depends: libqt5widgets5
	  Depends: libqt5x11extras5
	  Depends: libstdc++6
	  Depends: libvlccore9
	  Depends: libwayland-client0
	  Depends: libx11-6
	  Depends: <vlc-plugin-abi-3-0-0f>
		libvlccore9
	  Breaks: vlc
	  Recommends: vlc-bin
	  Replaces: vlc
	<<<

=== welke andere packages hangen van deze package af ===

	$ apt-cache rdepends libqt5webkit5
	- lijst wordt samengesteld uit de package database; moeten niet geinstalleerd zijn, maar gewoon beschikbaar in de geconfigureerde resources (zie sectie "lijst van alle definieerde repositories (ppa)"

=== versie van een package ===

- moet niet geinstalleerd zijn, maar gewoon beschikbaar in de geconfigureerde resources (zie sectie "lijst van alle definieerde repositories (ppa)"

- met wildcards als ge de naam maar ongeveer kent
	$ dpkg-query -l e2fs*
	>>>
		Desired=Unknown/Install/Remove/Purge/Hold
		| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
		|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
		||/ Name                        Version            Architecture       Description
		+++-===========================-==================-==================-===========================================================
		un  e2fsck-static               <none>             <none>             (no description available)
		ii  e2fslibs:amd64              1.42.13-1ubuntu1   amd64              ext2/ext3/ext4 file system libraries
		ii  e2fsprogs                   1.42.13-1ubuntu1   amd64              ext2/ext3/ext4 file system utilities
	<<<
	- packages met "ii" in 1ste kolom zijn geinstalelerd

- op exacte naam
	$ apt-cache policy e2fsprogs
	e2fsprogs:
	  Installed: 1.42.13-1ubuntu1
	  Candidate: 1.42.13-1ubuntu1
	  Version table:
	 *** 1.42.13-1ubuntu1 500
			500 http://archive.ubuntu.com/ubuntu xenial/main amd64 Packages
			100 /var/lib/dpkg/status

- zie ook sectie "details van een package"

- systemrescuecd heeft die progs niet, zie gewoon :
	- bij download
	- http://www.system-rescue-cd.org/Detailed-packages-list

=== details van een package ===

- zie ook sectie "Which PPA Repository A Package Belongs To"

$ dpkg-query -s e2fsprogs
	>>>
		Package: e2fsprogs
		Essential: yes
		Status: install ok installed
		...
		Version: 1.42.13-1ubuntu1
		...
		 /etc/mke2fs.conf f3de4385c498ee9e01d1d703f0c3795d
		Description: ext2/ext3/ext4 file system utilities
		 The ext2, ext3 and ext4 file systems are ...
	<<<

=== (maximum) aantal open bestanden of filedescriptors ===
	- Get max open files allowed per process:
		$ ulimit -n
		>>> 1024 <<<
	- Get maximum open files allowed:
		$ cat /proc/sys/fs/file-max
		>>> 1611831 <<<
	- current number of open files:
		$ cat /proc/sys/fs/file-nr
		>>> 9786	0	1611831 <<<
		- 9786 open van max. 1611831
	- sum of opened files by all processes (telt veel dubbel) :
		$ lsof | wc -l
		>>> 104602 <<<
		- lsof zonder opties: lijst van alle open filedescriptors
		- wc -l : word count - count lines

=== temperatuur van hdd ===
	$  sudo hddtemp /dev/sdb
		>>> /dev/sdb: TOSHIBA DT01ACA300: 40°C <<<

=== aantal processors (fysiek + hyperthreading virtueel) ===
	$ nproc
		>>> 8 <<<

=== type partitie (mbr of gpt) en detail van alle partities op alle schijven ===
	$ sudo parted -l

=== report file system disk space usage ===
	- Show information about all file systems :
		$ df
	- Show information about the file system on which the specified file resides
		$ df pad-naar-bestand
		- toont o.a. device en mountpoint :
			>>> df "een bestand ergens op /dev/sda1" :
				Filesystem      1K-blocks       Used Available Use% Mounted on
				/dev/sda1      2753050464 2392517016 220663500  92% /media/sdata
			<<<

=== aantal inodes in een directory tree ===

- als root om ALLES te vinden
	# find . -xdev -printf '%i\n' | sort -u | wc -l
	-xdev : niet naar submounts
	- %i : print inode
	-u : unique sort
	-l : count lines

=== partities en bestandssystemen identificeren ===

==== de symbolic links in /dev/disk/* ====

- OPM: misschien niet algemeen,maar wel in systemrescuecd (5.2.2), en Ubuntu (16.04)

- is toegankelijk voor niet-root

- De volgende directories :
	  /dev/disk/by-id
	  /dev/disk/by-label
	  /dev/disk/by-partlabel
	  /dev/disk/by-partuuid
	  /dev/disk/by-path
	  /dev/disk/by-uuid
  bevatten voor elk device van categorie "disk" die een identificatie hebben van het genoemde "by"-type, een (relatieve) symbolic link van die identificatie naar het device, b.v. :
	$ readlink /dev/disk/by-label/M2ROOT
		>>> ../../nvme0n1p2
	$ readlink -f /dev/disk/by-partlabel/m2_root
		>>> /dev/nvme0n1p2
	-f : canonicalize

==== blkid ALS ROOT ====

- OPM: ENKEL ALS ROOT BETROUWBARE INFO; voor niet-root gebruikers werkt blkid vanuit een cache, gevuld bij gebruik door root, en dus verouderd kan zijn. Gewone gebruikers gebruiken beter lsblk

- met blkid devicenaam e.a. bepalen, b.v.
	# blkid -o device -t PARTLABEL=tosh_linux
	-o (device|list|udev|full) : output alleen devicenaam, ... (zie voorbeelden)
	-t token=value : token kan o.a. zijn LABEL, UUID, PARTLABEL, PARTUUID, TYPE
	[-l] : (letter l, niet cijfer 1) : look up only the (first) device with the highest priority.
		[alleen zinvol met brede selectiecriteria zoals -t TYPE=ext4]. Devices in decreasing
		priority are: Device Mapper, EVMS, LVM, MD, and finally regular block devices.
	- verkorte opties :
		# blkid -L fslabel
		- impliceert "-o device"
		# blkid -U fsuuid
		- impliceert "-o device"
	- vb. :
		# blkid -o device -t PARTLABEL=tosh_linux
		 >>> /dev/sdb2
		# blkid -o device -t PARTUUID=70c59928-a23f-49d2-8823-208d9f57e68d
		 >>> /dev/sdb1
		# blkid -L TEFI
		 >>> /dev/sdb1
		# blkid -L TLINUX
		 >>> /dev/sdb2
		# blkid -U 036E-FCF8
		 >>> /dev/sdb1
		# blkid -U f7158182-82e9-41b7-bebd-3c5cb23d3ca3
		 >>> /dev/sdb2

- andere outputopties :
	- list : This output format is DEPRECATED in favour of the lsblk(8) command. Prints the devices in a user-friendly format; this output format is unsupported for low-level probing (-p or -i).
		# blkid -o list -t LABEL=TEFI
		 >>>
			device      fs_type  label   mount point      UUID
			-------------------------------------------------------
			/dev/sdb1   vfat     TEFI    (not mounted)    036E-FCF8
		 <<<
	- udev : This output format is DEPRECATED. Prints key="value" pairs for easy import into the udev environment; the keys are prefixed by ID_FS_ or ID_PART_
		# blkid -o udev #(blkid -U 036E-FCF8)
		 >>>
			ID_FS_LABEL=TEFI
			ID_FS_LABEL_ENC=TEFI
			ID_FS_UUID=036E-FCF8
			ID_FS_UUID_ENC=036E-FCF8
			ID_FS_TYPE=vfat
			ID_FS_PARTLABEL=tosh_efi
			ID_FS_PARTUUID=70c59928-a23f-49d2-8823-208d9f57e68d
		 <<<
	- full :
		# blkid -o full #(blkid -L TEFI)
		 >>> /dev/sdb1: LABEL="TEFI" UUID="036E-FCF8" TYPE="vfat" PARTLABEL="tosh_efi" PARTUUID="70c59928-a23f-49d2-8823-208d9f57e68d"
	- export : print key=value pairs for easy import into the environment
		# blkid -o export #(blkid -L TEFI)
		 >>>
			DEVNAME=/dev/sdb1
			LABEL=TEFI
			UUID=036E-FCF8
			TYPE=vfat
			PARTLABEL=tosh_efi
			PARTUUID=70c59928-a23f-49d2-8823-208d9f57e68d
		 <<<

==== findmnt ====

- zoekt bij verstek "in kernel table of mounted filesystems", zal wel betrouwbaarder zijn dan alles wat in /procs, /etc/mtab, ... zoekt
	>>> man mount
		For more robust and customizable output use findmnt(8), especially in your scripts
	<<<

- geschikt voor gebruik in bash command substitution, b.v.
	$ opdracht --uuid=$(findmnt -no UUID device)
	OF
	$ opdracht --uuid=$(findmnt -no UUID mountpoint)
	-n, --noheadings :don't print column headings
	-o, --output <list> : the output columns to be shown
	- beschikbare kolommen :
		>>> findmnt --help, onder andere
			  SOURCE  source device
			  TARGET  mountpoint
			  FSTYPE  filesystem type
			 OPTIONS  all mount options
		  FS-OPTIONS  FS specific mount options
			   LABEL  filesystem label
				UUID  filesystem UUID
		   PARTLABEL  partition label
			PARTUUID  partition UUID
				USED  filesystem size used
		<<<
	[-P, --pairs] :use key="value" output format, zoals lsblk hieronder

==== lsblk ====

- betrouwbaar voor niet-root gebruikers

- device-keuze kan in lsblk enkel op devicenaam; maar opties maken uitvoer geschikt voor keuze van device met grep, en parsen met bash. Vb. :
	$ export $(lsblk -nPpo PARTLABEL,NAME,PARTUUID | grep -E "^PARTLABEL=\"m2_root\"")
	- lsblk opties :
		-n : geen header
		-p : print volledige devicenaam, b.v. /dev/sda i.p.v. sda
		-o : namen van te printen eigenschappen, b.v. NAME,[PART]LABEL,[PART]UUID
		[-O] : print alle eigenschappen
		[-r] : print eigenschappen zonder namen, gewoon in volgorde; kan met slechte labels  zorgen dat grep onbedoeld 2 devices uitkiest
			- b.v. label met alleen [0-9a-f-] kan ook in uuid voorkomen
		[-P] : print als NAAM=WAARDE, moeilijker te parsen dan -r, maar eenduidigere grep
	- grep opties :
		-E ... : gewone regexp, met PARTLABEL aan begin van de lijn
	- export $() : maakt van de met grep gekozen output van "lsblk -nP" ineens omgevingsvariabaelen (bash verwacht commando als 1ste woord, zonder export krijgt ge foutboodschappen dat NAAM geen commando is, of nog ergere dingen als NAAM wel een commando is)
	$ echo $PARTLABEL
	 >>> PARTLABEL="m2_root" <<<
	$ echo $NAME
	 >>> NAME="/dev/nvme0n1p2" <<<
	$ echo $PARTUUID
	 >>> PARTUUID="aa679962-a12e-4f09-b010-371956223d25" <<<

- om alleen devicenaam te vinden, best "lsblk -pr" (volledige naam, raw uitvoer), b.v. :
	$ lsblk -nrp -o PARTLABEL,NAME | grep -E "^m2_root /dev/"
	 >>> m2_root /dev/nvme0n1p2
	$ lsblk -nrp -o PARTLABEL,NAME | grep -E "^m2_root /dev/" | grep -oE "/dev/[^[:space:]]+$"
	 >>> /dev/nvme0n1p2
	- grep opties
		-o : print alleen gematchte deel van de lijn
		-E "/dev/[[:alnum:]_/-]+$" : onderdelen :
			- $ : match alleen aan einde van de lijn
			- /dev/ : begint met /dev/
			- [^[:space:]]+ : 1 of meer space chars: in the ‘C’ locale, this is tab, newline, vertical tab, form feed, carriage return, and space.

=== details bestandssysteem ===

$ lsblk -OP /dev/sdb1
	-O : alle eig.
	-P : als NAAM=WAARDE
	>>>
	NAME="sdb1" KNAME="sdb1" MAJ:MIN="8:17" FSTYPE="vfat" MOUNTPOINT="" LABEL="TEFI" UUID="036E-FCF8" PARTTYPE="c12a7328-f81f-11d2-ba4b-00a0c93ec93b" PARTLABEL="tosh_efi" PARTUUID="70c59928-a23f-49d2-8823-208d9f57e68d" PARTFLAGS="" RA="128" RO="0" RM="0" HOTPLUG="0" MODEL="" SERIAL="" SIZE="10G" STATE="" OWNER="root" GROUP="disk" MODE="brw-rw----" ALIGNMENT="0" MIN-IO="4096" OPT-IO="0" PHY-SEC="4096" LOG-SEC="512" ROTA="1" SCHED="deadline" RQ-SIZE="128" TYPE="part" DISC-ALN="0" DISC-GRAN="0B" DISC-MAX="0B" DISC-ZERO="0" WSAME="0B" WWN="0x5000039fe3c6dce1" RAND="1" PKNAME="sdb" HCTL="" TRAN="" SUBSYSTEMS="block:scsi:pci" REV="" VENDOR=""
	<<<

==== details ext2/3/4 ====

$ sudo dumpe2fs -h /dev/sdb2
	>>>
	dumpe2fs 1.42.13 (17-May-2015)
	Filesystem volume name:   TLINUX
	Last mounted on:          /media/tlinux
	Filesystem UUID:          f7158182-82e9-41b7-bebd-3c5cb23d3ca3
	...
	Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize
	...
	Inode count:              4194304
	Block count:              16777216
	Reserved block count:     838860
	Free blocks:              14487382
	Free inodes:              3922393
	...
	Lifetime writes:          28 GB
	...
	<<<

==== details FAT ====

$ sudo file -s /dev/sdb1
	>>>
	/dev/sdb1: DOS/MBR boot sector, code offset 0x58+2, OEM-ID "mkfs.fat", sectors/cluster 16, Media descriptor 0xf8, sectors/track 63, heads 255, hidden sectors 2048, sectors 20971520 (volumes > 32 MB) , FAT (32 bit), sectors/FAT 10240, serial number 0x36efcf8, label: "TEFI       "
	<<<

=== fragmentatie van bestand ===

	$ filefrag GrootBestand
	>>> GrootBestand: 26 extents found
	$ filefrag -v GrootBestand
	-v : verbose
	- de kolom expected geeft aan wanneer er een extra fragment begint (andere physical offset dan het 'expected' volgende block. Samenvatting onderaan geeft aantal zulke sprongen als 'extents'
	>>>
		Filesystem type is: ef53
		File size of GrootBestand is 34359738368 (8388608 blocks of 4096 bytes)
		 ext:     logical_offset:        physical_offset: length:   expected: flags:
		   0:        0..       0:      34816..     34816:      1:
		   1:        1..   30719:      34817..     65535:  30719:             unwritten
		   2:    30720..   61439:      65536..     96255:  30720:             unwritten
		   3:    61440..   63487:      96256..     98303:   2048:             unwritten
		   4:    63488..   94207:     100352..    131071:  30720:      98304: unwritten
		   5:    94208..  124927:     131072..    161791:  30720:             unwritten
		...
		 282:  8364032.. 8388607:    8976384..   9000959:  24576:             last,unwritten,eof
		GrootBestand: 26 extents found
	<<<
	- OPM : 'unwritten' is typisch voor een GrootBestand aangemaakt met fallocate, zolang er inderdaad niet geschreven is naar die blocks. Swap file gemaakt met fallocate zal altijd unwritten blijven, omdat het swap-mechanisme niet langs het bestandssysteem gaat voor het schrijven: het vraagt aan het bestandssysteem enkel de lijst van blocks, en doet daarna direct I/O naar die blocks.

=== is dit een virtual machine ===

- /proc/cpuinfo heeft dan een flag "hypervisor" voor elke cpu
	$ grep -q "^flags.* hypervisor" /proc/cpuinfo && echo "This machine is a VM"

- welke machine : (werkt ook buiten VM)
	# dmidecode -t system | grep 'Manufacturer\|Product'

=== time van een opdracht ===

	$ time opdracht
	>>> standaard opties :
		real	2m14,654s
		user	6m9,839s
		sys		0m15,829s
	<<<
		real : Elapsed real (wall clock) time used by the process
		user : Total number of CPU-seconds that the process used directly (in user mode)
		sys  : Total number of CPU-seconds used by the system on behalf of the process (in kernel mode)

=== linux logs ===

- zie "https://help.ubuntu.com/community/LinuxLogFiles"
- zie "man journald.conf"

- verschillende logs staan in /var/log, meeste als tekstbestand met generaties, oudere gezipt (zelf in te stellen)
	- journal in /var/log/journal, in binair formaat, te raadplegen met journalctl, zie sectie "journalctl"
	
- kernel ring buffer?
	$ dmesg
	
- hele syslog :
	$ less /var/log/syslog
	- shift-g : scroll naar einde
	- /zoekterm[Enter] : zoeken, met n(ext) en p(revious); regex-speciale chars escapen met '\'
	
- iets bepaalds zoeken, b.v. TBYTES :
	$ grep TBYTES /var/log/syslog

- log opvolgen
	$ tail -f -n 50 /var/log/syslog
	- afsluiten met Ctrl-Z
	-f : follow; tail blijft actief en scrollt naar achter naarmate log wordt bijgevuld
	-n 50 : aantal lijnen

==== journalctl ====

- systeem- en user-journaal zijn binaire bestanden in /var/log/journal/, beheerd en raadpleegbaar met de opdracht journalctl.
	- OPM: default gedrag in Ubuntu (Storage=auto in journald.conf) : als directory /var/log/journal/ niet bestaat, wordt journal bijgehouden in /run/log/journal (dir. wordt aangemaakt); in Ubuntu is /run een tmpfs, dus journals verdwijnt bij afsluiten

- journals nakijken :
	- Ubuntu (bionic) journalctl gecompileerd zonder -g --grep optie; om te zoeken pipe naar grep
	# journalctl --no-pager -D /mnt/var/log/journal/ >/media/ramdisk/journals
	--no-pager : niet pipen naar less, zodat ge zelf een pipe kunt doen naar b.v. grep, of  redirect naar tekstbestand
	-D : directory naar ander journal, b.v. van gemounte andere systeemschijf

- lijst van alle gejournaleerde opstartsessies
	# journalctl --list-boots 

- journals verkleinen :
	# journalctl --disk-usage
		- Bij mij 500MB, en dat zit mee in mijn backup
	- journalctl --list-boots geeft bij mij aan dat hij de log van de laatste 133 boots heeft bijgehouden.
	- Gelukkig kunt ge dat verminderen : https://askubuntu.com/questions/1012912/systemd-logs-journalctl-are-too-large-and-slow/1012913#1012913
		- eenmalig :
			# journalctl [--vacuum-size=10M] [--vacuum-time=2weeks] [-D /mnt/var/log/journal]
			[--vacuum-size=10M] : verwijdert enkel volledige journal-archieven
			[--vacuum-time=2weeks] : verwijdert enkel volledige journal-archieven
			[-D /mnt/var/log/journal] : in journal van ander systeem
		- blijvend : directory /etc/systemd/journald.conf.d/ maken met .conf-bestand, b.v. :
			>>> /etc/systemd/journald.conf.d/kleinerjournaal.conf
			SystemMaxUse=50mb
			<<<
			- zie "man journald.conf"

== HANDELINGEN ==

=== sed - zoek en vervang in een bestand ===

- OPM : -E om extended regular expression te gebruiken, anders basic regex (zoals grep)

- man sed is beknopt :
	$ info sed

==== search/replace regexp op 1 lijn
	$ sed -Esi s/zoek/vervang/g file.txt [file2.txt]...
		-E : extended regular expression
		-s : elk bestand apart
		-i[backupextensie], --in-place[=backupextensie] : niet naar stdout, maar naar originele bestandsnaam, met evt. backup
		[-e] script, --expression=script : script commands to be executed; als er meer dan 1 script is, moet de -e er staan
		- script : gequote als er spaties in staan

==== dos CRLF naar unix LF ===
	$ for i in *.srt;do sed -i 's/\r$//' "$i";done
	-i : in place
	- gewoon alle \r weglaten
	- OPM: in for-loop bestand per bestand, want met b.v. "sed ... *.srt" concateneert alle inputbestanden

==== unix LF naar dos CRLF ===
- b.v. onze Medion TV leest .srt subscripts alleen met dos CRLF lijneinde :
	$ for i in *.srt;do sed -i -e 's/$/\r/' -e 's/\r\r/\r/' "$i";done
	-i : in place
	-e : nodig als er meer opdrachten zijn
	- eerst blindweg een \r voor elk lijneinde ('$') zetten, dan alle \r\r vervangen door \r (fallback voor als het bestand al (deels) dos CRLF heeft) :
	- OPM: in for-loop bestand per bestand, want met b.v. "sed ... *.srt" concateneert alle inputbestanden
	
==== sed space ====
- hold space : a long-term storage, such that you can catch something, store it and reuse it later when sed is processing another line. You do not directly process the hold space, instead, you need to copy it or append to the pattern space if you want to do something with it.

- pattern space : When sed reads a file line by line, the line that has been currently read is inserted into the pattern buffer (pattern space). Pattern buffer is like the temporary buffer, the scratchpad where the current information is stored. For example, the print command p prints the pattern space only. Likewise, s operates on the pattern space.

- met sed, search/replace regexp op meer lijnen: eerst hele bestand laden in "hold space", en dat als geheel naar "pattern space" sturen en multi-line regexp op uitvoeren
	$ sed -Ei -e '1h;2,$H;$!d;g' -e "s/lijn1\nlijn2/nieuw op lijn 1.../g"
	-e script, --expression=script : add the script to the commands to be executed
	- '1h;2,$H;$!d;g' : tussen '' gezet om interpreteren van $ door bash te voorkomen
		1h : "1" 1ste lijn - "h" in hold space zetten
		2,$H : "2,$" 2de t.e.m. laatste lijn - "H" append na \n aan hold space
		$!d : "$!" alle behalve laatste lijn - "d" pattern niet behandelen, lees volgende lijn en begin terug met eerste sed-commando van script
		g : "" alle lijnen, maar komen hier alleen voor de laatste lijn, waarvoor geen "d" wordt gedaan - "g" kopieer hold space naar pattern space (en voer daarop dan volgende sed scripts uit)

==== sed opdrachten ====
- command summary for sed : http://docstore.mik.ua/orelly/unix/sedawk/appa_03.htm

- command "cheat-sheet"
	: : label
	= : line number
	a : append text to stdout after flush
	b : branch unconditional
	c : range change
	d : pattern delete top/cycle
	D : pattern ltrunc(line + \n) top/cycle
	e : execute
		- execute the contents of pattern space as command, and replaces the pattern space with its output; a trailing newline is suppressed
		- uitvoeringsfouten krijgen de prefix "sh: ", vanwege de shell die door execute wordt aangeroepen om de contents of pattern space uit te voeren
		- OPM : typisch wordt de opdracht in pattern space samengesteld door voorafgaande substitute 's', met & (volledige pattern match) en \N (gematchte capturing group)
		- OPM : volledige pattern space wordt als opdracht uitgevoerd; evt. jongleren met hold space, of opdracht opsplitsen met meerdere capturing groups en echo om diegene te behouden die niet door opdracht bewerkt moeten worden, b.v.:
			's/(prefix)(opdrachtparams)(suffix)/echo "\1" "$(opdracht \2)" "\3"/;e'
				- OPGELET : 's///', NIET "s///", zodat de $() command substitution pas wordt uitgevoerd door de shell die de execute doet, met substitutie van \N en &, en niet reeds vooraf door de shell die sed uitvoert
				- "" rond "$()" enkel nodig om evt. spaties in uitvoer te beschermen
	e COMMAND : execute COMMAND
	g : pattern = hold
	G : pattern += \n + hold
	h : hold = pattern
	H : hold += \n + pattern
	i : insert text to stdout now
	l : pattern list
	n : pattern flush = nextline continue
	N : pattern += \n + nextline
	p : pattern print
	P : pattern first line print
	q : flush quit
	r : append file to stdout after flush
	s/zoek/vervang/gi : substitute
		- NIET VERGETEN : sed-optie -E voor extended regular expression
		- attempts to match the pattern space against the supplied regular expression REGEXP; if the match is successful, then that portion of the pattern space which was matched is replaced with REPLACEMENT.
		- eerste teken na s (hier de /) scheidt de onderdelen zoek en vervang, b.v. 's|pad/naar/bestand|ander/pad/naar/bestand|g'
		- opties na laatste / :
			- g : optie global (allemaal, anders alleen 1ste voorkomen)
			- 9 : niet de 1ste, maar de 9-de match vervangen
			- i, I : case insensitive matching
			- m, M : multiline matching
			- p : print pattern space
			- e : execute; if a substitution was made, pattern space is executed as a shell command, and replaced with the output (trailing newline is suppressed)
				- weinig of geen onderscheid met command e, behalve dat deze versie enkel bij een s kan, en enkel wordt uitgevoerd als de s een vervanging doet
		- speciale waarden in vervang-pattern :
			- \1 ... \9 : gematchte groepen (wat tss. () staat, in volgorde, ook genest)
			- & : hele gematchte pattern
			- \L : Turn the replacement to lowercase until a '\U' or '\E' is found,
			- \l : Turn the next character to lowercase,
			- \U : Turn the replacement to uppercase until a '\L' or '\E' is found,
			- \u : Turn the next character to uppercase,
			- \E : Stop case conversion started by '\L' or '\U'.
	t : branch on substitute
	w : append pattern to file now
	x : swap pattern and hold
	y/sourcechars/destchars/ : transform chars

=== beschermd tekstbestand bewerken ===

- veilig en snel, maar in tekst-interface (nano)
	$ sudoedit tekstbestand
	- bewerkt een tijdelijke kopie, en hernoemt die pas na afsluiten terung naar originele naam
	
- met sudo, sudo -i, pkexec, mijn bash-alias spawn etc. kunt ge alles bewerken

=== eigenaar of groep van bestand veranderen ===

- met naam (d.i. dirk, Dirk is maar een displaynaam), niet uid of gid:
	- allebei
		$ sudo chown naam:groep foobar
	- alleen naam
		$ sudo chown naam bestand
	- alleen groep
		OFWEL
		$ sudo chown :groep bestand
		OFWEL
		$ sudo chgrp groep bestand

=== luidspreker kiezen ===

- mogelijkheden bekijken met
	$ pacmd list-cards
  In huidige pc geeft dit
		3 card(s) available.
			index: 0
			name: <alsa_card.usb-Plantronics_Plantronics_.Audio_648_USB-00>
			driver: <module-alsa-card.c>
			owner module: 6
			properties:
				alsa.card = "1"
			...
			index: 1
			name: <alsa_card.pci-0000_05_01.0>
			driver: <module-alsa-card.c>
			owner module: 7
			properties:
				alsa.card = "0"
				alsa.card_name = "SB Live! 5.1 [SB0220]"
			...
			index: 2
			name: <alsa_card.pci-0000_00_1f.3>
			driver: <module-alsa-card.c>
			owner module: 8
			properties:
				alsa.card = "2"
				alsa.card_name = "HDA Intel PCH"
			...
				device.description = "Built-in Audio"
			...
			profiles:
				input:analog-stereo: Analogue Stereo Input (priority 60, available: unknown)
				output:analog-stereo: Analogue Stereo Output (priority 6000, available: unknown)
				output:analog-stereo+input:analog-stereo: Analogue Stereo Duplex (priority 6060, available: unknown)
				output:hdmi-stereo: Digital Stereo (HDMI) Output (priority 5400, available: unknown)
			...
  en blijkbaar is het de index, en niet het alsa.card nummer dat we nodig hebben voor het volgende commando. Maar aangezien de index opnieuw bepaald wordt bij elke opstart, beter de name gebruiken:
- geluid van built-in audio (index 2) naar tv-uitgang (hdmi) sturen:
	(NIET pactl set-card-profile 2 output:hdmi-stereo)
	$ pactl set-card-profile alsa_card.pci-0000_00_1f.3 output:hdmi-stereo
- geluid van built-in audio (index 2) naar lijn-uitgang (mini-cinch) sturen:
	(NIET pactl set-card-profile 2 output:analog-stereo)
	$ pactl set-card-profile alsa_card.pci-0000_00_1f.3 output:analog-stereo

- programma starten met bepaald kanaal voor in- en/of uitvoer:
	- gewenste kanalen moeten geactiveerd zijn (Profile) op hun resp. device
		OFWEL
		- in pavucontrol/Configuration
		OFWEL
		- met cli, lijst van geluidsdevices en hun profielen
			$ pacmd list-cards
				>>> (
				...
				index: 3
				name: <alsa_card.pci-0000_00_1f.3>
				driver: <module-alsa-card.c>
				owner module: 10
				properties:
					alsa.card = "0"
					alsa.card_name = "HDA Intel PCH"
				...
				profiles:
					input:analog-stereo: Analogue Stereo Input (priority 60, available: unknown)
					output:analog-stereo: Analogue Stereo Output (priority 6000, available: unknown)
				...
				<<<
			- syntax "pacmd set-card-profile CARD PROFILE", met CARD (index of naam) en PROFILE ("off", "output:naam", "input:naam" of "output:naam+input:naam" zonder afsluitende ':') te vinden met commando list-cards
			- voorbeeld moederbord audio, met "pacmd list-cards" zoals hierboven:
				OFWEL
				$ pacmd set-card-profile 3 output:hdmi-stereo+input:analog-stereo
				OFWEL
				$ pacmd set-card-profile alsa_card.pci-0000_00_1f.3 output:analog-stereo
	- lijst van beschikbare ingangen (afh. van pavucontrol/Configuration)
		$ pactl list | grep -A2 'Source #' | grep 'Name: ' | cut -d" " -f2
		>>> vb.
			combined.monitor
			alsa_output.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo.monitor
			alsa_input.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo
			alsa_output.pci-0000_00_1f.3.analog-stereo.monitor
			alsa_output.pci-0000_05_00.0.analog-stereo.monitor
			alsa_input.pci-0000_05_00.0.analog-stereo	---> (FM801 PCI geluidskaart)
			alsa_input.pci-0000_05_01.1.analog-stereo	---> (Bt878 video tuner)
			alsa_input.pci-0000_00_1f.3.analog-stereo	---> (moederbord)
		<<<
		- met de monitors kunt ge niets aanvangen
	- lijst van beschikbare uitgangen (afh. van pavucontrol/Configuration)
		$ pactl list | grep -A2 'Sink #' | grep 'Name: ' | cut -d" " -f2
		>>> vb.
			combined
			alsa_output.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo
			alsa_output.pci-0000_00_1f.3.analog-stereo	---> (moederbord)
			alsa_output.pci-0000_05_00.0.analog-stereo	---> (FM801 PCI geluidskaart)
		<<<
	- in/uitgangen kiezen met env. variabelen PULSE_SOURCE/PULSE_SINK, b.v.
		OFWEL
		$ export PULSE_SOURCE="alsa_input.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo"
		$ export PULSE_SINK="alsa_output.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo"
		$ skype
		OFWEL in commando buiten bash shell (b.v. in .desktop bestand, met de opdracht 'env var=waarde opdracht', niet zomaar 'var=waarde opdracht' zoals in bash)
		Exec=env PULSE_SOURCE="alsa_input.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo" PULSE_SINK="alsa_output.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo" skype
			- de opdracht env voert een opdracht uit in een gewijzigde omgeving
		OFWEL in 1 commando (in bash shell is wijziging van omgeving ingebouwd d.m.v. NAAM=WAARDE prefix)
		$ PULSE_SOURCE="alsa_input.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo" PULSE_SINK="alsa_output.usb-Plantronics_Plantronics_.Audio_648_USB-00.iec958-stereo" skype

=== geluidrecorder ===
Simpele rechttoe rechtaan recorder naar wav:
	$ arecord filename.wav
Neemt op in 'Unsigned 8 bit, Rate 8000 Hz, Mono'
Enkele opties:
	-d ##	:voor seconden (anders Ctrl+C om te stoppen)
	-V mono	of -V stereo : toon VU meter
	-f cd : 441000kHz 16-bit stereo

=== pdf utilities ===

- geinstalleerd :
	pdf180             pdfbook            pdfflip            pdfjam-slides3up   pdfpun             pdftoppm
	pdf270             pdfbook2           pdffonts           pdfjam-slides6up   pdfseparate        pdftops
	pdf2dsc            pdfclose           pdfimages          pdfjoin            pdfsig             pdftosrc
	pdf2ps             pdfcompress        pdfinfo            pdflatex           pdftex             pdftotext
	pdf90              pdfcrop            pdfjadetex         pdflatexpicscale   pdftocairo         pdfunite
	pdfannotextractor  pdfdetach          pdfjam             pdfnup             pdftohtml          pdfxmltex
	pdfatfi            pdfetex            pdfjam-pocketmod   pdfopen            pdftool            pdfxup

- uit de Poppler bibliotheek gebruikt door de evince document viewer
	pdfdetach extract embedded documents from a PDF
	pdffonts lists the fonts used in a PDF
	pdfimages extract all embedded images at native resolution from a PDF
		$ pdfimages -all -p input.pdf outputprefix
		- kopieert alle beelden uit input.pdf naar outputprefix-###.ext , met ext extensie die hoort bij het beeldformaat
		-all : ingebedde jpg, jpeg2000, jbig2 en ccitt naar zichzelf, cmyk naar tiff, rest naar png
		-p : voeg bladzijdenr toe aan outputprefx, vóór nummering beeldbestanden
	pdfinfo list all infos of a PDF
	pdfseparate extract single pages from a PDF
	pdftocairo convert single pages from a PDF to vector or bitmap formats using cairo
	pdftohtml convert PDF to HTML format retaining formatting
	pdftoppm convert a PDF page to a bitmap
	pdftops convert PDF to printable PS format
	pdftotext extract all text from PDF
	pdfunite merges several PDF

- java PDFMultivalent: zie eigen script ~/bin/pdftool en ~/bin/pdfcompress
	Split, Merge, Compress, Uncompress, Info, Validate, Repair, Decrypt, Encrypt, Impose, Undo, Extract, Diff, Convert, Stamp

- Ghostscript, b.v. pdf comprimeren door beeldkwaliteit te verlagen:
	$  gs -dNOPAUSE -sDEVICE=pdfwrite -dCompatibilityLevel=1.6 -dPDFSETTINGS=/screen -sOutputFile=out.pdf in.pdf
	- op ghostscript-prompt ">" quit [enter]
	-dPDFSETTINGS=/screen of =/ebook of =/printer of =/prepress
	-dNOPAUSE niet pauseren tussen paginas

- eigen java progs
	$ java JpgExtractor x.pdf
	$ java be.arci.pdf.ImageExtractor x.pdf
	$ Usage: java be.arci.pdf.ImageWrapper [-d dir] [[image(.jb2|.jpg|.jp2)]... [out.pdf] [-s|-g]]...
		 -d dir change directory for all following filenames (including for generated pdf filename)
			- OPM : opgepast met wildcards, niet geëxpandeerd in 'dir'
		 -s      wrap evt. preceding images in a pdf and set single mode
		 -g      wrap evt. preceding images in a pdf and set group mode (default)
		 out.pdf wrap preceding images in the named pdf file
		 All filenames not ending in '.pdf' will be assumed to be images.
		 ImageWrapper currently handles jbig2, jpeg and jpeg2000 images.
		 In single mode each image is wrapped in a separate pdf file.
		 In group mode all consecutive images are wrapped as pages of 1 pdf file.
		 If no pdf file name is given, one is generated from the filename of the 1st
		 image of a group, by appending or substituting the extension '.pdf'.

==== pdf paginagroottes ====

- lijst van groottes met Poppler bib :
	$ pdfinfo -f 1 -l 99  Physics\ ~\ Giancoli-x.pdf
		[-f 1] : (vanaf) blad 1, anders maar 1 blad (standaard 1ste blad)
		[-l 99] : (tot) blad 99, anders maar 1 blad (standaard 1ste blad)
		[-box] : Print the page box bounding boxes: MediaBox, CropBox, BleedBox, TrimBox, and ArtBox

- aanpassen paginagrootte (b.v. witruimte rondom toevoegen)
	- Foxit PDF editor (wine)
		- centert oude paginas in nieuwe grotere pagina
		- kan wijziging toepassen op alle blz.
		- kan naar keuze inhoud aanpassen aan nieuwe paginagrootte
		- kan wschlk. geen pdf van >1000 blz openen
	- Master PDF  Editor
		- voegt witruimte rechts-boven toe
		- kan wijziging toepassen op oneven/even/alle blz.
			- nuttig om oneven/even anders te behandelen : tussenin 180° roteren

==== pdf splitsen in oneven en even paginas en terug samenvoegen ====

- zie ook sectie "opdracht uitvoeren op alle bestanden van een directory tree" subsectie "vb. 12 jpeg scans opsplitsen naar linker- en rechterblz."

- met java PDFMultivalent (script ~/bin/pdftool)
	- opgelet : evt. hierarchische inhoudstafel (index) in het document wordt in 2 hierarchieën gesplitst
	$ pdftool Split -pages "odd;even" invoer.pdf
		- OPM : meerdere page ranges gescheiden door ';' (is bash-teken, daarom tussen "")  maakt evenzoveel documenten, hier invoer-x1.pdf met oneven en invoer-x2.pdf met even blz
			- evt. inhoudstafel wordt gesplitst
	$ pdftool Merge -samedoc  invoer-x1.pdf invoer-x2.pdf
		- zet alle oneven, dan alle even blz. terug samen (1,3,5,...,2,4,6,...) in invoer-x1-m.pdf
		-samedoc : zet inhoudstafel van even blz. volledig achter die van oneven blz.
			- hierarchie wordt niet gemerged, maar achter elkaar geplakt, b.v.
				- hfstk1
					- blad1
					- blad3
				- hfstk2
				...
				- hfstk1
					- blad2
					- blad4
				...
	$ pdftool Split -pages "odd,even,backmap" invoer-x1-m.pdf
		- zet blz. terug in juiste volgorde (1,2,3,4,5,6,...)
		- inhoudstafel blijft staan zoals Merge ze heeft gemaakt (maar verwijst natuurlijk wel naar juiste blz.)

=== mkv video splitten ===

- niet meer geinstalleerd (mkvtoolnix)
Meerdere sequenties samen in 1 bestand bewaren:
	$ mkvmerge -o /media/ramdisk/out.mkv --split parts:uu:mm:ss-uu:mm:ss,+uu:mm:ss-uu:mm:ss ... input.mkv
	- zowel begin als einde van elke sequentie beginnen op volgende key-frame, dus om het beginframe goed te krijgen, proberen met telkens een paar seconden eraf.

=== geluidsbestand splitsen volgens cue file ===

- OPM : shntool hercodeert de gesplitste uitvoer ALTIJD. Is geen bezwaar voor verliesloze formaten zoals flac, maar voor mp3, als er een klein beetje stilte is rond de splitspunten, kan ffmpeg splitsen zonder hercoderen : zie "_ffmpeg truuks en commandos.adoc" sectie "splitsen in segmenten"

- Enkel voor cue met slechts 1 FILE met daarin verschillende tracks, b.v. om 1 flac uit te splitsen over meer flacs:
	- zowel de oplossing met shntool split -f, als die met cuebreakpoints, lezen enkel de "INDEX 01" van de cue-file, dus NIET de FILE statements, en shntool past die INDEX points dan blind toe op het invoerbestand plaat.flac
	$ shntool split -f plaat.cue -t "%n %t" -o flac plaat.flac
		- shnsplit is andere naam voor shntool split
		-f plaat.cue : Specifies a file from which to read split point data. If a simple CUE sheet, each "INDEX 01 m:ss:ff" line is converted to a m:ss.ff split point (ff in 75 frames per seconde). If not given, then split points are read from the terminal
		-t "%n %t" : Name output files in user‐specified format based on CUE sheet fields.  The following formatting strings are recognized:
			%p Performer
			%a Album
			%t Track title
			%n Track number
		-o flac : uitvoerformaat flac, evt. tussen '' met opties voor flac opdracht, waarin %f wordt vervangen door de bestandsnaam
		OF
		- b.v. 'cust ext=mp3 lame --quiet -m j -h -V 2 - %f'
		plaat.flac : het origineel, een hele plaat in 1 geluidsbestand
		- splitst op de "INDEX 01" punten, b.v.
			>>> .cue file
				FILE "Anna Moffo - Canteloube Villa-Lobos Rachmaninov.flac" WAVE
				  TRACK 01 AUDIO
					INDEX 01 00:00:00
				  TRACK 02 AUDIO
					INDEX 00 03:15:68
					INDEX 01 03:17:63
			<<<
			maakt 1ste track 3' en 17" en 63/75" lang
		- daarom kunnen flac bestanden die met shnsplit gemaakt zijn, gewoon terug met shntool join aaneengeplakt worden om het origineel te bekomen
	OFWEL (alternatief voor -f : zonder -f "split points are read from the terminal") :
	$ cuebreakpoints plaat.cue | shntool split -o flac plaat.flac
		- cuebreakpoints is part of cuetools

- tags toevoegen aan de resulterende flac op basis van cue-sheet, onder aanname dat de flac bestanden sorteren in track-volgorde (b.v. omdat ze genummerd zijn) :
		$ cuetag plaat.cue *.flac
		- cuetag is part of the cuetools, maar eerste op path is mijn versie in ~/bin/cuetag :
			$ cuetag -h

- info over cue files : http://wiki.hydrogenaud.io/index.php?title=Cue_sheet

=== flac geluidsbestanden achter elkaar plakken ===

- bestanden in natuurlijke sortering samenvoegen naar /media/ramdisk/samengevoegd.flac
	OFWEL
	$ shnjoin ./*.flac -o flac -a /media/ramdisk/samengevoegd
	OFWEL
	$ shntool join ./*.flac -o flac -a /media/ramdisk/samengevoegd
	-o flac : uitvoerformaat flac, evt. tussen '' met opties voor flac opdracht, waarin %f wordt vervangen door de betandsnaam
	-a str : Prefix str to base part of output filenames, default is 'joined'
	- andere opties :
		-r val : reorder input files;  val is one of: {ask, ascii, natural, none}.  The default is natural.

	- voorbeelden met deze invoer :
	>>> files.lst (flacs uit ~/Music)
		Anna Moffo - Aria Cantilena (Villa-Lobos).flac
		Anna Moffo - Vocalise Op34 (Rachmaninov).flac
		Claude Debussy - Nocturnes - Sirènes.flac
	<<<
	- join naar 1 flac-bestand
		$ shntool join -F files.lst -n -o flac
		-n : niet padden achteraan tot volledige CD-blocksize (zou alleen nuttig zijn om cd te schrijven)
		[-a prefix] : uitvoernaam prefix (eig. volledige naam bij join, i.p.v. "joined")
		>>>
			Joining [Anna Moffo - Aria Cantilena (Villa-Lobos).flac] (7:05.17) --> [joined.flac] (23:58.12) : 100% OK
			Joining [Anna Moffo - Vocalise Op34 (Rachmaninov).flac] (7:05.70) --> [joined.flac] (23:58.12) : 100% OK
			Joining [Claude Debussy - Nocturnes - Sirènes.flac] (9:47.00) --> [joined.flac] (23:58.12) : 100% OK
			Output file was not padded, nor was it needed.
		<<<
	- join naar 1 mp3-bestand zonder tijdelijk flac-bestand
		$ shntool join -F files.lst -n -o 'cust ext=mp3 lame --quiet -m j -h -V 2 - %f'
		- OPM: mislukt soms om onduidelijke reden, mogelijk op buffer voor pipe naar cust
			>>>
				shntool [join]: warning: error while transferring 49744800 bytes of data
				shntool [join]: warning: child encoder process 5831 had non-zero exit status 1
				shntool [join]: error: failed to join files
			<<<
		- cust : externe encoder
		- ext=mp3 : extensie voor output "joined.$ext"
		- lame ... : de externe encoder en zijn opties
			-m j : joint stereo
			-h : high quality (trager)
			-V 2 : variable bitrate en kwaliteit (0 hoog, 9 laag)
			-tt : titel
			-ta : artiest
			...
			- : encode from stdin
			%f : output, default ingevuld door shntool met joined.$ext
		>>>
			Joining [Anna Moffo - Aria Cantilena (Villa-Lobos).flac] (7:05.17) --> [joined.mp3] (23:58.12) : 100% OK
			Joining [Anna Moffo - Vocalise Op34 (Rachmaninov).flac] (7:05.70) --> [joined.mp3] (23:58.12) : 100% OK
			Joining [Claude Debussy - Nocturnes - Sirènes.flac] (9:47.00) --> [joined.mp3] (23:58.12) : 100% OK
			Output file was not padded, nor was it needed.
		<<<

- cue-sheet maken (of alvast de basis daarvan)
	- info over cue files : http://wiki.hydrogenaud.io/index.php?title=Cue_sheet
	$ shntool cue  -F files.lst
	-
	- alleen nuttig samen met 'join' : bevat maar 1 bestandsnaam "joined.wav"
	- zelf aanvullen met TITLE "titel", PERFORMER "zanger", COMPOSER "", ARRANGER "" en GENRE "" (VLC leest alleen de eerste 2)
		- per cue-sheet vooraan
		- per track na "TRACK ##"
	>>>
		FILE "joined.wav" WAVE
		  TRACK 01 AUDIO
			INDEX 01 0:00:00
		  TRACK 02 AUDIO
			INDEX 01 7:05:17
		  TRACK 03 AUDIO
			INDEX 01 14:11:12
	<<<
	- OPM : VLC (en waarschijnlijk geen enkel programma) vindt correct begin van gejoinde tracks in een VBR mp3-bestand; bij afspelen hebben ze natuurlijk wel de juiste lengte.
	- voorbeelden op basis van vorige join-voorbeelden:
	>>> split.cue
		FILE "Anna Moffo - Aria Cantilena (Villa-Lobos).flac" WAVE
		  TRACK 01 AUDIO
			TITLE "Aria Cantilena (Villa-Lobos)"
			PERFORMER "Anna Moffo"
			INDEX 01 0:00:00
		FILE "Anna Moffo - Vocalise Op34 (Rachmaninov).flac" WAVE
		  TRACK 02 AUDIO
			TITLE "Vocalise Op34 (Rachmaninov)"
			PERFORMER "Anna Moffo"
			INDEX 01 0:00:00
		FILE "Claude Debussy - Nocturnes - Sirènes.flac" WAVE
		  TRACK 03 AUDIO
			TITLE "Nocturnes - Sirènes"
			PERFORMER "Claude Debussy"
			INDEX 01 0:00:00
	<<<
	>>> joined.flac.cue
		FILE "joined.flac" WAVE
		  TRACK 01 AUDIO
			TITLE "Aria Cantilena (Villa-Lobos)"
			PERFORMER "Anna Moffo"
			INDEX 01 0:00:00
		  TRACK 02 AUDIO
			TITLE "Vocalise Op34 (Rachmaninov)"
			PERFORMER "Anna Moffo"
			INDEX 01 7:05:17
		  TRACK 03 AUDIO
			TITLE "Nocturnes - Sirènes"
			PERFORMER "Claude Debussy"
			INDEX 01 14:11:12
	<<<
	>>> joined.mp3.cue
		FILE "joined.mp3" MP3
		  TRACK 01 AUDIO
			TITLE "Aria Cantilena (Villa-Lobos)"
			PERFORMER "Anna Moffo"
			INDEX 01 0:00:00
		  TRACK 02 AUDIO
			TITLE "Vocalise Op34 (Rachmaninov)"
			PERFORMER "Anna Moffo"
			INDEX 01 7:05:17
		  TRACK 03 AUDIO
			TITLE "Nocturnes - Sirènes"
			PERFORMER "violist"
			SONGWRITER "Claude Debussy"
			INDEX 01 14:11:12
	<<<

=== zip zonder compressie ===
	-0 : no compression (store all files)
	- zie ook sectie "opdracht uitvoeren op alle bestanden van een directory tree" subsectie "vb. 9 stripverhalen opnieuw inpakken naar cbz"

=== Folders delen op het netwerk ===

- Benodigd: Samba (sudo apt-get install samba, zie _Xubuntu.adoc)

- zie ook sectie "symlinks volgen in Samba netwerk shares"

- shares worden geconfigureerd via leesbare bestanden in /var/lib/samba/usershares/, aangemaakt met de commando's van 'net usershare' (zie 'net help usershare', 'net help usershare add' etc.). Die commando's kunnen evt. toegevoegd worden aan thunar (Edit/Configure Custom Actions/+, met in de tab 'Appearance conditions' alleen Directories aangevinkt).
	- folder met definitie van samba-networkshares moet waarschijnlijk leesbaar zijn:
		- kreeg eerst veel foutberichten
		>>> /var/log/samba/log.pav (voor computer PAV van Mieke)
			[2017/05/07 19:44:25.795655,  0] ../source3/param/loadparm.c:3259(process_usershare_file)
			process_usershare_file: stat of /var/lib/samba/usershares/muziek failed. Permission denied
		<<<
		- met chmod, of in thunar properties van /var/lib/samba/usershares/: "other: read"

- share toevoegen 'net usershare add [-l|--long] <sharename> <path> [<comment>] [<acl>] [<guest_ok=[y|n]>]'
	- zie "_Xubuntu.adoc" sectie "op netwerk gedeelde directories"
	0 restricted to directories you own
		- verholpen met toevoeging aan /etc/samba/smb.conf (b.v. in sectie 'misc', juist voor header "Share Definitions" :
		>>>
			# Allow usershare without owning the shared folder (t.b.v. usershare op ramdisk)
		   usershare owner only = false
		<<<
		0 tijdelijk ramdisk schrijfbaar maken vanuit netwerk
			- enkel eigenaar kan directory delen, dus eerst een directory maken op ramdisk :
			$ mkdir /media/ramdisk/RW ;  net usershare add RAMDISK /media/ramdisk/RW "ramdisk van frt (vergankelijk)" Everyone:f guest_ok=y
			NA AFLOOP
			$ net usershare delete RAMDISK

- share verwijderen
	$ net usershare delete <sharename>

- zie ook _VirtualBox.txt sectie "Samba share mounten in VM"
- toon share-namen
	- volledige lijst (met commando's) zie "_Xubuntu.adoc" sectie "op netwerk gedeelde directories"
	>>> $ net usershare list
		MUZIEK
		...
	<<<

- toon de inhoud van de bestanden uit /var/lib/samba/usershares/
	$ net usershare info

=== Samba configuratie wijzigen ===

- staat in /etc/samba/smb.conf
	$ man smb.conf

- shares definieren in smb.conf is nog niet gelukt
	- zie "_Xubuntu.adoc" sectie "Samba installeren om network shares te maken", OPM onderaan

- Samba leest smb.conf om de 60 seconden, wijzigingen best eerst opslaan onder tijdelijke naam en testen, vooraleer smb.conf zelf te overschrijven :
	$ testparm /etc/samba/smb.conf.nieuw

- After saving /etc/samba/smb.conf, be sure you restart Samba:
	# /etc/init.d/samba restart

=== symlinks volgen in Samba netwerk shares ===

- Samba verhindert als standaard toegang via symbolic links (verbergt die zelfs) naar directories en bestanden buiten een netwerk-share
	- VirtualBox shared folders doen dit NIET, daar wprden symbolic links wel gevolgd
		- OPGELET : resultaat van volgen op guest VM kan/zal anders zijn dan volgen op host
		- guest VM kan zonder "VBoxManage setextradata" geen symbolic links maken op shared folder
			- zie "_VirtualBox.txt" sectie "Symbolic links op shared folders"
	- zie "https://www.samba.org/samba/news/symlink_attack.html"
	- zie "https://unix.stackexchange.com/questions/5120/how-do-you-make-samba-follow-symlink-outside-the-shared-path"
	- zie "https://www.samba.org/samba/docs/using_samba/ch08.html#samba2-CHP-8-TABLE-1"
	- zie sectie "Samba configuratie wijzigen"
	>>> /etc/samba/smb.conf
		[global]
		unix extensions = no

		[share]
		follow symlinks = yes
		wide links = yes
	<<<
	- "unix extensions = yes" kan blijven als volgt:
		- dit lijkt onveiliger
		- met unix extensions kunnen directories/bestanden 'echt' gedeeld worden over netwerk, i.p.v. enkel toegankelijk zijn voor read/write, lijkt niet nodig voor mij
		>>> /etc/samba/smb.conf :
			[global]
			unix extensions = yes
			allow insecure wide links = yes

			[share]
			follow symlinks = yes
			wide links = yes
		<<<

=== Bestanden nummeren ===

- kan ook met b.v. Thunar Bulkrename

- alle bestanden in een reeks subdirectories van huidige directory opeenvolgend nummeren vanaf 01, met evt. een vaste extensie
	$ for i in ./* ; do num=100; cd "$i" ; for j in *.* ; do ((++num)) ; mv "$j" "${num:1}.jpg" ; done; cd .. ;done
	- num=100 zorgt dat de volgende 99 num's even veel (3) cijfers hebben
	- ((++num)) : increment num
	- ${num:1} pitst daar het eerste cijfer (de 1##) af
	- OPGELET: als de bestanden al genummerd zijn vanaf 00, wordt 00 over 01 gemoved, en dan over 02, ..., tot er maar 1 bestand overblijft: de originele 00, maar hernoemd naar het laatste nummer + 1

=== meerdere opdrachten (CLI en GUI) als root uitvoeren ===

- terminalgebruiker op root zetten
	$ sudo -i
	- vervangt ineens environment van user door die van root
	- GUI commandos kunnen vanuit deze prompt veilig gestart worden als root; in achtergrond uitvoeren met '&' erachter, best stdout en stderr naar /dev/null pipen:
		# guiopdracht >& /dev/null &
		- zie ook functie 'spawn' in .bash_aliases.rc
	- GUI opdrachten niet gewoon met sudo uitvoeren: sudo zonder -i behoudt environment van user, de gui kan dan zijn configuratiebestanden van de user overschrijven als root, waardoor de user zelf er nadien niet meer aan kan veranderen; dat kan zelfs over login-bestanden gaan, waardoor de user niet meer kan inloggen.

=== Thunar Custom Actions ===

- worden opgeslagen in ~/.config/Thunar/uca.xml

- vb.: scripts uitvoeren vanuit thunar
	Create a Thunar Custom Action to do this:
	In Thunar, Edit -> Configure Custom Actions -> Add a new custom action, then:
	On the Basic Tab:
	   - Name = Run In Terminal
	   - Description = Run in Terminal
	   - Command = xfce4-terminal -e %f --hold
	   - Select an icon if you want
	- On the Appearance Conditions tab:
	   - pattern "*.sh", select "Other files"
	Then in thunar, right-click the script and select the "Run in Terminal" option.

=== opdracht shellscript uitvoeren in nieuwe terminal, en open houden ===

- opdracht uitvoeren in nieuwe (Xubuntu) terminal
	$ xfce4-terminal -x opdracht arg1 arg2
	- optie -x : rest van de lijn is de uit te voeren opdracht
	- optie -e : volgende string of "string1 string2 ..." is de uit te voeren opdracht
	- optie --tab of --window : 2de tab of window, met eigen opdracht
	- optie -H : venster open houden na afloop opdracht, maar geen prompt: enkel om uitvoer te kunnen lezen
	- optie -T titelstring
	- optie --geometry 80x25+0+0
	- sluit na afloop van de opdracht waarvoor hij wordt opgestart (vgl. de terminals die door Whisker worden geopend om een man-page te bekijken).

- opdracht uitvoeren in nieuwe terminal (Xubuntu), na afloop openhouden voor vervolgopdracht:
	$ xfce4-terminal -T titel -e "bash -c \"opdracht ; exec bash\""
b.v.	$ xfce4-terminal -T titel -e "bash -c \"./Documents/shellscripts/mijnscript.sh ; exec bash\""
	- 'bash -c' opent shell om script of andere opdracht uit te voeren
	- 'exec bash' vervangt het vorige proces, in dezelfde terminal, met uitvoer daarvan nog zichtbaar, en biedt prompt voor vervolgopdrachten; exec is a bash built in command:
		>>>
			Execute a command
			Syntax
				  exec [-cl] [-a name] [command [arguments]]
			Options
				  -l   Place a dash at the beginning of the zeroth arg passed to command. (This is what the login program does.)
				  -c   Causes command to be executed with an empty environment.
				  -a   The shell passes name as the zeroth argument to command.
			If command is supplied, it replaces the shell without creating a new process. If no command is specified, redirections can be used to affect the current shell environment. If there are no redirection errors, the return status is zero; otherwise the return status is non-zero.
		<<<

- vanuit script nieuwe interactieve shell/terminal openen om opdrachten te aanvaarden, bij exit daaruit gaat script verder: 	zet op die plaats in het script de opdracht
	bash -i
of (mits de aanpassing die ik daarvoor in .bash_aliases heb gedaan)
	TERMINALTITEL="Mijn titel voor het terminalvenster" bash -i

=== Beheer jobs ===

- GUI-programma als neven-proces openen vanuit terminal, en direct terug een prompt krijgen :
	$ opdracht &
		>>> man bash
		 If a command is terminated by the control operator &, the shell executes the command in the background in a subshell. The shell does not wait for the command to finish, and the return status is 0.
		<<<
		- foutboodschappen, zoals de veel voorkomende van gtk, komen wel in de terminal, tenzij met pipe naar null:
			$ opdracht >& /dev/null &
			- zie ~/bash_aliases functie spawn()

- Beheer jobs :
	- zie ook sectie "bash shell sneltoetsen"
	$ jobs
	- overzicht van gestopte en lopende jobs ?van terminalsessie (is denk ik niet echt een commando, bestaat alleen als er jobs zijn)
	$ fg n
	- 'foreground', koppelt job n aan de terminal en laat verder lopen
	$ bg n
	- 'background', laat job n verder lopen maar in de achtergrond, los van de terminal
	$ kill %n
	- zelfde als kill -TERM %n, breek job n helemaal af. De afgebroken job blijft wel als 'terminated' in jobs staan, mogelijk om met 'fg n' de job terug naar de voorgrond te brengen om zijn exit code te krijgen.
	- het is om jobnummer n (met prefix %) als argument te kunnen geven, i.p.v. pid, dat de opdracht kill is ingebouwd in bash
	$ ps
	- overzicht van alle processen ?van terminalsessie, met pid
	$ kill -STOP pid
	- zoals ctlr+z: stopt job met pid, zonder zijn resources vrij te geven
	$ kill -CONT [pid | %n]
	- zoals 'bg n': laat job pid terug lopen, maar in de achtergrond(?), los van de terminal
	$ kill -l
	- lijst van alle SIGxxxx die we naar jobs en processen kunnen sturen als 'kill -xxxx pid' of 'kill -xxxx %jobnr'

=== pipe naar bestand maar ook naar scherm ===

- tee : read from standard input and write to standard output and files
	$ opdracht | tee [-a] bestand
	- -a : --append

=== java broncode omzetten naar ASCII ===

- Op Windows (ook Eclipse voor Windows) waren alle tekst-bestanden (ook .java) gecodeerd als windows codepage 1252 (Latin-1). Op Xubuntu (ook Eclipse voor Linux) als UTF-8. Omzetten van cp1252 naar UTF-8 kan met iconv :
	$ iconv -f WINDOWS-1252 -t UTF-8 in.java uit.java
	- -f : from encoding
	- -t : to encoding
	- ZIE sectie "opdracht uitvoeren op alle bestanden van een directory tree" voor meer uitgewerkt voorbeeld

- JDK zelf heeft een geschikte opdracht om .java bronbestand om te zetten naar ASCII met Java-stijl Unicode-escapes
	$ native2ascii -encoding windows-1252 in.java uit.java

=== directory van mijn website synchroniseren over FTP  ===

- NIET rsync met FTP server gemount (b.v. met gigolo) op local file system : "is designed to compute file hashes remotely to compare files without transferring them, but doing that with virtual files transfers the files anyway"

- ZIE OOK Unison (nog in TEDOEN van _Xubuntu.adoc)

- ZIE https://stackoverflow.com/questions/1461978/how-to-synchronize-local-directory-with-remote-ftp-directory
	$ wget --mirror username:password@siteurl.com/path
	- nog te onderzoeken welke opties conflicten (gewijzigd aan beide kanten) behandelen
	- nuttige bijkomende opties :
		--limit-rate=amount : Limit the download speed to amount bytes (k kB, m MB) per second; e.g. --limit-rate=2.5k
		-w seconds , --wait=seconds : Wait seconds (m minutes, h hours, d days) between retrievals. Specify a large value to wait long enough to reasonably expect the network error to be fixed before the retry. The waiting interval specified by this function is influenced by "--random-wait".
		--waitretry=seconds : wait between retries of failed downloads. Wget will use linear backoff, waiting 1 second after the first failure on a given file, then waiting 2 seconds after the second failure on that file, up to the maximum number of seconds you specify. By default, Wget will assume a value of 10 seconds.
		--random-wait : causes the time between requests to vary between 0.5 and 1.5 * wait seconds, where wait was specified using the --wait option, in order to mask Wget's presence from analysis to identify automated retrieval programs.
		-Q quota , --quota=quota : Specify download quota in bytes (k kB, m MB) for automatic retrievals. This does not affect downloading a single file or file URLs specified on the command-line. Quota is respected when retrieving either recursively, or from an input file. Thus you may safely type "wget -Q2m -i sites"; download will be aborted when the quota is exceeded. Setting quota to 0 or to inf unlimits the download quota.

=== opdracht uitvoeren op alle bestanden van een directory tree ===

ZIE http://www.dwheeler.com/essays/filenames-in-shell.html ("Filenames and Pathnames in Shell= How to do it Correctly.mht")
ZIE http://mywiki.wooledge.org/UsingFind

==== basistechnieken ====
	- for i in ./*.ext; do opdracht1; opdracht2; else opdracht3 ; opdracht4; done
	- for over alle subdirectories (in het algemeen globbing = wild card expansion over subdirectories):
		$ shopt -s globstar
		- hiermee wordt ** uitgebreid tot alle niveaus van subdirectories
		$ for i in ./**/*.ext;
	- find [bronpad] selecties acties
		- [bronpad] selecties : zie sectie "lijst-opdrachten" lemma "zoek bestanden en directories"
		- acties : default actie is naam naar stdout
			- meerdere akties zijn toegelaten, worden uitgevoerd in opgegeven volgorde, per zoekresultaat
			- b.v. opeenvolgende "-exec commando ;"
			- b.v. -print -exec commando \; : drukt bestandsnamen als separators tussen elke uitvoer commando
			-delete
			-exec commando : commando wordt direct vanuit find uitgevoerd, met de functie exec(args[]), dus zonder langs de shell te gaan: commando string opgesplitst in args[i] door find zelf
				- {} plaatshouder voor bestandsnaam(lijst)
					- wordt rechtstreeks ingevuld met het resultaat van find
					- soms t.b.v. shell escapen \{\} of quoten "{}", omdat { en } daar ook iets betekenen
				- commando afsluiten met \; :
					- per aanroep 1 bestandsnaam in {}
					- meerdere {} mag
					- {} mag overal staan
				- commando afsluiten met \+
					- per aanroep lijst van zoveel mogelijk bestandsnamen in {}
					- slechts 1 {}
					- {} moet helemaal achteraan, en naakt
						MAG : {} \{\} "{}"
						MAG NIET : "\{\}" prefix{}suffix, zelfs niet b.v. -{}
				- ALTERNATIEVEN :
					-execdir : commando wordt in directory van zoekresultaat uitgevoerd, is veiliger
						- met \+ worden zoekresultaten gegroepeerd per directory
						- OPGELET bestandsnaam ingevuld in {} bevat geen volledige padnaam meer, MAAR WEL "./"
					[-ok] OFWEL [-okdir] : prompt voor elk zoekresultaat, enkel met \; (per bestand)
						- "command ... bestandsnaam ... ?" (y of n enteren)
				- pipe in commando KAN NIET, want vooraf door shell verwerkt => onvolledige exec.
				- variable=waarde commando : idem (environment variable enkel voor uitvoering van commando)
				  OPLOSSING:
					- pipe na de \; of \+ is soms genoeg (b.v. voor gewone grep)
					- commando in script zetten, met {} als parameter
					- bash als commando gebruiken :
						$ find . -type f -exec bash -c 'commando1 $1 -$2 | commando2 $1 -$3' _ {} optie1 optie2 \;
							bash -c :
								- first non-option argument ('', NIET "") is command string
								- arguments after that assigned to positional parameters, starting with $0
								- in het voorbeeld wordt :
									- _ : $0 (plaatshouder)
									- {} : $1
									- optie1 : $2
									- optie2 : $3
						$ find . -type f -exec bash -c 'naam=waarde commando1 $1' _ {} \;
			-print : print zoekresultaten op stdout, gescheiden door \n
				-fprint file : naar bestand 'file'
			-print0 : gescheiden door 0x00
				-fprint0 file : naar bestand 'file'
			-printf formaat : geformateerd
				-fprintf file formaat : naar bestand 'file'
			...
		- OPM: bij het opbouwen en testen van -exec met echo i.p.v. uitvoering, moeten de "..." in de argumentlijst voor echo tijdelijk geschreven worden als "\"...\"", omdat echo zelfs zijn ding doet met ""
		- OPM: max. lengte command line is beperkt, -exec {} \+ splitst desnoods op over meerdere aanroepen
			OFWEL
			$ getconf ARG_MAX
			2097152
			OFWEL
			$ xargs --show-limits
			Your environment variables take up 3557 bytes
			POSIX upper limit on argument length (this system): 2091547
			POSIX smallest allowable upper limit on argument length (all systems): 4096
			Maximum length of command we could actually use: 2087990
			Size of command buffer we are actually using: 131072
			Maximum parallelism (--max-procs must be no greater): 2147483647

==== Korte voorbeelden ====
	- checksum van lijst bestanden
	OFWEL
	$ find pad -type f -exec sha256sum -b \{\} \; > sha256sums.lst
	OFWEL (sha256num aanvaardt meerdere bestandsnamen)
	$ find pad -type f -exec sha256sum -b \{\} \+ > sha256sums.lst
		-exec, want -execdir zou padnaam verwijderen, dus niet geschikt voor b.v. "sha256sum -c" achteraf
	- + sluit het opdracht-argument van -exec af, BEST net zoals de accolades ge-escaped met \ (of tussen '' of "")
	OFWEL
	$ find pad -type f -print0 | xargs -0 sha256sum -b > sha256sums.lst
	- "|" pijpt stdout van find naar stdin van xargs
	find -print0 : (niet in alle linux/unixen) namen in stdout van find gescheiden door 0x00
	xargs -0	 : (niet in alle linux/unixen) 0x00 als scheidingsteken in stdin van xargs
	- grootte van alle bestanden per directory :
	$ find /media/sdata/muziek -maxdepth 1 -type d -exec du -hs \{\} \;
	- totale grootte (du, disk usage) van alle bestanden van een bepaald type, b.v alle flac muziekbestanden :
	$ find /media/sdata/muziek -type f -iname "*.flac" -print0 | du -ch --files0-from=- | grep total
		du --files0-from=- : lees lijst namen met 0x0 als scheidingsteken van stdin (of =lijstbestand i.p.v. =-)
		du -c, --total : produce a grand total
		du -h, --human-readable : print sizes in human readable format (e.g., 1K 234M 2G)
	- alle bestanden in een subtree, met een bepaalde extensie, openen in mousepad (b.v. VirtualBox VM definities):
	$ find pad -type f -iname "*.vbox" -exec mousepad \{\} \+
	- alle java-sourcecodes converteren van Latin-1 (Eclipse voor Windows) naar UTF-8 (Ubuntu) :
	$ find . -type f -iname *.java -print -exec mv {} {}.cp1252~ \; -exec iconv -f WINDOWS-1252 -t UTF-8 -o {} {}.cp1252~ \;
		- eerst backup naar x.java.cp1252~ (bestand met suffix ~ is 'hidden' in thunar)
		- codepage 1252 is Latin1
		- semi-inplace via tussenbestand

==== vb. 1 alle .java omzetten van Windows cp1252 naar utf-8, met backup ====
	$ find . -type f -iname "./*.java" -exec bash -c 'iconv -f WINDOWS-1252 -t UTF-8 "$1" | diff -q - "$1" || { mv "$1" "$1.cp1252" && iconv -f WINDOWS-1252 -t UTF-8 -o "$1" "$1.cp1252" ; } ' _ \{\} \;
		bash -c '' _ \{\} : ingevulde \{\} als $1 in 'commandos'
		| : iconv naar stdout, en pipe naar stdin van diff
		diff - : stdin
		|| : als diff exit status != 0 heeft (1: inputs are not the same, 2: trouble)) wordt deel na || uitgevoerd (logische OR), een compound command list tussen { && ;} als geheel

==== vb. 2 als vb. 1, met delete van niet-gewijzigde bestanden ====
	OPGELET ALLEEN UITVOEREN OP RESERVEKOPIE, verwijdert alle .java-bestanden zonder speciale characters
	$ find . -type f -iname "*.java" -exec bash -c 'iconv -f WINDOWS-1252 -t UTF-8 "$1" | { diff -q - "$1" && rm "$1" ;} || { mv "$1" "$1.cp1252" && iconv -f WINDOWS-1252 -t UTF-8 -o "$1" "$1.cp1252" ; } ' _ \{\} \;

==== vb. 3 als vb. 2, met omzetten naar ASCII met Java Unicode escapes ====
	OPGELET ALLEEN UITVOEREN OP RESERVEKOPIE, verwijdert alle .java-bestanden zonder speciale characters
	$ find . -type f -iname "*.java" -exec bash -c 'iconv -f WINDOWS-1252 -t UTF-8 "$1" | { diff -q - "$1" && rm "$1" ;} || { mv "$1" "$1.cp1252" && native2ascii -encoding windows-1252 "$1.cp1252"  "$1" ; } ' _ \{\} \;

==== vb. 4a alle bestandsnamen met niet-ASCII tekens ====
	$ find . | perl -ne 'print if /[^[:ascii:]]/'

==== vb. 4b alle windows (cp1252) bestandsnamen in directory tree omzetten naar linux (UTF-8) bestandsnamen ====
	OPGELET: heel gevoelig voor de plaats van de quotes (en NIET escapen)
	OPGELET: eerst testen met een echo voor de mv (om absoluut zeker te zijn dat het CP1252 is, en b.v. geen rare chars van CP1252 die UTF-8 gecodeerd zijn)
	$ shopt -s globstar
	- zorgt voor expansie van ** naar volledige subdirectory tree
	$  for i in **/* ; do if [ -f "$i" ] && [ "$i" != "$(echo "$i" | iconv -f WINDOWS-1252 -t UTF-8)" ] ; then  mv "$i" "$(echo "$i" | iconv -f WINDOWS-1252 -t UTF-8)" ; fi; done
		- de "" rond $i dienen voor bestandsnamen met whitespace; zelfs dubbele spaties blijven behouden (van belang voor de echo)
		- de "" rond `opdracht` idem voor de geconverteerde bestandsnaam

==== vb. 5 kb/s van alle filmbestanden in een map ====
	$ find -maxdepth 1 -type f -exec /opt/ffmpeg/ffprobe -hide_banner {} \; 2>&1 | grep -e "Input #" -e "kb/s"
		2>&1 : ffprobe stuurt resultaat zot genoeg naar stderr, dus die moeten we aan stdout hangen
		grep -e : zo kan grep meerdere regexp tegelijk zoeken

==== vb. 6 alle films (van meerdere types: avi, mkv, mp4, mpg) ====
	$ find pad \( -iname ./*.avi -or -iname ./*.mkv -or -iname ./*.mp? \) -print0 | du -ch --files0-from=- | grep total
		\( ... -or ... \) : deze gehele expressie eerst, voor we de combinatie aanbieden aan -print0
			- zonder wordt alleen resultaat van de laatste test, "-iname ./*.mp?", naar -print0 gestuurd
			- escapes \( en \) zijn nodig voor bash, omdat die zijn eigen betekenis heeft voor ()
			-or : logische OR

==== vb. 7 symbolic links naar bestanden in hernoemde map ====

- links in current directory naar liedjes na hernoemen van /media/seag1m/ naar /media/sdata/ :
	$ find . -lname '/media/seag1m/*' -exec bash -c 'lied=$(readlink "{}") ; ln -sfi "${lied/seag1m/sdata}" "{}"' \;
	-lname : selecteer op target van de link, met klassieke bash pathname expansie
	-ilname : idem, case insensitive
	-sfi : maak symbolic link, forceer vervangen van bestaande (verbroken) link, maar interactief (y of n)
	bash -c '...' : nodig om de 2 commando's lied=... en ln ... aan elkaar te breien: lied= is iets van shell
	- ${parm/zoek/vervang} : parameteruitbreiding met vervanging van zoekterm

==== vb. 8 in een map links maken naar alle directories met een subdirectory "ORIG" ====
	$ mkdir /media/ramdisk/mp3
	$ cd /media/ramdisk/mp3
	$ find /media/sdata/muziek/ -type d -name ORIG -exec bash -c 'ln -s "$(realpath "{}/..")" ' \;
	-exec bash -c '...' : -exec van find is via call naar C exec(), niet via een shell; daarom werken shell-specifieke zaken zoals $() niet, daarvoor moet ge zelf een shell opstarten

==== vb. 9 stripverhalen opnieuw inpakken naar cbz ====
	- strips staan per album als .jpg in subdirectory van current directory :
	$ for i in * ; do cd "$i"; echo $PWD ; zip -0 ../"$i".cbz *.jpg ; cd ..; done

==== vb. 10 in alle bestandsnamen dubbele aanhalingstekens vervangen door enkele ====
	$ find -xdev -iname "*\"*" -execdir bash -c 'mv "${1//\"/"\""}" "${1//\"/\'\''}"' _ \{\}  \;
	- het argument voor bash -c staat best tussen enkele aanhalingstekens, dat voorkomt expansie (in deze shell, want in de aangeroepen bash-shell zijn die al verdwenen) :
	- zowel in de uitvoerende shell, als in de shell die wordt aangeroepen door de find-opdracht exec, de argumentstrings in 2 splitsen met extra set aanhalingstekens (die toch wegvallen na de nodige expansies), met daartussen ge-escaped het aanhalingstekens dat in de bestandsnaam moet staan/komen

==== vb. 11 bestanden zoeken met uitsluiting van bepaalde suffixen ====

- b.v. bestanden die geen e-book o.i.d. zijn, met bash brace expansion :
	- WERKT : met brace expansion find-opdracht samenstellen, en uitvoeren met eval
	$ eval find -type f "\! -iname \*."{pdf,djvu,epub,mobi,ps,txt,html,doc,docx,rtf,odt,cbz,chm}
	0 NIET find-opdracht rechtstreeks aanmaken :
		0 find -type f "\! -iname *".{pdf,djvu,epub,mobi,ps,txt,html,doc,docx,rtf,odt,cbz,chm} 
		- "iets"{x,y} expandeert tot "iets"x "iets"y
	- WERKT : genereer eerst de find-opdracht, toon die met echo, en dan kopieren, plakken, uitvoeren
		$ echo find -type f "\! -iname \"*\"".{pdf,djvu,epub,txt,html,htm,chm,doc,docx,ps,rtf,mobi,odt}
			>>> output kopieren naar een nieuwe opdrachtlijn :
			find -type f \! -iname "*".pdf \! -iname "*".djvu \! -iname "*".epub \! -iname "*".txt \! -iname "*".html \! -iname "*".htm \! -iname "*".chm \! -iname "*".doc \! -iname "*".docx \! -iname "*".ps \! -iname "*".rtf \! -iname "*".mobi \! -iname "*".odt
			<<<
	0 NIET $(echo find ... zie hierboven ...) : find geeft dezelfde fout als rechtstreekse find van hoger


==== vb. 12 jpeg scans opsplitsen naar linker- en rechterblz. ====
- sommige pdf's zijn per 2 blz. gescand :
	- jpg's uit pdf halen :
		$ java be.arci.pdf.ImageExtractor input.pdf
		OF (typisch als lengte van pdf-stream gecodeerd is in ander object, i.p.v. rechtstreeks opgegeven) :
		$ java JpgExtractor input.pdf
		OF
		$ pdfimages -all -p input.pdf outputprefix
	- resulterende jpegs opsplitsen in linker en rechter blz
		$ mkdir gesplitst.
		$ for i in *.jpg; do eval $(jpeginfo "$i"|sed -E 's/.*jpg ([0-9]+) x ([0-9]+) .*/w=\1 h=\2/');echo $i w:$w $((w/2)) h:$h;jpegtran -opt -prog -crop "$((w/2))x$h+0+0" -copy none -outfile "gesplitst/${i/.jpg/}L.jpg" "$i";jpegtran -opt -prog -crop $((w-w/2))x$h+$((w/2))+0 -copy none -outfile "gesplitst/${i/.jpg/}R.jpg" "$i";done
			- OPM : $(jpeginfo | sed) moeten in dezelfde subshell, dus dezelfde bracket expansion, want pipe werkt enkel binnen zelfde shell
			- OPM : jpegtran argumenten mogen afgekort worden, BEHALVE -outfile
		$ java be.arci.pdf.ImageWrapper gesplitst/*.jpg [uitvoer.pdf]
			- wildcard expansie is altijd alfanum gesorteerd, toegevoegde suffixen L en R geven toevallig de juiste volgorde

=== dubbele voorkomens verwijderen uit invoer ===

- met sorteren :
	$ sort -u
	-u, --unique : sorteer output only the first of an equal run
	[-c, --check, --check=diagnose-first] : do not sort, check for sorted input (anders error)

- zonder sorteren : b.v. alle directories met een of meer flac-bestand vinden
	- met awk, heeft eigen associative arrays, waarvoor we gevonden directories als key kunnen gebruiken, en zo zien of die eerder al gebruikt is :
		- vb.: maak lijst met alle directories met flac-bestanden :
			$ find "_Muziek/" -type f -iname "*.flac" -printf "%h\n" | awk '!a[$0]++'
			-printf "%h\n" : print alleen directory (zonder eind-/), met new-line achter
			- awk '!a[$0]++' : removes duplicate lines
				- OPGELET : enkele quotes '!...', want "!..." is bash history
				- a : willekeurige naam voor een array
				- $0 : hele invoerlijn van awk, in dit vb. de directorynaam
				- a[$0] : array element van 'a' met directorynaam als sleutel
				- !a[$0] : als element a[$0] niet bestaat [dan stuurt awk de invoer lijn uit naar stdout]
				- !a[$0]++ : increment array element (doet het ineens bestaan, zodat een volgende keer a[$0] met dezelfde invoerlijn WEL bestaat)
	- met bash associative arrays; moeten expliciet gedeclareerd, maar ge moet er awk niet voor leren:
		- vb.: voer opdracht uit op elke directory met flac-bestanden :
			$ find "_Muziek/" -type f -iname "*.flac" -printf "%h\n" | { declare -A a; while IFS= read -r map; do if [ ! ${a["$map"]} ]; then a["$map"]=x; opdracht $map; fi; done; }
			-printf "%h\n" : print alleen directory (zonder eind-/), met new-line achter
			- | { ... } : weerszijden van een pipe worden in een subshell uitgevoerd, waarna environment variabelen en cd-opdrachten verloren gaan; door opdrachtlijst binnen { } te zetten, is dat geheel 1 kant van de pipe, zodat daarbinnen variabelen en cd zichtbaar blijven
			- declare -A a : a is associative array (met keywords), anders met integers als sleutel
			- IFS= om begin- en eindspaties te behouden in read
			-r : Backslash does not act as an escape character. The backslash is considered to be part of the line. In particular, a backslash-newline pair may not be used as a line continuation.
			- "if [ ! ${a["$map"]} ]; then a["$map"]=x; opdracht $map; fi;" : als array element met key==directorynaam niet bestaat of leeg, zet dan dat array element (op een willekeurige waarde), en voer de opdracht uit
			- "${...}" : verhindert dat shell opeenvolgende whitespaces samen neemt tot 1 spatie

=== directory verwijderen ===

- lege directory
	$ rmdir mijndir

- hele tree met inhoud
	$ rm -r[f] mijndirtree
	- r : --recursive, remove directories and their contents
	- f : --force, ignore nonexistent files

- alle lege directories in tree
	- vinden:
	$ find mijndirtree -type d -empty -depth
	- -depth om exact hetzelfde zoekgedrag te hebben als bij -delete
	- verwijderen:
	$ find mijndirtree -type d -empty -delete

=== directory tree kopieren, met behoud van eigenaars en rechten ===

- kopieer bron/ naar doel/, resultaat doel/
	# cp -ax[n] bron/. doel
	- -a : --archive, combineert:
		-d : --no-dereference --preserve=links (volg links niet, maar kopieer ze wel)
		-R : recursive
		--preserve=all : bewaar niet alleen de links, ook eigenaarsschap, rechten, ...
	- -x : --one-file-system, stay on this filesystem (volg geen mounts)
	- bron/. : kopieer de self-directory van bron, niet bron zelf (dus niet naar doel/bron/). Aangezien we recursive kopieren, is dit de inhoud
	- OPM: niet bron/* /doel, want dat slaat verborgen bestanden en directories (die beginnen met .) over
	- -n : --no-clobber, do not overwrite existing file

- kopieer bron/ naar bestaand doel/, resultaat doel/bron/
	# cp -ax[n] bron doel
	- OPM: als doel nog NIET bestaat, wordt het gemaakt en komt enkel de inhoud van bron erin, niet bron als subdirectory doel/bron/

=== directory tree vergelijken ===
	$ diff -rqN -x=pattern dir1/ dir2/ | tee bestand
	- -r : recursive
	- -q : --brief, "quiet", meldt alleen als er verschillen zijn
	- -N : treat absent files as empty (en geeft dus verschil als het bestand in 1 tree bestaat en niet leeg is)
		- variant: --unidirectional-new-file : treat absent first files as empty
	- -x : --exclude=pattern, exclude files that match 'pattern'
		- variant: -X : --exclude-from=FILE, exclude files that match any pattern in FILE
	- | tee bestand : stuurt stout naar stdout én bestand
b.v.	# diff -rqN -x=.swapfile /media/sdata/. /media/tarch/. | tee /media/ramdisk/difftree

=== Backup restoren naar Virtualbox VM met EFI boot ===

- zie "_VM model restore Ubuntu-backup.txt"

=== in standby of uit zetten na verloop van tijd (b.v. 45 minuten)  ===

- voor standby of uit na download met nzbget: zie hierna
- standby of uit na vast aantal minuten:
	$ sleep 45m ; standby
	- standby is mijn .bash-aliases alias voor "systemctl suspend"
	$ sleep 45m ; uit
	- uit is mijn .bash-aliases alias voor "shutdown now"

=== in standby of uit zetten na nzbget einde ===

- op download naam klikken
- knop [Postprocess -> ]
- procedure (eigen script) postproc_standby (of postproc_shutdown) op 'yes'
- save
- OPM: met postproc_standby blijft ramdisk behouden om evt. download fouten nog op te lossen, bij postproc_shutdown niet, maar bij fout is de download sowieso niet klaar, dus dan wordt die procedure niet aangeroepen

=== prioriteit van een taak instellen ===

- nieuwe taak : start de taak met voorvoegsel 'nice ' of 'nice -n niceness ', bij voorbeeld om taak met lage prioriteit te laten draaien
	$ nice hercomprimeervideo.sh
	- niceness [-20,19] is bereidheid om tijd af te staan aan andere taken.
	- uit niceness en realtime of niet berekent het systeem een prioriteit als 20 - niceness
	- in uitvoer van 'top' staan de kolommen PRioriteit en NIceness
	- zonder 'nice' start een taak met niceness 0
	- met 'nice ' start een taak met niceness 10
	- met 'nice -n niceness ' start een taak met de opgegeven niceness
	- voor niceness < 0 is root nodig

- bestaande taak (processid nodig)
	$ renice -n niceness -p processid

=== opstartboodschap "system program problem detected" verhelpen ===

- apport-gtk-root meldt programma-fouten aan hun auteurs: diagnose met extensie .crash  in /var/crash/. Bij volgende boot vraagt dialoog "system program problem detected" of apport-gtk-root melding mag sturen. Bedoeling is dat elk soort crash maar 1 keer gerapporteerd wordt (middels lege dummy bestanden xxx.upload en xxx.uploaded), maar de foutmelding blijft komen zolang het .crash-bestand bestaat :
	$ ll /var/crash/
	# rm /var/crash/*
	- verwijdert alle bestaande crash diagnoses

- B.v. VirtualBox maakt hier gebruik van, en sluit al eens een VM fout af. Nuttig voor de ontwikkelaars, maar niet als ge ettelijke versies achterloopt.

- crashreport systeem uitschakelen vanaf volgende boot
	$ sudo nano /etc/default/apport : wijzig als volgt
		"enabled=0"
	- uitschakelen zonder reboot (volgens bestand zelf)
		$ sudo service apport start force_start=1
		- volgens bestand zelf (en stackexchange)
	- uitschakelen zonder reboot (sinds Ubuntu 16.04)
		- a different syntax than just restart is needed to restart apport. 16.04 uses systemd to manage services :
		$ sudo systemctl restart apport

- In ~/.apport-ignore.xml staan programmas waarvoor geen crashraport meer moet gemaakt worden. Ik weet niet hoe ze daarin gezet worden. De mtime (wschlk. modification time) is misschien een manier om de 'versie' van het programma aan te geven

=== urlencode ===

- definieer deze functie in bash, (b.v. door ze gewoon naar terminal te kopiëren :
	- niet inspringen of met voorloopspaties, maar geen tabs!
	- laatste lijn, leeg op 1 spatie na is handig, om LF na "} ;" mee te nemen
	>>>
		codeerurl() {
			local string="${1}";
			local strlen=${#string};
			local encoded="";
			local pos c o;
			for (( pos=0 ; pos<strlen ; pos++ ));
			do
			c=${string:$pos:1};
			case "$c" in
				[-_.~a-zA-Z0-9] ) o="${c}" ;;
				* )               printf -v o '%%%02x' "'$c";
			esac;
			encoded+="${o}";
			done;
			# You can the result (EASIER)
			echo "${encoded}";
			# or set a return variable (FASTER)
			#REPLY="${encoded}";
		};
	<<<

- aanroepen als volgt:
	$ codeerurl http://www.url.be?zoek=term&taal=nl
	of
	$ codeerurl "http://www.url.be?zoek=woord1 woord2&taal=nl"
	of (om resultaat in commando te gebruiken)
	$ doeiets `codeerurl  "http://www.url.be?zoek=woord1 woord2&taal=nl"`

=== computernaam wijzigen ===

- in 2 bestanden aanpassen :
	- /etc/hostname
	- /etc/hosts lijn met 127.0.1.1

- zonder herstarten toepassen (lukt niet altijd) :
	# service hostname start

=== Mr Sid converteren ===

	$ for i in *.sid; do /opt/GeoExpress/bin/mrsidgeodecode -i "$i" -o /media/ramdisk/"$i".jpg;done
	- .jpg 3-4 keer zo groot als .sid
	- andere opties :
		$ /opt/GeoExpress/bin/mrsidgeodecode -h : korte help
		$ /opt/GeoExpress/bin/mrsidgeodecode -help : lange help

=== helderder beeld ===

- b.v. om video te spelen op monitor; puur software regeling, en niets voor overlay apart
	- Bionic HDMI-n, Xenial : HDMIn
	$ xrandr --output HDMI-2 --brightness 1.2
	$ xrandr --output HDMI-2 --gamma 1.6:1.6:1.6
	- voor hardware regeling helpt misschien xbacklight (te installeren)

=== cat zonder commentaar en lege lijnen ===

- zie ~/bin/compcat

- laat alle lijnen weg die leeg zijn, of volledig blank (spatie of tab) op '#'-commentaar na
	$ grep -vE "^[ \t]*(#.*| *)$" bestand...
	-E : extended regexp
	[-h] : print zonder bestandsnaam, zelfs als er meer bestanden gegeven zijn
	[-H] : print met bestandsnaam, zelfs als er maar 1 bestand gegeven is

=== pythons CLI Web Server gebruiken ===

- zie "https://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python"
	$ cd webroot
	$ python -m SimpleHTTPServer [poort]
	Ctrl-Z : beëindigen
	- default poort 8000, IP 0.0.0.0
	- andere IP, b.v. localhost :
	>>> mijnserver.py
		#! /usr/bin/python
		import sys
		import BaseHTTPServer
		from SimpleHTTPServer import SimpleHTTPRequestHandler
		HandlerClass = SimpleHTTPRequestHandler
		ServerClass  = BaseHTTPServer.HTTPServer
		Protocol     = "HTTP/1.0"
		if sys.argv[1:]:
			port = int(sys.argv[1])
		else:
			port = 8000
		server_address = ('127.0.0.1', port)
		HandlerClass.protocol_version = Protocol
		httpd = ServerClass(server_address, HandlerClass)
		sa = httpd.socket.getsockname()
		print "Serving HTTP on", sa[0], "port", sa[1], "..."
		httpd.serve_forever()
	<<<

=== php's CLI Web Server gebruiken ===

- zie "http://php.net/manual/en/features.commandline.webserver.php"

- enkel vanop eigen pc toegankelijk
	$ cd ~/webroot
	- b.v. met de php-installatie van mijn Bitnami nginx stack :
		$ ~/nginxstack-1.9.14-0/php/bin/php -S localhost:8000
		-S serveradres
		[ -t path-to-webroot] : absoluut of relatief, default is current directory
		[-c php.ini] : set configuration options
		- Ctrl-C om af te sluiten (NIET Ctrl-Z : maakt server onbereikbaar, maar proces blijft lopen en poort bezetten)
		- default home pagina is index.php, dan index.html

- toegankelijk vanop andere pc's
	$ ~/nginxstack-1.9.14-0/php/bin/php -S 0.0.0.0:8000

- Using a Router Script
	- vb. : requests for images will display them, but requests for HTML files will display "Welcome to PHP":
	>>> router.php
		<?php
		if (preg_match('/\.(?:png|jpg|jpeg|gif)$/', $_SERVER["REQUEST_URI"])) {
			return false;    // serve the requested resource as-is.
		} else { 
			echo "<p>Welcome to PHP</p>";
		}
		?>
	<<<
	$ php -S localhost:8000 router.php

=== grep een tab ===

- alleen perl-regexp van grep herkennen een tab-escape :
	$ grep -P "xxx\tyyy" ...

- alternatief : de tab op een andere manier in het grep-pattern krijgen
	- command substitution met printf :
		$ grep "xxx$(printf '\t')yyy"
	- command substitution met echo :
		$ grep "xxx$(echo -e '\t')yyy"
	- bash string quoting : Words of the form $'string' are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard. 
		$ grep $'xxx\tyyy'
		- om b.v. te combineren met variable expansion, gewoon 2 (quoted) strings concateneren, b.v.
			$ grep $'xxx\tyyy'"en een $variabele"

=== grep als cat met highlights ===
- voorbeeld : toon volledige uitvoer, maar met highlight
	$ apt-cache show node.js | grep -e "^" -e "^Description"
	-e "^" : matcht elk lijnbegin, toont dus elke lijn, maar heeft niets te highlighten
	-e "^Description" : heeft wel iets te highlighten
	
=== history wissen ===

- alle behalve open terminals :
	$ rm $/.bash_history

- sommige opdrachten
	$ mousepad ~/.bash_history
	
- huidige bash prompt
	- enkel vorige opdrachten niet toevoegen, latere wel :
		 $ history -c
		 - wist hele history list die in current terminal is ingeladen van uit history file en van nieuwe opdrachten
		 - wijzigt history file (~/.bash_history) niet
		 - is een bash-opdracht, heeft geen eigen man :
			$ help history
	- vorige noch volgende opdrachten toevoegen bij afsluiten bash prompt
		$ unset HISTFILE
		OF
		$ HISTSIZE=0
	- opdrachtgeschiedenis terug helemaal inlezen :
		$ history -r
		- handig na wissen history huidige shell met 'history -c'
	- opdrachtgeschiedenis van ene shell/terminal overdragen naar andere :
		- ene shell : opdrachtgeschiedenis opslaan
			$ history -a
				-a : append opdrachtgeschiedenis aan .bash_history
			OF (sluit die shell)
			$ exit
		- andere shell
			$ history -n
			-n : leest nieuwe lijnen uit .bash_history (elke bash shell onthoudt dus nr. laatst ingelezen lijn)

=== genummerde bestanden van ramdisk naar HDD verplaatsen naarmate ze aangemaakt worden ===

- een reeks bestanden aanmaken op ramdisk, kan ze vol doen lopen (b.v. media-bestanden in niet-gecomprimeerd formaat). Als ze genummerd zijn, in dit vb. van 01 tot 08, kunt ge ze naar HDD verplaatsen telkens als het volgende bestand gemaakt wordt :
	- genummerd zonder voorloopnullen : 
		$ for i in {2..99};do while ! [ -f $i*.avi ] ; do sleep 10;done;mv $((i-1))*.avi /media/sdata/WERK;done;klaar;sleep 30;cp $i*.avi /media/sdata/WERK/;sleep 30;slaap
			- als bestand 2 verschijnt, wordt verondersteld dat bestand 1 klaar is, en dat wordt naar HDD verplaatst
			- als alles klaar is (volgens mijn script "klaar") wordt tenslotte het laatste bestand (99 in dit voorbeeld) naar de HDD gekopiëerd (niet verplaatst, om niet te struikelen over evt. foute interpretatie van "klaar")
		- OPM : in $(()) moet er geen $ voor shell-veranderlijken, maar het mag wel; is wel nodig voor {} parameter expansion syntax
		- NIET "for i in {02..99}" : i zelf is string, maar in $(()) wordt die string geinterpreteerd als getal, octaal als er een voorloop-0 is, en 08 en 09 zijn octaal niet geldig
			- voorloop-0 van i evt. verwijderen met $((${i#0}-1) : remove prefix 0
			- evt. expliciteren dat i radix 10 heeft :  $((10#$i-1)) : syntax is radix#string; moeten dan wel $i gebruiken, want i zou geïnterpreteerd worden als digit, en dit zou in dit vb. " value [d.w.z. i] too great for base [d.w.z. 10]" geven
		- NOOIT voorloopnullen in output van $(()) 
	- genummerd met altijd 1 voorloopnul, 01 tot 10 :
		- expliciet de voorloopnul toevoegen wanneer we van i een bestandsnaam maken :
		$ for i in {2..9};do while ! [ -f 0$i*.avi ] ; do sleep 10;done;mv 0$((i-1))*.avi /media/sdata/WERK;done;klaar;sleep 30;cp 0$i*.avi /media/sdata/WERK/;sleep 30;slaap
	- genummerd met 1 voorloopnul wanneer < 10 (i.e. meer dan 10 bestanden 01,...,09,10,...) :
		- expliciet de voorloopnul toevoegen wanneer we van i < 10 een bestandsnaam maken :
		$ for i in {2..99};do while ! [[ -f 0$i*.avi || -f $i*.avi ]] ; do sleep 10;done;[[ $((--i)) -lt 10 ]] && i=0$i;mv  $i*.avi /media/sdata/WERK;done;klaar;sleep 30;cp $((++i))*.avi /media/sdata/WERK/;sleep 30;slaap
			- werken met 1 variabele, die we decrementen als we vorige bestandsnaam maken om te verplaatsen, maar dan moeten we wel terug incrementen om laatste bestandsnaam te maken

== RSYNC ==

- MIJN VOORKEUR voor synchronisatie van directories:
	- voor linux schijven :
		$ rsync -aASXx [-iv] [--delete] bronpad/ doelpad/
	- voor NTFS schijven :
		$ rsync -aSx --no-p --no-g --no-o [-iv] [-delete] bronpad/ doelpad/
		- sudo misschien niet nodig bij rsync, maar b.v. wel bij meld omdat die voor [--delete] naar .Trash wil doken
		
=== test of te verwachten resultaat nakijken ===
	$ rsync -niv ...
	-n, --dummy : geen wijzigingen aanbrengen
	-i, --itemize-changes : output a change-summary for all updates
	-v, --verbose : increase verbosity

=== archive mode ===
	-a , --archive	: archive mode; equals -rlptgoD (no -H,-A,-X) (preserve symbolic links, devices, attributes, permissions, ownerships, etc.)
		-r, --recursive	: recurse into directories
		-l, --links	: copy symlinks (as symlinks, zonder -l geheel niet)
		-p, --perms	: preserve permissions
		-t, --times	: preserve modification times
		-g, --group	: preserve group
		-o, --owner	: preserve owner (super-user only)
		-D		: same as --devices --specials
			--devices	: preserve device files (super-user only)
			--specials	: preserve special files
	- NTFS-schijven : -a afzwakken met --no-p --no-g --no-o (no permissions, no group, no owner), omdat die op NTFS toch niet kunnen gelijkgetrokken worden met ext4
	- in afwachting van voldoende kennis, doe ik daar zelf ook de volgende bij
		-A, --acls : preserve ACLs (implies -p)
		-X, --xattrs : preserve extended attributes
		- heeft een paar maar-en, en ik gebruik hard links zelf (nog) niet:
			0 -H, --hard-links : preserve hard links (look for hard-linked files in the source and link together the corresponding files on the destination.  Without this option, hard-linked files in the source are treated as though they were separate files.)
		-x, --one-file-system : (want linux/Ubuntu zelf mount her en der tmpfs en speciale bestandssystemen, die wil ik niet archiveren)
		-S, --sparse : handle sparse files efficiently
	- soms ook deze :
		--safe-links : (enkel effect samen met -l) ignore absolute symbolic links and symlinks that point outside the copied tree (oppassen samen met --relative)

=== verschil tussen bronmappen met en zonder eind-'/' ===
	>>> man rsync
		Put a trailing slash on the source to avoid creating an additional directory level at the destination. You can think of a trailing / on a source as meaning "copy the contents of this directory" as opposed to "copy the directory by name", but in both cases the attributes of the containing directory are transferred to the containing directory on the destination. In other words, each of the following commands copies the files in the same way, including their setting of the attributes of /dest/foo:
				  rsync -av /src/foo /dest
				  rsync -av /src/foo/ /dest/foo
	<<<
	- eind-'/' maakt geen verschil voor doelmap
	- bron MET eind-'/' : onbenoemde submapstructuur synchroniseren met doelpad
		$ rsync -aAXxSiv bronpad/ doelpad
		OF
		$ rsync -aAXxSiv bronpad/ doelpad/
		- bestanden en alle submappen en submaptrees van bronpad/ komen in doelpad/
	- enkel submap, ZONDER eind-'/' : benoemde submapstructuur synchroniseren naar doelpad
		$ rsync -aASXxiv bronpad/submap doelpad
		OF
		$ rsync -aASXxiv bronpad/submap doelpad/
		- submap zelf, met bestanden en submaptrees, wordt gesynchroniseerd met of gecopiëerd als doelpad/submap

=== nakijken betrokken bronbestanden : 1 bron, en geen doel opgeven ===
	$ rsync -opties bron
	- Usages with just one SRC arg and no DEST arg will list the source files instead of copying

=== subtree van volledige pad synchroniseren met overeenkomende subtree in doel ===
	$ rsync -R -aAXxSiv pad/van/./sub/tree doel/
	- -R, --relative : Use relative paths. This means that the full path names specified on the command line are sent to the server rather than just the last parts of the filenames.
	- "./" invoegen om deelpad te markeren
	- inhoud van sub/tree in pad/van wordt gesynchroniseerd (vergelijken en kopieren) met doel/sub/tree

=== volledige backup with rsync ===
	- zie ook sectie "backup maken"
	# rsync [-n] [--delete] -aAXxSiv --exclude={"/dev/*","/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*", "/media/*", "/lost+found"} bron/ doel
	- OPGELET : bron/ MET eind-'/'
	- OPGELET : GEEN SPATIES in --exclude={dir1,dir2} voor bash brace expansion naar "--exclude=dir1 --exclude=dir2", dus met "=", en "," maar geen ", "
	- OPGELET : argumenten met "*" tussen quotes "" om globbing te voorkomen
		- globbing, oftewel "pathname expansion", zou dan wel zijn van b.v. "--exclude=/dir1*", dus waarschijnlijk geeft dat geen resultaat, maar met "shopt -s globstar" zou die expansie dan gewoon wegvallen, en dat kan nooit de bedoeling zijn.
	[-n, --dry-run] : perform a trial run with no changes made
	[--delete] : you may want to add this option if you are running this multiple times to the same backup folder. In this case make sure that the source path does not end with /*, or this option will only have effect on the files inside the subdirectories of the source directory, but it will have no effect on the files residing directly inside the source directory.
	-aAX : transfer in archive (-a) mode (zie hoger), to preserve symbolic links, devices, permissions, ownerships, modification times, and also ACLs (-A), and extended attributes (-X)
	-x, --one-file-system : (want linux/Ubuntu zelf mount her en der tmpfs en speciale bestandssystemen, die wil ik niet archiveren)
	-S, --sparse : handle sparse files efficiently
	-i, --itemize-changes : output a change-summary for all updates
	-v, --verbose : increase verbosity
	--exclude : /lost+found is filesystem-specific, /dev, /proc, /sys, /tmp, and /run are populated at boot, although the folders themselves are not created.
		- Ending the excluded paths with * ensures that the directories themselves are created if they do not already exist.
		 - OPGELET : tussen "", anders doet shell de wildcard expansion (globbing), en dan moet ge ofwel zowel * als .* opgeven voor elke map, ofwel vooraf "shopt -s dotglob" doen
		 - OPGELET : elk exclude pad beginnen met '/', om begin van de matching te verankeren op "bron/" (cfr. '^' bij regexp; anders matcht rsync het pattern om het even waar in het volledige pad van bestandsnamen)
	[--exclude={"/home/*","/util/*","/opt/*"}] om deze apart te backuppen
	- If you wish to restore the backup, use the same rsync command that was executed but with the source and destination reversed.
		- OPGELET : bij restore op andere schijf: /etc/fstab aanpassen, grub.cfg aanpassen of opnieuw genereren

=== enkel .java-bestanden van subtree kopieren naar ramdisk ===
	$ rsync -aAXxSivm --include='*/' --include='*.java' --include='*.JAVA' --exclude='*' /home/dirk/Documents/./java .
	 -m, --prune-empty-dirs : prune empty directory chains from file-list
	- include/exclude regels worden van links naar rechts toegepast, eerste match alleen
	- patterns met wildcards '*' en '?' worden gezocht per component van een volledig pad van een bestand/directory, zonder over '/' te springen
	- patterns met wildcard '**' worden gezocht over '/' in volledig pad heen
	- patterns die eindigen op '/' matchen enkel een directory
	- patterns die beginnen met '/' matchen enkel vanaf het begin van een component van een volledig pad
	- include/exclude patterns met / worden op directories toegepast
	- zonder --include='*/' (alle directories wel) zou --exclude='*' matchen op alle directories, en die samen met hun inhoud uitsluiten

=== vergelijken van verschillende backups ===

- b.v. verschillende kandidaten voor herstel vergelijken met origineel en met elkaar :
	# rsync -naiAX kandidaat1/ kandidaat2/
	-n		: no changes
	-a , --archive	: archive mode; equals -rlptgoD  (zie hoger)
	-A, --acls	: preserve ACLs (implies -p)
	-X, --xattrs	: preserve extended attributes
	-i		: itemize changes

=== volledig herstel van backup over nieuwe versie, met delete van bestanden in nieuwe versie die niet in backup stonden ===
	$ rsync -aAXxSi --delete backup/ huidige/
	- OPGELET : symbolic links in Samba network shares en VirtualBox shared folders zijn standaard beperkt of uitgeschakeld
		- zie sectie "symlinks volgen in Samba netwerk shares"
		- zie "_VirtualBox.txt" sectie "Symbolic links op shared folders"

== SCRIPTS SCHRIJVEN EN DEBUGGEN ==

=== elk tekstbestand kan een script bevatten ===
- is uit te voeren door de bestandsnaam als parameter van een shellopdracht te geven:
	OFWEL
	$ bash mijnscript.txt
	- voert de opdracht uit in een nieuwe bash shell, die niet interactief is en dus ~/.bashrc niet laadt
	OFWEL
	$ bash -i mijnscript.txt
	- voert de opdracht uit in een nieuwe interactieve bash shell, die dus ~/.bashrc wel laadt
	OFWEL
	$ . mijnscript.txt
	- . voert de opdracht uit in de huidige bash shell

=== uitvoerbaar maken met chmod ===
- kan dan zelfstandig uitgevoerd worden zonder shellopdracht; de default shell wordt dan gebruikt. Om een of andere reden moet dan wel het pad worden opgegeven, al is het maar ./ :
	OFWEL
	$ ./test.txt
	OFWEL
	$ [pad//test.txt
	- pad is noodzakelijk, al is het "./"

=== default shell ===

- in Ubuntu is bash de default shell voor interactief gebruik, zeg maar terminal, en dash (Debian Almquits Shell) voor opstarten. De Xubuntu-opdracht "xfce4-terminal -e %f --hold" (b.v. in Thunar custom action) geeft echter ander gedrag aan de shell. "If bash is invoked with the name sh, it tries to mimic the startup behavior of historical versions of sh as closely  as possible,  while conforming to the POSIX standard as well." Laat het script daarom best beginnen met de gewenste interpreter:
	"#!/bin/bash"
	- de ! na # in #! ('shebang') maakt er geen commentaarlijn van, maar een opdracht: gebruik DIE shell

- in systemrescuecd is zsh de default shell, maar bash kan opgestart worden
	# bash

=== welke shell voert script uit ===

- Ubuntu default shell :
	- bij opstarten : dash
	- interactieve terminal : bash
	- bij uitvoeren shell "sh" : dash

- beslissen welke shell het script moet uitvoeren
	- de shebang bepaalt welke binary default gekozen wordt om een script uit te voeren
		>>> #!/bin/bash <<<
		- dat hoeft zelfs geen shell te zijn :
		>>> #!/usr/bin/perl <<<
		- het volledige pad is niet nodig, wel aan te raden (b.v. hacker zou elders op pad een executable "perl" of "bash" kunnen zetten)
	- MAAR de shebang wordt enkel gekozen als het script executable is, en direct wordt uitgevoerd:
		$ ./test
	- shebang NIET gekozen, als impliciet of expliciet een shell wordt gebruikt om het script uit te voeren:
		- source invoeren in current shell :
			$ . ./test
		- source uitvoeren met default shell :
			$ sh ./test
		- source uitvoeren met bepaalde shell :
			$ dash ./test
			OF
			$ bash ./test

- testen welke shell effectief uitvoert :
	- simpele test of bash de shell is :
		>>> [ -n "$BASH_VERSION" ] || echo "Geen bash wegens -n" <<<
		- kan gefopt worden door gewoon zelf zo'n variabele een waarde te geven
		- niet testen met [ -v BASH_VERSION ], want "-v" zelf is al bash-specifiek
		- array variabele BASH_VERSION_INFO splitst die versie op, zie "man bash"
		- dash heeft niet zo'n variabelen om op te testen
	- betrouwbare test :
		>>> [ $(readlink /proc/$$/exe) = "/bin/bash" ] || echo "Geen bash volgens proc/\$\$/exe" <<<
		- "$$" is process-ID van uitvoerend process
		- /proc/process-ID/exe is symbolic link naar binary van process-ID
		- waarschijnlijk is /proc/self hetzelfde, maar natuurlijk is [ "$(realpath /proc/self/exe)" = "/usr/bin/realpath" ]

- tests uitgevoerd om dit te weten
	>>> script "test"
		#!/bin/bash
		echo bash versie $BASH_VERSION
		echo arg0 is $0
		echo -n "readlink zegt "
		readlink /proc/$$/exe
		[ -n "$BASH_VERSION" ] || echo "Geen bash wegens -n"
		[ -v BASH_VERSION ] || echo "Geen bash wegens -v"
	<<<
	- in bash, default interactieve shell van XUbuntu
		$ ./test
			bash versie 4.3.48(1)-release
			arg0 is ./test
			readlink zegt /bin/bash
		$ . ./test
			bash versie 4.3.48(1)-release
			arg0 is bash
			readlink zegt /bin/bash
		$ sh ./test
			bash versie
			arg0 is ./test
			readlink zegt /bin/dash
			Geen bash wegens -n
			./test: 7: [: -v: unexpected operator
			Geen bash wegens -v
		$ bash ./test
			bash versie 4.3.48(1)-release
			arg0 is ./test
			readlink zegt /bin/bash
		$ dash ./test
			bash versie
			arg0 is ./test
			readlink zegt /bin/dash
			Geen bash wegens -n
			./test: 7: [: -v: unexpected operator
			Geen bash wegens -v
	- in dash shell
		$ dash
		$ ./test
			bash versie 4.3.48(1)-release
			arg0 is ./test
			readlink zegt /bin/bash
		$ . ./test
			bash versie
			arg0 is sh
			readlink zegt /bin/dash
			Geen bash wegens -n
			sh: 7: [: -v: unexpected operator
			Geen bash wegens -v
		$ sh ./test
			bash versie
			arg0 is ./test
			readlink zegt /bin/dash
			Geen bash wegens -n
			./test: 7: [: -v: unexpected operator
			Geen bash wegens -v
		$ dash ./test
			bash versie
			arg0 is ./test
			readlink zegt /bin/dash
			Geen bash wegens -n
			./test: 7: [: -v: unexpected operator
			Geen bash wegens -v
		$ bash ./test
			bash versie 4.3.48(1)-release
			arg0 is ./test
			readlink zegt /bin/bash

=== trace van script tonen ===

- toon elke opdracht van een script op de terminal tijdens uitvoer (cfr. displays in een C-programma):
	$ bash -x mijnscript
	- elke opdracht van een pipeline wordt getoond

- toon elke opdracht van een sectie van script op terminal tijdens uitvoer (cfr. displays in een C-programma):
	- in het script volgende opdrachten opnemen rond die sectie:
		set -x
		#sectie met display van opdrachten
		set +x
	- de afsluitende "set +x" wordt ook getoond
	- set -f, set -o noglob : Disable file name generation using metacharacters (globbing).
	- set -v, set -o verbose : Prints shell input lines as they are read.
	- set -x, set -o xtrace : Print command traces before executing command.

=== script debuggen met de bash debugger ===
	$ bashdb mijnscript
	- "?" voor lijst van opdrachten
	- "help opdracht" voor hulp
	- "q" om af te sluiten

=== eigen map bepalen in het script ===
- zie https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within :
	zelfdir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

=== script beperken tot root ===

- een script moet niet uitvoerbaar zijn (chmod +x) om het te kunnen uitvoeren: in "bash scriptnaam" moet alleen bash uitvoerbaar zijn, en is scriptnaam gewoon een invoerbestand. Daarom moet ge soms in het script zelf testen of een root-gebruiker het uitvoert.

- bash (andere shells mogelijk niet) zet de variabelen UID en EUID (effective user id); in Ubuntu zijn die readonly, dus veilig, in andere OS mogelijk niet

- OPL. 1 : controle op uitvoer door roor :
	>>>
		if [ "$(id -u)" -ne 0 ]
		then
			echo 'This script must be run by root' >&2
			exit 1
		fi
	<<<<
	- OPM : dit is niet zomaar te testen met sudo op de commandolijn, omdat bash de $()-expansie doet voor sudo wordt aangeroepen :
		$ id -u
		 >>> 1000
		$ sudo id -u
		 >>> 0
		$ echo $(id -u)
		 >>> 1000
		$ sudo echo $(id -u)
		 >>> 1000
		$ bash -c 'echo $(id -u)'
		 >>> 1000
		$ sudo bash -c 'echo $(id -u)'
		 >>> 0

- OPL. 2 : script herstart zichzelf als root
	>>>
		# display user, mag weg na test
		echo "$(whoami)"
		# als niet root, herstart als root met sudo
		[ "$UID" -eq 0 ] || exec sudo "$0" "$@"
	<<<
	- zie ook sectie "redirect password naar sudo"
	
=== loop over lijnen van tekstbestand ===
	$ while read woord1 woord2 ... ; do echo $woord1 $woord2 ... ; done < tekst.txt
	- woord1 ... : variabelen waarin de woorden van een lijn uit tekst.txt gelezen worden; default $REPLY. The characters in IFS are used to split the line into words using the same rules the shell uses for expansion
	- als lijn in tekst.txt meer woorden bevat dan opgegeven voor read, dan komt rest in laatste woord#
	- andere read opties :
		-a arrayname : woorden in array i.p.v. benoemde variabelen
		-d delimchar : t.b.v. opsplitsen tekst.txt in lijnen, default newline
		-r : lees backslash niet als escape (i.e. \LF is geen vervolglijn)
		-e : (enkel interactief) gebruik readline
		-i default : (enkel met readline) zet "default" al in input buffer, en toont die
		-p prompt : (enkel met readline) toont prompt
		-n ## : leest ## chars, of hele lijn als die korter is
		-N ## : leest ## chars
	- voorbeeld :
	>>> flc2mp3.cfg
		2 "doel1.mp3" "1ste bestand.flac" "2de bestand.flac" "3de bestand.flac"
		3 "doel2.mp3" "4de bestand.flac" "5de bestand.flac"
	<<<
	$ while read kwal mp3 flacs ; do echo Q=$kwal ; echo MP3=$mp3 ; echo FLC=$flacs ; done < flc2mp3.cfg
	>>>
		Q=2
		MP3="doel1.mp3"
		FLC="1ste bestand.flac" "2de bestand.flac" "3de bestand.flac"
		Q=3
		MP3="doel2.mp3"
		FLC="4de bestand.flac" "5de bestand.flac"
	<<<

=== menu maken met select ===
	$ PS3="prompt voor select-menukeuze"
	- default leeg
	- PS3 behandelt geen escapes, dus zonder truukje geen kleuren, piepen, bold, ...
		- truukje :
			$ vet=$(tput smso) vetuit=$(tput rmso)
			$ PS3="${vet}Kies${vetuit} het nummer van ... : "
	$ select var in EINDE [value1]... ; do if [ "$var" = "EINDE" ] ; then exit; if [ -z "$var" ] ; then echo "keuze is niet geldig" else echo $var; break; fi; done
	- toont de menukeuzes in kolommen, met een volgnr. i ervoor
	- aantal kolommen is afh. van de variable COLUMNS, die gezet wordt in een terminal, maar niet (altijd?) bij het uitvoeren van een shellscript. Zelf zetten in het script als volgt:
		$ [[ -v COLUMNS ]] || COLUMNS=$(tput cols)
	- bij enter zonder keuze wordt het menu ververst, zonder in de do-loop te komen
	- bij enter met iets ingetikt, wordt de keuze verwerkt in de do-loop; moeten zelf "break"-opdracht uitvoeren om de loop te beeindigen, maar select-lijst wordt niet opnieuw geprint
		- bij enter van geldig keuzenr heeft $var de overeenkomede waarde uit de select-lijst, en $REPLY het ingetikte nummer
		- bij enter van ongeldige waarde heeft var de waarde null, "$var" = "", en $REPLY het ingetikte
	- EINDE is een zelfgekozen naam voor een laatste menukeuze die het afbreken wat gebruikvriendelijker maakt (anders Ctrl-C, in sommige gevallen Ctrl-Z)
	- select is een 'shell builtin command', en komt op een andere plaats dan andere commando's in de parsing van een opdrachtlijn. Daardoor kunnen de menukeuzes [value1]... enkel blanco's bevatten in de volgende gevallen :
		- tussen ""
		- door globbing
	- VOORBEELDEN:
		$ select optie in EINDE "eerste optie" "tweede optie" ...
		- literal opties tussen "" kunnen spaties bevatten
		OF
		$ opties=("optie 1" "optie 2")
		$ select optie in EINDE "${opties[@]}" ...
		OF
		$ select bestand in EINDE ./*.jpg ...
		- opties t.g.v. shell globbing kunnen spaties bevatten
		- GEEN SPATIES bij enig ander voorbeeld :
		- voor een ononderbroken array opties ([0], [1], ...) is ook $REPLY nuttig, het gekozen volgnr. van de menukeuze
		$ select optie in EINDE $(ls globbingpattern) ...
		- GEEN SPATIES mogelijk:
			- niet met $(ls -Q globbingpattern)
				-Q, --quote-name
			- niet met $(ls -Q --quoting-style=shell globbingpattern)
				- met geen enkele van word=: literal, locale, shell, shell-always, shell-escape, shell-escape-always, c, escape
			- niet met $(find ...) i.p.v. $(ls ...)

=== menus maken met het dialog-commando ===
	- volgorde van argumenten heeft zijn belang, in groepen: eerst algemene opties, dan boxopties (dan widgetopties?)
	- let op de pipe, lijkt nodig om het menu zichtbaar te maken : " 2>&1 >/dev/tty"
	- VOORBEELD kiezen uit inhoud van een directory
	$ KEUZE=$(dialog --clear --fselect "/pad/[defaultkeuze]" $HEIGHT $WIDTH 2>&1 >/dev/tty)
	- --clear : maakt het scherm leeg na keuze
	- --fselect : keuze uit bestanden in een directory
	- --dselect : keuze uit directories in een directory
	- [defaultkeuze] (OPGELET: zonder eind-'/') wordt voorgeselecteerd in het menu, kan globbing wildcards bevatten, maar die bepalen NIET welke bestanden/directories getoond worden en gekozen kunnen worden
	- KEUZE bevat wat in het invoerveld onderaan staat. Een bestands/directorynaam uit de lijst met de spatiebalk naar dat invoerveld kopiëren
	- navigeren naar andere mappen (ook  '.' en '..') kan door ze te selectern naar het invoerveld en er een / achter te typen
	- ook leuk: --backtitle "venstertitel" --title "menutitel"
	- VOORBEELD kiezen uit een lijst (array of literal) van even lengte: "label1" "omschrijving1" ...
	$ OPTIES=("label 1" "Uitleg 1" "Label 2" "Uitleg 2")
	$ KEUZE=$(dialog --clear --menu "menuprompt" $HEIGHT $WIDTH $LIJSTHOOGTE "${OPTIES[@]}" 2>&1 >/dev/tty)
	- KEUZE bevat het gekozen label

=== menu-maatwerk met 'ls' voor lijst van bestanden of directories, en 'read' om 1 te kiezen met autocompletion ===
	- vanwege autocompletion enkel werkbaar in de working directory waar die bestanden/directories staan
	- zelf een loop scripten, met daarin
		- voor bestanden:
			$ ls -C globbingpattern
			- -C : list entries by columns
		- voor directories:
			$ ls -Cd globbingpattern\
			- -d, --directory : list directories themselves, not their contents
		$ read -ep "mijn prompt: " var
		- -e : doe autocompletion ("use Readline to obtain the line in an interactive shell")
		- -p : een prompt
		- $var bevat de ingevoerde waarde voor het menu-script

=== here-document ===

- gebruikt here-document (met naam HERE-DOCUMENT) om sommige bestanden te maken :
	- begin :
		<<naam
		OF
		<<-naam : alle voorlooptabs worden verwijderd (handig voor indendatie)
		OF
		<<'naam' : omgevingsveranderlijken in tekst here-document worden niet vervangen (anders dus WEL)
	- gevolgd door lijnen met tekstinhoud van het document
	- afgesloten door lijn met de naam herhaald (zonder blanks of tabs voor noch na):
		naam
	- als naam, noch om het even welke letters ervan, niet tussen '' of "" staat, dan gebeuren in het hele here-document parameter expansion, command substitution, en arithmetic expansion, the character sequence \<newline> is ignored, and \ must be used to quote the characters \, $, and `. Als naam tussen quotes staat, niet; naam zelf ondergaat dan wel quote removal

- voorbeeld van here-document met de naam "HERE-DOCUMENT", met pipe naar bestand :
	cat <<-einde_heredoc > doelbestand
		een lijn
		en nog een
		...
		laatste lijn is die waarna de naam "HERE-DOCUMENT" herhaald wordt
	einde_heredoc

==== block comment in shell script ====

- linux shells kennen meestal alleen lijn-commentaar, met '#' als commentaarteken; formattering van lijncommentaar wordt door b.v. geany niet ondersteund, enkel fold/unfold van opeenvolgende lijnen die met # beginnen. Met een here-document is hieraan te verhelpen, b.v. :
	: <<'BLOCKCOM'
		dit is vrije tekst
BLOCKCOM
	- man bash
	>>> : [arguments] : No effect; the command does nothing beyond expanding arguments and performing any specified redirections. A zero exit code is returned.	<<<
	- 'BLOCKCOM', om geen $-expansies e.d. te doen in de commentaar; b.v. voorbeelden van command substitution zouden neveneffecten hebben.
	- de ":" en de tekst mogen vrij inspringen, de afsluitende marker (b.v. BLOCKCOM) moet wel op kolom 0 staan (tenzij de redirectoperator "<<-" is i.p.v. "<<" is)
	- andere toegelaten here-doc namen zijn b.v. '#', '##', '_', '/**' (helaas dan ook afsluiten met /**, niet met */)

- hightech help-display :
	- gebruik evt. de redirectoperator "<<-" is i.p.v. "<<", om voorloop-tabs te verwijderen als die geen betekenis hebben (alleen dienen om het script zelf leesbaar te maken)
	- redirect naar een if-statement i.p.v. naar de dummy opdracht ":"
	- voorbeeld:
		if [[ "-h" = "$1" || "--help" = "$1" ]]
		then cat;exit
		else :
		fi <<-'_'
			dit is helptekst
		_
	- ik weet niet waarom het here-document bij de cat terechtkomt, i.p.v. bij de exit

=== script maar 1 keer uitvoeren ===

- de flock-opdracht laat de uitvoering van een simpel commando ervan afhangen of een lock op een bestand kan gekregen worden.
	- met argument -c "samengesteld commando" kan een moeilijker commando uitgevoerd worden (vgl. "bash -c 'commandos'"); helaas is het moeilijk (kan het uberhaupt) om argumenten tussen "" door te geven aan dat commando

- complexe scripts kunnen met 1 extra lijn vooraan ge-flocked worden als volgt :
	- niet uitvoeren als ander proces dit script al uitvoert :
		- vooraan script deze lijn toevoegen
		>>>
		[ "${mijnFlockEnvVar}" != "$0" ] && exec env mijnFlockEnvVar="$0" flock -n "$0" "$0" "$@" || :
		<<<
		- zie "man flock" laatste vb.
		- mijnFlockEnvVar != "$0" en ="$0" : mag ook andere waarde zijn
		- exec : Execute following command, replacing this shell with the specified program; If the command cannot be executed, a non-interactive shell exits.
		- env - run a program in a modified environment
		- flock -n, --nb, --nonblock : Fail rather than wait if the lock cannot be immediately acquired.
		- flock "$0" : (1ste $0) zet file lock op "$0", het huidige commando (moet dus executable script zijn, niet uitvoeren met "bash scriptnaam")
		- flock "$0" "$@" : (2de $0) roept het script terug aan, met dezelfde argumenten in ""
		- ":" : bash built-in dummy command, return value 0
			- OPM: ik weet niet waarom (en of) dat er bij moet
	- wachten als ander proces dit script al uitvoert :
		- vooraan script deze lijn toevoegen
		>>>
		[ "${mijnFlockEnvVar}" != "$0" ] && exec env mijnFlockEnvVar="$0" flock "$0" "$0" "$@" || :
		<<<
		- enige verschil met vorige script : flock zonder "-n"
		- evt. flock [-w nn] : als het script in dit proces na nn seconden nog niet aan de beurt komt, afbreken
	- verschillende script zo synchroniseren : een gemeenschappelijk lock-bestand gebruiken i.p.v. elk zichzelf ("$0"), b.v.
		- vooraan script deze lijnen toevoegen
		>>>
		onsLockBestand=/var/lock/onslockbestand
		[ "${mijnFlockEnvVar}" != "$onsLockBestand" ] && exec env mijnFlockEnvVar="$onsLockBestand" flock "$onsLockBestand" "$0" "$@" || :
		<<<
		- /var/lock is in Ubuntu een link naar een tmpfs op /run/lock

=== functies, argumenten, return value en spaties daarin ===

- argumenten voor een functie zijn strings, zoals argumenten voor een shell script vanop de opdrachtlijn
	- in de functie : "$1", "$2", ... of "$@"
	- $0 is naam van script of shell
	- om spaties te bewaren, argumenten zowel bij aanroep van als bij gebruik in functie tss. ""
	
- de return value van een functie is de return code van de laatste opdracht, een getal van 0 tot 255 (cfr. de exit code van een binary)
	- als tijdens het uitvoeren van de functie een return-opdracht wordt tegengekomen, is dat de laatste opdracht; het (numerieke) argument van de return-opdracht (default 0) is ook haar return code, en dus die van de functie
	- bereikbaar als de expansie van "$?"
	- bij tests daarop is 0 true, al de rest false.

- een functie kan andere informatie doorgeven aan de aanroeper via
	- variabelen : als die niet als 'local' worden gedeclareerd in de functie, zijn ze toegankelijk voor de aanroeper
	- stdout, b.v. met de opdracht "echo" en bash command substition, b.v.
		$ resultaat=$(functie argument...)
			- de command subsitution behoudt evt. spaties zonder dat er "" rondstaan, zodat elk argument tussen "" kan
		$ [ -n "$(functie argument...)" ]
			- de command substition MOET tss. "", of ze wordt aan de spaties opgesplitst in woorden; als we argumenten met spaties willen gebruiken, moet het resultaat van de command substitution eerst in een variabele worden bewaard
		- bij gebruik van het resultaat moeten er wel "" rond om spaties te behouden
	- voorbeeld :
			$ keepspaces() { echo "$1"; }
			$ spaceskept=$(keepspaces "1 2  3   spaces")
			$ echo "$spaceskept"
			>>> 1 2  3   spaces <<<

- $@ is de array van argumenten van aangeroepen script of functie

- een array is niet toegelaten als functie-argument; expansie tss. "" kan wel door aangeroepene in array gezet worden :
	>>> ./test.sh
		#!/bin/bash
		function copyFiles() {
		   local arr=("$@")
		   echo "function ${#arr[@]} elements : ${arr[@]}"
		   for i in "${arr[@]}"
		   do
			   echo ">$i<"
		   done
		}
		echo "script   ${#@} elements : $@"
		copyFiles "$@"
	<<<
	$ ./test.sh  A "B C D" "  Double  Spaced  "
	>>>
		script   3 elements : A B C D   Double  Spaced  
		function 3 elements : A B C D   Double  Spaced  
		>A<
		>B C D<
		>  Double  Spaced  <
	<<<
	
=== echo naar stderr ===

- redirects mogen overal staan, b.v. in het begin maakt het heel leesbaar
	$ >&2 echo "error"

=== redirect ===

- zie "http://wiki.bash-hackers.org/howto/redirection_tutorial"

- stdin, stdout en stder zijn respectief file descriptors 0, 1 en 2 van een door bash gesimuleerde terminal, /dev/pts/#. Met "stat" kunt ge wel de verwijzing naar die terminal zien, maar niet welke 'poort' :
	$ stat -c %N /proc/self/fd/[012]
	>>>
		'/proc/self/fd/0' -> '/dev/pts/6'
		'/proc/self/fd/1' -> '/dev/pts/6'
		'/proc/self/fd/2' -> '/dev/pts/6'
	<<<
	- elke gelijktijdige bash shell heeft een ander pts-nummer
- de redirect "2>&1" kopieert de file descriptor van 2 naar 1, zodat die beide naar dezelfde 'poort' van die terminal schrijven
	- dit is niet zichtbaar in stat
		$ 2>&1 stat -c %N /proc/self/fd/[012]
			>>>
			'/proc/self/fd/0' -> '/dev/pts/6'
			'/proc/self/fd/1' -> '/dev/pts/6'
			'/proc/self/fd/2' -> '/dev/pts/6'
			<<<
- de redirect "2>bestand" verandert de verwijzing van fd 2: die gaat nu naar bestand
	$ 2>/tmp/mijnstderr stat -c %N /proc/self/fd/[012]
		>>>
		'/proc/self/fd/0' -> '/dev/pts/3'
		'/proc/self/fd/1' -> '/dev/pts/3'
		'/proc/self/fd/2' -> '/tmp/mijnstderr'
		<<<
- de redirect "1>bestand" of ">bestand" doet hetzelfde met fd 1: die gaat nu naar bestand
	$ 1>/tmp/mijnstdout stat -c %N /proc/self/fd/[012]
		>>>
		'/proc/self/fd/0' -> '/dev/pts/8'
		'/proc/self/fd/1' -> '/tmp/mijnstdout'
		'/proc/self/fd/2' -> '/dev/pts/8'
		<<<
- de redirect "0<bestand" of "<bestand" doet hetzelfde met fd 0, maar voor invoer: die komt nu van bestand
	$ 0</tmp/mijnstdin stat -c %N /proc/self/fd/[012]
		>>>
		'/proc/self/fd/0' -> '/tmp/mijnstdin'
		'/proc/self/fd/1' -> '/dev/pts/7'
		'/proc/self/fd/2' -> '/dev/pts/7'
		<<<
- een pipe, naar b.v. grep, verandert de verwijzing van fd 1 :
	$ stat -c %N /proc/self/fd/[012] | grep -
		>>>
		'/proc/self/fd/0' -> '/dev/pts/6'
		'/proc/self/fd/1' -> 'pipe:[258096]'
		'/proc/self/fd/2' -> '/dev/pts/6'
		<<<
- een pipe, samen met de redirect "2>&1" doet dit voor fd 2 en fd 1
	$ 2>&1 stat -c %N /proc/self/fd/[012] | grep -
		>>>
		'/proc/self/fd/0' -> '/dev/pts/9'
		'/proc/self/fd/1' -> 'pipe:[258098]'
		'/proc/self/fd/2' -> 'pipe:[258098]'
		<<<
- redirects zijn volgorde-gevoelig :
	- als ge VOOR "2>&1" ook een redirect van fd 1 doet, gaan ze beide naar de nieuwe bestemming van fd1 :
		- cfr. het voorbeeld "een pipe, samen met de redirect "2>&1""
		$  1>/tmp/mijnstdout 2>&1 stat -c %N /proc/self/fd/[012]
			>>>
			<<<
		$ cat /tmp/mijnstdout
			>>>
			'/proc/self/fd/0' -> '/dev/pts/7'
			'/proc/self/fd/1' -> '/tmp/mijnstdout'
			'/proc/self/fd/2' -> '/tmp/mijnstdout'
			<<<
	- als ge NA "2>&1" ook een redirect van fd 1 doet, blijft 2 uitvoeren naar de oorspronkelijke bestemming van fd1, terwijl fd2 naar de nieuwe gaat :
		$ 2>&1 1>/tmp/mijnstdout stat -c %N /proc/self/fd/[012]
			>>>
			<<<
		$ cat /tmp/mijnstdout
			>>>
			'/proc/self/fd/0' -> '/dev/pts/7'
			'/proc/self/fd/1' -> '/tmp/mijnstdout'
			'/proc/self/fd/2' -> '/dev/pts/7'
			<<<

==== exec met redirect ====

- exec also allow us to manipulate the file descriptors. If you don't specify a program, the redirection after exec modifies the file descriptors of the current shell:
	$ exec 2>/tmp/exec-stderr
	[ $ stat -c %N /proc/self/fd/[012] ]
		- opdrachtlijn is onzichtbaar, die komt blijkbaar via stderr op het scherm, en nu dus niet; stdin en stdout zijn onaangeroerd :
		>>>
		'/proc/self/fd/0' -> '/dev/pts/8'
		'/proc/self/fd/1' -> '/dev/pts/8'
		'/proc/self/fd/2' -> '/tmp/exec-stderr'
		<<<
	[ $ exit ]
	$ cat /tmp/exec-stderr
		>>>
		$ stat -c %N /proc/self/fd/[012]
		$ exit
		exit
		<<<


All the the errors sent to stderr by the commands after the exec 2>file will go to the file, just as if you had the command in a script and ran myscript 2>file.

exec can be used, if, for instance, you want to log the errors the commands in your script produce, just add exec 2>myscript.errors at the beginning of your script. 

=== redirect password naar sudo ====

- sudo bestuurt zelf terminal voor invoer paswoord; met optie -S wordt paswoord echter vanstdin gelezen

- whiptail (alternatief "dialog") toont mooie textmode invoerpopups voor interactie vanuit scripts
	- om nog uit te zoeken reden voert onderstaande opdracht zonder "sudo -k" vooraf, al direct de "sudo -S ..." uit als sudo-credentials nog in cache zitten
	$ sudo -k;echo "$(whiptail --title "SUDO WACHTWOORD" --passwordbox "sudo wachtwoord: " 10 50  3>&1 1>&2 2>&3-)" | sudo -S ls -al /root
		- sudo -k : sudo credentials vergeten
		- 3>&1 1>&2 2>&3- : whiptail zet resultaat in stderr, deze truk wisselt stderr met stdout :
			- 3>&1 : opent een fd (file descriptor 3), als kopie van 1 (stdout)
			- 1>&2 : kopieert de fd van 2 (sterr) naar 1 (stdout)
			- 2>&3- : kopieert de fd van 3 (originele stdout) naar 2 (stderr), en sluit 3
		- sudo -S : prompt op stderr zoals gebruikelijk, maar input van stdin i.p.v. via terminal

== PROGRAMMEREN ==

=== C compileren en linken ===
	$ gcc -o test test.c
	-o test : naam uitvoerbestand (is direct ook uitvoerbaar)

=== assembler maken van C ===
	$ gcc -Wa,-adhln -masm=intel -g test.c > /media/ramdisk/test.asm
	-Wa,-options: Pass options to the assembler :
		a: turn on listings
		d: omit debugging directives;
		h: include high-level source
		l: include assembly
		n: omit forms processing
	-masm=intel : assembler min of meer in Intel MASM formaat (anders GAS Gnu Assembler)
	-g: Produce debugging information

=== alleen preprocessor laten lopen ===
	$ cpp test.c > /media/ramdisk/test.c.c

=== C stacktrace krijgen van crashend programma ===
	- met gdb (GNU debug) het programma laten lopen, en hopen dat het terug crasht
	$ gdb programma
	(gdb) run
	(gdb) backtrace

== ONDERHOUD ==

=== repositories (ppa) ===

- dpkg beheert de database van packages voor Debian, en installeert ze van verschillende bronnen (repositories) naargelang prioriteiten

- apt, apt-get en apt-cache zijn frontends voor dpkg; ze bekijken ook de afhankelijkheden tussen packages
	- ppa repositories voor Ubuntu zelf worden bewaard in
		/etc/apt/sources.list
	- bijkomende ppa repositories best per leverancier apart in :
		/etc/apt/sources.list.d/%leverancier%.list

- sommige ontwikkelaars onderhouden een eigen repository met packages, volg de instructies aldaar

- Canonical biedt op "https://launchpad.net/" een plek, waar iedereen eigen repositories kan bijhouden: Personal Package Archive (PPA)
	- ZIE ook "Add launchpad PPA repository to Ubuntu.txt"
	- de gekozen broncode wordt door launchpad gecompileerd voor verschillende versies van Ubuntu. Dat wordt gepubliceerd in een ppa (personal package archive) repository.

- 4 manieren om repositories toe te voegen:
	- launchpad repo's : add-apt-repository
		- voegt ook ineens de verificatiesleutel toe
		- maakt zoals het hoort een apart .list-bestand in /etc/apt/sources.list.d
		0 Make sure you have the following python utility installed :
			0 apt-get install python-software-properties
		# add-apt-repository ppa:[USERNAME]/[REPOSITORY NAME]
		b.v. # add-apt-repository ppa:semiosis/ubuntu-glusterfs-3.4
	- andere methodes : eerst verificatiesleutel toevoegen vb.:
		OFWEL met de hand vanop launchpad
			- "Signing key" XXXXXX (zonder de prefix b.v. "1024R/") kopiëren van repository-webpagina van launchpad, na de hoofding "Technical details about this PPA", en dan
			$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys XXXXXX
		OFWEL van url naar keybestand op website ontwikkelaar
			$ wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -
			-q : quiet
			-O- : naar stdout
		OFWEL idem met curl (alternatief voor wget)
			$ curl -L https://www.virtualbox.org/download/oracle_vbox_2016.asc | sudo apt-key add -
			-L : volg redirect van evt. http-300 response
	- met 'Settings/Software & updates/other software'
		- ALTIJD verificatiesleutel toevoegen : zie hierboven
		- hiermee kunnen repositories ook tijdelijk disabled worden: worden dan uitgecommentariëerd in hun sources.list.d/repo.list
	- repo in eigen .list-bestand (extensie .list vereist) in /etc/apt/sources.list.d/REPONAAM.list :
		- syntax zie repository-webpagina van launchpad, na de hoofding "Technical details about this PPA"
			$ man sources.list
		- formaat "deb URL UBUNTU-VERSIE suite component..." of "deb-src ..."
			- suite : "xenial", "xenial-updates", ...
			- component : main, universe, contrib, ...
		- lijnen met "# deb" zijn niet actief, kunnen met 'Settings/Software & updates/other software' of met editor geactiveerd worden
		- andere commentaarlijnen gewoon beginnen met "##" of "#"
			- b.v. sourcecode repo kan al direct inactief toegevoegd worden voor evt. latere activatie
		- ALTIJD verificatiesleutel toevoegen : zie hierboven
		- .list-bestand maken :
			OFWEL met echo :
				# echo "deb http://download.virtualbox.org/virtualbox/debian xenial contrib" > /etc/apt/sources.list.d/oraclevirtualbox.list
			OFWEL met een editor:
				- OPGELET: altijd eindigen met een new-line, anders lopen de andere manieren mis
				>>> # mousepad /etc/apt/sources.list.d/virtualbox.lst
					deb http://download.virtualbox.org/virtualbox/debian xenial contrib
				<<<
		- ALTIJD :
			$ sudo apt update
			- uitvoer nakijken, bij fouten 2de keer proberen
	0 AFGERADEN : alle repo's samen in /etc/apt/sources.list
		0 echo "deb http://download.virtualbox.org/virtualbox/debian xenial contrib" > /etc/apt/sources.list

- als ge een ppa repository gebruikt om 'voor te lopen' op Ubuntu-ondersteunde updates van een programma, kan dat mislopen. Ge kunt dan de oudere, wel ondersteunde versie installeren als volgt, met ppa-purge :
	# apt-get install ppa-purge
	- ppa-purge moet natuurlijk maar 1 keer geïnstalleerd worden
	# ppa-purge ppa:otto-kesselgulasch/gimp-edge

- bij upgrade van ubuntu worden alle externe ppa’s and third-party repositories uitgeschakeld; na upgrade elk apart terug aanklikken in Software & Updates
	- ppa's behouden door een cfg-file aan te maken in /etc/update/update-manager/release-upgrades.d
		>>> https://support.system76.com/articles/ppa-third-party/
			There are two ways to tell update-manager to keep PPAs enabled. For both, create a file in /etc/update-manager/release-upgrades.d/ with a .cfg extension. You should give it a descriptive and unique name since other packages may provide their own config files. Users who want to keep all PPAs/repos enabled can put the following into that .cfg file:
				[Sources]
				AllowThirdParty = yes
			To keep one specific ppa/repo enabled, create a key = value pair inside a [ThirdPartyMirrors] section:
				[ThirdPartyMirrors]
				myppa = http://ppa.launchpad.net/myppa/stable/ubuntu/
			The key 'myppa' can be any string that is unique within the section. The value is the url of the ppa you want to keep enabled. You can find this url in the .list file for the PPA, which can be found in /etc/apt/sources.list.d/
		<<<

- voorbeeld : development versies van gimp installeren via ppa :
	# add-apt-repository [-r] [-s] ppa:otto-kesselgulasch/gimp-edge
	-r, --remove :			Remove the specified repository
	-s, --enable-source :	Allow downloading of the source packages from the repository (om zelf te compileren)
	- ppa:otto-kesselgulasch/gimp-edge : ppa van user otto-kesselgulasch voor programma gimp-edge
	# apt-get update
	# apt-get install gimp

==== info van package ====

- geinstalleerde en beschikbare versies, en hun repository
	$ apt-cache policy packagenaam
- info zoals in USC (Ubuntu Software Center)
	$ apt-cache show packagenaam
- dependencies (andere packages nodig voor packagenaam)
	$ apt-cache depends packagenaam
- reverse dependencies (nodig voor welke andere packages)
	$ apt-cache rdepends packagenaam
- beschikbare versies en (reverse) dependencies
	$ apt-cache showpkg packagenaam
	
==== lijst van alle definieerde repositories (ppa) ===
	$ grep -vrhE "^[ \t]*(#.*| *)$" --include "*.list" /etc/apt/sources.list /etc/apt/sources.list.d/*  | sort -u
	- zie sectie "cat zonder commentaar en lege lijnen"
	[-h] : print zonder bestandsnaam

==== lijst van packages uit niet-officiele repository ====
- selecteert (ruw script) packages die van elders dan http://[archive|security].[ubuntu|canonical].com/ geinstalleerd zijn/kunnen worden :
	$ bash ~/bin/ppa-installed.sh

==== Which PPA Repository A Package Belongs To ====
	$ apt-cache policy package_name
		- heeft bash completion (tab)
		- zie https://web.archive.org/web/20121024134944/http://carlo17.home.xs4all.nl/howto/debian.html
		>>> apt-cache policy package_name
		A general output would be:
				package-name:
				  Installed: <installed-version>
				  Candidate: <version-installed-when-doing-apt-get-upgrade>
				  Package-Pin: <version-of-Pin-in-etc-apt-preferences>
				  Version table:
				 *** <some-version> <minimum-priority-to-consider>
					   <priority-of-this-instance> <repository1>
					   <priority-of-this-instance> <repository2>
				 *** <some-other-version> <minimum-priority-to-consider>
					   <priority-of-this-instance> <repository3>
					   <priority-of-this-instance> <repository4>
		<<<
		- b.v.
		>>> $ apt-cache policy samba
			samba:
			  Installed: 2:4.3.11+dfsg-0ubuntu0.16.04.11
			  Candidate: 2:4.3.11+dfsg-0ubuntu0.16.04.16
			  Version table:
				 2:4.3.11+dfsg-0ubuntu0.16.04.16 500
					500 http://archive.ubuntu.com/ubuntu xenial-updates/main amd64 Packages
				 2:4.3.11+dfsg-0ubuntu0.16.04.15 500
					500 http://security.ubuntu.com/ubuntu xenial-security/main amd64 Packages
				 2:4.3.11+dfsg-0ubuntu0.16.04.12+lliurex1 500
					500 http://ppa.launchpad.net/llxdev/xenial/ubuntu xenial/main amd64 Packages
			 *** 2:4.3.11+dfsg-0ubuntu0.16.04.11 100
					100 /var/lib/dpkg/status
				 2:4.3.8+dfsg-0ubuntu1 500
					500 http://archive.ubuntu.com/ubuntu xenial/main amd64 Packages

			The /var/lib/dpkg/status stands for the installed package. The highest priority is thus 1000 for the (local) repository ./ (as we listed in the sources.list file).
		<<<
		- *** duidt de geinstalleerde versie aan, en zijn bron eronder
		- de 100 en 500 zijn prioriteiten : 500 installable, 100 installed
		- /var/lib/dpkg/status

=== apt of apt-get? ===

- apt voor commandolijn : is gebruiksvriendelijk, maar 'man apt' toont niet alle mogelijke opties
- apt-get voor scripts : heeft stabiele syntax, meer opties, en is ook vollediger gedocumenteerd

- NOOT : "axi-cache search" is een betere vervanger voor "apt search" en "apt-cache search"

>>> man-page apt(8):
	The `apt` command is meant to be pleasant for end users and does not need to be backward compatible like apt-get(8). Take a look at this post for more information on the new tool: http://mvogt.wordpress.com/2014/04/04/apt-1-0/
	A synopsis of the above link
		The big news for this version is that we included a new “apt” binary that combines the most commonly used commands from apt-get and apt-cache. The commands are the same as their apt-get/apt-cache counterparts but with slightly different configuration options.

	Currently the apt binary supports the following commands:
		list: which is similar to dpkg list and can be used with flags like --installed or --upgradable.
		search: works just like apt-cache search but sorted alphabetically.
		show: works like apt-cache show but hide some details that people are less likely to care about (like the hashes). The full record is still available via apt-cache show of course.
		update: just like the regular apt-get update with color output enabled.
		install,remove: adds progress output during the dpkg run.
		upgrade: the same as apt-get dist-upgrade -with-new-pkgs.
		full-upgrade: a more meaningful name for dist-upgrade.
		edit-sources: edit sources.list using $EDITOR.
<<<

=== apt[-get] update niet blind gebruiken ===

- "apt[-get] update" installeert niets, werkt alleen de database bij van wat beschikbaar is in de repositories

- dikwijls vindt ge commando's zoals
	0 sudo apt update && apt-install ...
 maar soms geeft update belangwekkende waarschuwingen (met of zonder foutcode?) die ge eerst wilt oplossen. Dikwijls moet ge daarvoor gewoon update een 2de keer uitvoeren. Dus :
	# apt update
	[# apt update]
	# apt-install ...

=== apt cache opruimen ===

- apt wordt geconfigureerd in /etc/apt/apt.conf.d
	- ondervragen :
		# apt-config dump
		- b.v. enkel cache-instellingen:
			# apt-config dump | grep "^Dir\( \|::Cache\)"
		
- apt houdt lijst bij van wat repositories beschikbaar hebben in /var/lib/apt/lists
	- best afblijven, ook al is het 232MB

- apt houdt index van beschikbare gedownloade *.deb-installatiepakketten bij in /var/cache
	- /var/cache/apt/pkgcache.bin en /var/cache/apt/srcpkgcache.bin : ±100MB
		- lookup cache voor packages en source packages
		- mag verwijderd worden, worden opnieuw gemaakt bij opstarten en bij 'apt update'
		- definitief uitschakelen (apt-bewerkingen duren dan wat langer) :
			$ echo -e 'Dir::Cache::pkgcache "";\nDir::Cache::srcpkgcache "";' | sudo tee /etc/apt/apt.conf.d/00_geen_lookupfiles_cache
	- /var/cache/apt/archives/
		- bevat .deb, een lock-file, en een directory "partial" voor downloads die bezig zijn
		- kan zeker na een dist-upgrade 2GB groot zijn
		- mag symlink naar andere locatie zijn, maar met volledige rechten voor root
			- dus opgelet met netwerkschijven en VM shared folder
			- anders fouten zoals "chown to _apt:root of directory /var/cache/apt/archives/partial failed"
		- definitief uitschakelen :
			$ echo -e 'Dir::Cache "";\nDir::Cache::archives "";' | sudo tee /etc/apt/apt.conf.d/00_geen_packages_cache
			- worden opnieuw gedownload wanneer ze nodig zijn, b.v. mislukte installatie, of remove en toch terug installeren
		- volledig leegmaken (als geen apt* bezig is) :
			# apt-get clean
		- alleen verouderde weggooien :
			# apt-get autoclean
	>>> https://www.unixtutorial.org/ubuntu-clean-apt-cache/
		APT (Advanced Package Tool) keeps a cache of previously downloaded and installed packages even after they've been uninstalled. To save disk space the apt cache can be cleaned. This can be done in one of two ways. First will do it partially:
			# apt-get autoclean
		This command will remove only the outdated packages, like those superseded by a recent update, making them completely unnecessary. This may free up some disk space, but if you want to clean out the cache in its entirety you would run:
			# apt-get clean
		This command will remove all of the cached packages, saving the most space. This just means that if you were to ever need a package that was cached it will simply have to be downloaded again. Depending on your connection speed and data plan this may or may not be of concern. Other than that, it is safe to do.
		Perhaps noteworthy is that the apt cache resides in /var/cache/apt/archives/. You can see them if you run the ls command on that path or view it in a file manager. Manually removing packages from this directory should be safe, but with the simpler and faster methods above there's no need.
	<<<

==== upgraden (binnen zelfde release) ====
	- BELANGRIJK : ofwel alle bootschijven aansluiten, ofwel reservekopie /boot/grub/grub.cfg, want die wordt bijgewerkt
	- Alvorens bij te werken vanop de command line, eerst
	# apt-get update
		- herhalen bij foutboodschappen is dikwijls genoeg als oplossing
	# apt-get upgrade
	- NADIEN : indien nodig secties voor niet-aangesloten bootschijven terughalen uit reservekopie /boot/grub/grub.cfg

- OPM de GUI update manager (launcher 'Settings/Software updater') laat toe om te kiezen wat wel/niet bijgewerkt moet worden

- apt-get update en apt-get upgrade worden gestuurd door de keuzes in launcher 'Settings/Software & Updates' (Configure the sources for installable software and updates)
	# software-properties-gtk

==== point release upgrade, b.v. van 16.04 naar 16.04.1 ====

- als dat niet al vanzelf gebeurd is

	# apt-get update
	# apt-get upgrade
	- 'apt-get upgrade' vernieuwt alleen geïnstalleerde packages. Als de afhankelijkheden van geïnstalleerde software veranderd zijn, kunnen er nieuwe packages nodig zijn, of geïnstalleerde packages overbodig (boodschap 'packages held back' bij apt-get upgrade), kunnen die met apt-get dist-upgrade bijgewerkt (of verwijderd) worden:
		# apt-get update
		# apt-get dist-upgrade
			[-y, --yes, --assume-yes] : Automatic yes to prompts
			- gebruikt packages binnen dezelfde releasenaam (b.v. xenial), want zo is dat geconfigureerd in /etc/apt/sources.list; doet dus geen upgrade naar andere releasenaam zonder die naam te veranderen in /etc/apt/sources.list (zie sectie "release upgrade, b.v. van 16.04.x naaar 18.04.x"
	>>>https://askubuntu.com/questions/81585/what-is-dist-upgrade-and-why-does-it-upgrade-more-than-upgrade
		apt-get upgrade is restricted to the case where packages are to be replaced by newer versions, but no package needs to be added or removed. A new version of Firefox, for instance, should be installable with apt-get upgrade.
		However apt-get upgrade will refuse to work when there are additions or removals required by the updated versions. For example, when you have kernel linux-image-3.2.0-10-generic installed and linux-image-3.2.0-11-generic appears, the linux-image-generic package gets updated to depend on the newer version. In order to install the new kernel, you need to run apt-get dist-upgrade.
		Notice how an apt-get upgrade will say that the kernel packages have been held back. That's the cue for using apt-get dist-upgrade.
	<<<
	>>>man apt-get
		update
			update is used to resynchronize the package index files from their sources. The indexes of available packages are fetched from the location(s) specified in /etc/apt-get/sources.list. For example, when using a Debian archive, this command retrieves and scans the Packages.gz files, so that information about new and updated packages is available. An update should always be performed before an upgrade or dist-upgrade. Please be aware that the overall progress meter will be incorrect as the size of the package files cannot be known in advance.
		upgrade
			upgrade is used to install the newest versions of all packages currently installed on the system from the sources enumerated in /etc/apt-get/sources.list. Packages currently installed with new versions available are retrieved and upgraded; under no circumstances are currently installed packages removed, or packages not already installed retrieved and installed. New versions of currently installed packages that cannot be upgraded without changing the install status of another package will be left at their current version. An update must be performed first so that apt-get knows that new versions of packages are available.
	   dist-upgrade
		   dist-upgrade in addition to performing the function of upgrade, also intelligently handles changing dependencies with new versions of packages; apt-get has a "smart" conflict resolution system, and it will attempt to upgrade the most important packages at the expense of less important ones if necessary. The dist-upgrade command may therefore remove some packages. The /etc/apt-get/sources.list file contains a list of locations from which to retrieve desired package files. See also apt_preferences(5) for a mechanism for overriding the general settings for individual packages.
	   full-upgrade (is nog niet beschreven in man-page)
			full-upgrade performs the function of upgrade but may also remove installed packages if that is required in order to resolve a package conflict.
	<<<

==== release upgrade, b.v. van 16.04.x naaar 18.04.x ====

- "Dirty" upgrades, from one release to another, don't always go as planned :
	- Back up your current system.
	- Update your current system with
		# apt-get update
		# apt-get full-upgrade.
	OFWEL
	- Make sure you have the update-manager-core package installed:
		# apt-get install update-manager-core
	- Upgrade to the current release:
		# do-release-upgrade
	OFWEL
	- schakel alle repositories van derden uit (Software & Updates)
	- verander repositories van oude (b.v. xenial) naar die voor nieuwe (b.v. bionic) release
		# sed -s --in-place=xenial~ 's/xenial/bionic/g' /etc/apt/sources.list /etc/apt/sources.list.d/*.list
			- backupextensie : NIET ".list" als backupextensie, best wel iets dat eindigt op ".save", anders waarschuwingen van apt-get
		- doordat nu (in dit vb.) bionic staat in /etc/apt/sources.list, doet dist-upgrade een upgrade die een stap verder gaat : alle paketten van oude release (xenial) vervangen door die van nieuwe release (bionic)
		# apt update
		- OPM: apt update kan nu een waarschuwing geven dat hij de backup-bestanden negeert omdat ze een rare extensie hebben. Maar hij negeert ze dus
	- upgrade naar de nieuw ingestelde distributie :
		# apt-get dist-upgrade
			- b.v. voor door uzelf gewijzigde configuratiebestanden vraagt apt-get wat hij moet doen: vervangen, afblijven, eerst vergelijken
			0 beter niet als ge al wat aan uw systeem gewijzigd hebt :
			 [-y, --yes, --assume-yes] : Automatic yes to prompts
	- waarschijnlijk best heropstarten

	- schakel de nodige repositories van derden terug in (Software & Updates); update zou bij "OK" achter de schermen moeten gebeuren, kan geen kwaad dat te herhalen :
		# apt-get update
	- installeer nieuwe software

=== Where can I find the source code of Ubuntu ===

	>>> https://askubuntu.com/questions/167468/where-can-i-find-the-source-code-of-ubuntu
	The source code for every package in the main and universe archives is in Launchpad, or you can get it by enabling Sources in the Software Properties dialog, and then doing apt-get source $packagename in a terminal, after refreshing the package information.
	<<<

- Linux Kernel Source Code:
	$ apt-get source linux-source-3.2.0

- Ubuntu Source Code:
	[Ubuntu archive](http://archive.ubuntu.com/ubuntu/)

- Specific Software Source Code for package $package:
	- in Settings/Software & Updates/tab [Ubuntu Software] source code aanvinken :
		v Source code
	# apt-get build-dep $package
		- install/remove packages in an attempt to satisfy the build dependencies for a source
           package
	$ apt-get source $package
		- download into the current directory the newest available version of that source package while respecting the default release, set with the option APT::Default-Release, the -t option or per package with the pkg/release syntax, if possible.
		- Source packages are tracked separately from binary packages via deb-src lines in the sources.list(5) file. This means that you will need to add such a line for each repository you want to get sources from; otherwise you will probably get either the wrong (too old/too new) source versions or none at all.
		- If the --compile option is specified then the package will be compiled to a binary .deb using dpkg-buildpackage for the architecture as defined by the --host-architecture option. If --download-only is specified then the source package will not be unpacked.
		- A specific source version can be retrieved by postfixing the source name with an equals and then the version to fetch, similar to the mechanism used for the package files. This enables exact matching of the source package name and version, implicitly enabling the APT::Get::Only-Source option.
		- Note that source packages are not installed and tracked in the dpkg database like binary packages; they are simply downloaded to the current directory, like source tarballs.
	- For instance:
		# apt-get build-dep ffmpeg
			- 300MB
		$ apt-get source ffmpeg		

- You can download the complete source code ISOs from the Ubuntu download servers:
    http://cdimage.ubuntu.com/releases/<version>/release/source/ for currently-supported releases. For example, http://cdimage.ubuntu.com/releases/12.04/release/source/ for 12.04.
    http://old-releases.ubuntu.com/releases/<version>/release/source/ for obsolete/EOL releases. For example, http://old-releases.ubuntu.com/releases/12.10/source/ for 12.10. However, source ISOs seem to be available only for 12.10 onwards.

=== oude versies van kernel verwijderen ===

- laat enkel laatste 2 staan :
	- BELANGRIJK : ofwel alle bootschijven aansluiten, ofwel reservekopie /boot/grub/grub.cfg, want die wordt bijgewerkt
	$ sudo apt-get update
	- herhalen bij foutboodschappen is dikwijls genoeg als oplossing
	$ sudo apt-get autoremove
	- OPM: duurt minuten
	- NADIEN : indien nodig secties voor niet-aangesloten bootschijven terughalen uit reservekopie /boot/grub/grub.cfg
	- OPM: misschien best herstarten nadien
	- Laat oude headers staan in /usr/src, >50MB per versie. Daarom van tijd tot tijd voor alle oude versies (vergelijken met /boot) met de hand opkuisen:
		$ sudo apt-get purge linux-headers-4.4.0-34

=== .deb package installeren ===
- aanbevolen :
	# apt update
	# apt install ./mijnpackage.deb
	- OPM : steeds een absoluut of relatief pad voor mijnpackage.deb opgeven, anders gaat apt gewoon het internet op om die package te zoeken in de repositories
	- apt install zorgt ook voor alle dependencies

- brute kracht; niet aanbevolen, omdat "apt-get install -f" soms wat driest te werk gaat :
	# dpkg -i mijnpackage.deb
	- installeert rechttoe-rechtaan, zonder evt. nodige extra packages te installeren
	# apt update
	# apt-get install -f
	-f : fix dependencies

=== .deb package uitpakken/inpakken/bewerken ===

- DEB files are ar archives, which always contains the three files: debian-binary, control.tar.gz, and data.tar.gz.

- wijzigen manier 1
	$ dpkg-deb -R original.deb /media/ramdisk/doelmap
	-R, --raw-extract : Extracts the filesystem tree from a package archive into a specified directory, and the control information files into a DEBIAN subdirectory of the specified directory. The target directory (but not its parents) will be created if necessary. The input archive is not (currently) processed sequentially, so reading it from standard input (-) is not supported.
	- edit the extracted files
	- You should add a changelog entry (.../doelmap/usr/share/doc/<library>/changelog.Debian.gz) and change the version number in ("DEBIAN/control") if you modify anything in the package. The infrastructure to manipulate Debian packages assumes that if two packages have the same name and version, they're the same package. Add a suffix to the debian_revision part at the end of the version number; for sorting reasons the suffix should start with ~, e.g. 1.2.3-4.1 becomes 1.2.3-4.1~johnjumper1
	$ dpkg-deb -b /media/ramdisk/doelmap fixed.deb
	-b, --build directory [archive|directory] : Creates a debian archive from the filesystem tree stored in directory. directory must have a DEBIAN subdirectory, which contains the control information files such as the control file itself. This directory will not appear in the binary package's filesystem archive, but instead the files in it will be put in the binary package's control information area. If the second argument is a directory then dpkg-deb will write to the file package_version_arch.deb, or package_version.deb if no Architecture field is present in the package control file.

- wijzigen manier 2
	- Beware that unless your script is running as root, the files' permissions and ownership will be corrupted at the extraction stage. Rather than mess with permissions, you can keep the data archive intact and modify only the control archive. dpkg-deb doesn't provide a way to do that. Fortunately, deb packges are in a standard format: they're ar archives. So you can use ar to extract the control archive, modify its files, and use ar again to replace the control archive by a new version.
	- You should add a changelog entry (? in DEBIAN/templates ?) and change the version number in ("DEBIAN/control") if you modify anything in the package. The infrastructure to manipulate Debian packages assumes that if two packages have the same name and version, they're the same package. Add a suffix to the debian_revision part at the end of the version number; for sorting reasons the suffix should start with ~, e.g. 1.2.3-4.1 becomes 1.2.3-4.1~johnjumper1
	# mkdir tmp
	# cd tmp
	# ar p ../original.deb control.tar.gz | tar -xz
	- edit the extracted files
	# cp ../original.deb ../fixed.deb
	# tar czf control.tar.gz *[!z]
	# ar r ../fixed.deb control.tar.gz

=== programma installeren naar eigen pad ===

- als ge weet naar welke paden het progr. installeert, kunt ge die op voorhand vervangen door links naar de gewenste installatiedirectory
	- b.v. FlighGear zet gigabytes databestanden in /usr/share/games/flightgear/

- veel programmas zijn te krijgen in een portable formaat, b.v. appimage, snap, flatpack. Die kopiëert ge gewoon waar ge wilt, b.v. mijn SDATA/.stacks

- met dpkg i.p.v. apt install
	- goed testen in VM snapshot
	>>>  https://askubuntu.com/questions/392644/install-program-to-home-folder-not
		There doesn't seem to be any option on apt-get for this. But there is for dpkg! (Untested as I'm doing this from memory. This DOES NOT WORK for packages that install stuff in weird places.)
		- download the .deb package
			# apt-get download hetprogramma
			# dpkg -i --instdir=mijnpad hetprogramma_versiestring.deb
		- WARNING. Using the following incorrectly (or even correctly) will probably destroy your system.
			- The man page for dpkg also has a --admindir= flag that, quote: "Change default administrative directory, which contains many files that give information about status of installed or uninstalled packages, etc. (Defaults to /var/lib/dpkg)" So in theory, if dpkg is complaining about package conflicts and dependencies, you can use the above to build a completely separate dependency tree, containing required libraries that would otherwise conflict with your system's main libraries and dependencies. (Do not use --admindir=YOURDIR without --installdir=YOURDIR. It'll mess things up)
		- Also look at the --root=dir option in the dpkg manual page. It's probably safer than using --admindir=YOURDIR and --installdir=YOURDIR
	<<<

=== eigen programmas en man pages toevoegen ===

- eigen programma's moeten niet geïnstalleerd worden, als het pad ~/bin bestaat, wordt dit door de .bashrc scripts van Ubuntu aan PATH= toegevoegd. Voor man pages bestaat zoiets niet. De opdracht man gebruikt de opdracht manpath om man-bestanden te vinden. Als de variabele MANPATH bestaat, en begint met ':', b.v. ':mijnmanpad', wordt 'mijnmanpad' toegevoegd achteraan het resultaat van de opdracht manpath; anders geeft manpath gewoon de inhoud van MANPATH. In de mappen van MANPATH mogen ge-gzipte man broncode staan, b.v. fdupes.1.gz, of (een softlink naar) de broncode zelf.
Voorbeeld:
	$ mkdir ~/bin/man/man1
	- man1 : directory voor manpages van sectie 1, executables en shell built-ins
	$ ln ~/Documents/c/fdupes-master/fdupes.1 ~/bin/man/man1/fdupes.1
	>>>~/.pam_environment
		MANPATH=~/bin/man
	<<< (terug aanmelden of zo)
	$ man fdupes

- syntax : ZIE
	$ man 7 man
	$ man man-pages

=== core dumps verwijderen ===

Bij sommige problemen dumpt linux het geheugen in een bestand /core of /core.1234, soms in andere directories zoals /root. Die bestanden kunnen vrij groot worden (cfr. beschikbaar RAM), maar blijken gewoon weg te mogen.

http://www.linuxnix.com/how-to-find-and-remove-core-files-in-linux/ :
>>>
	Why we system administrators are interested in that core files?
	Ans : This is because of their size. As we do monitoring of systems on daily basis but suddenly your disk is full one day when you came to office, you are total blank thinking how come disk is full though there is no much user activity etc. So core files are one reason which will eat up our disk. Which you have to check for when sudden disk activity is observed.

	How to find core files ?
	#  find / -mount -type f -name core -print0 | xargs -0 ls -l

	This find command will search entire filesystem for core files.. once you find them use rm command to remove those files..
	# rm -rf core
<<<

=== USB of andere schijf checken op bad blocks ===

- slecht werkende stukken geheugen komen al eens voor op oude of goedkope usb-sticks. Is zeker lastig wanneer we die als herstelstick willen gebruiken. Best vooraf checken op slechte blokken. Kan zowel per partitie als voor hele schijf

b.v.
	OFWEL
	$ sudo badblocks /dev/sdc1
	OFWEL
	$ sudo badblocks /dev/sdc
	- doet enkel een readtest
	- optie -n : non-destructive write test (schrijft orig. block terug na schrijf -en leestest)
	- optie -w : destructive write test (sneller dan non-destructive, maar natuurlijk alle info kwijt)

=== langlopende reeks problemen met ttf-mscorefonts-installer ===

- Van tijd tot tijd is er een pop-up scherm dat zegt dat er download nodig is om de basis fonts van microsoft voor Windows XP te downloaden, die op veel websites gebruikt worden, en daarom ook in Ubuntu, Debian e.a. linux distris geinstalleerd worden naar pad
	/usr/share/fonts/truetype/msttcorefonts/

- Bij mij staan die fonts er, op de juiste plaats, maar de update van package "3.4+nmu1ubuntu2" of "ttf-mscorefonts-installer_3.4+nmu1ubuntu2_all.deb" triggert dat die van tijd tot tijd een popup toont dat ze als dependencies opnieuw gedownload en geinstalleerd moeten worden. Dat zijn bij elke update dezelfde bestanden, het zijn .exe bestanden van Microsoft zelf, uit de Windows XP tijd, die niet meer geupdate worden:
	. andale32.exe, arial32.exe, arialb32.exe, comic32.exe, courie32.exe, georgi32.exe, impact32.exe, times32.exe, trebuc32.exe, verdan32.exe, webdin32.exe

- bij die download via de Ubuntu package manager, loopt het dikwijls mis, zodat die update van het package mislukt, en de volgende keer opnieuw de popup triggert. Op zich is dit geen probleem, de fonts staan er en alles werkt, alleen is die popup erg vervelend. Dit is een of andere oude weerkerende bug die niemand wil oplossen:
	https://bugs.launchpad.net/ubuntu/+source/msttcorefonts/+bug/1607535

Sommigen zegggen dat de fout zit in de url in het .deb-package: ".../the fonts/...", zou  ".../the%20fonts/..." moeten zijn, kunt ge zelf niet veel aan veranderen.

Anderen zeggen dat ze de repository van Debian gebruiken, en zo ineens updaten naar versie 3.6 van dat package:
>>>
	ttf-mscorefonts-installer 3.4+nmu1ubuntu2 fails to install core fonts and should be updated to version 3.6 from Debian Edit
	I solved the problem by downloading (manually) the 3.6 version of ttf-mscorefonts-installer from debian
	(https://packages.debian.org/de/sid/all/ttf-mscorefonts-installer/download). installing that package with gnome's software center (and probably also ubuntu's software center) works perfectly.
	Probably this is a workaround and not a solution
<<<

- als de fonts nog niet geinstalleerd zijn, zelf downloaden (wschlk. NIET de verzameling "wd97vwr32.exe" downloaden) van b.v.
	https://sourceforge.net/projects/corefonts/files/the%20fonts/final/
	https://freefr.dl.sourceforge.net/project/corefonts/the%20fonts/final/
allemaal naar dezelfde, voor het overige lege, directory (bij mij staan ze b.v. al klaar in /home/dirk/.PlayOnLinux/fonts om naar nieuwe wine-versies te installeren). Dan een terminal openen in die map, en volgende commando's uitvoeren:
	$ sudo apt-get update
	$ sudo apt-get remove --purge ttf-mscorefonts-installer
	$ sudo apt-get install ttf-mscorefonts-installer
	- dit probeert weer dezelfde downloads van de .exe's, die waarschijnlijk weer mislukt (zie verder voor voorbeelden van fouten bij de download). Maar deze stap is wel nodig om de EULA (end-user license agreement) van Microsoft te aanvaarden. Opgepast, het scherm daarvoor wordt naar verluidt soms verborgen, bij mij verscheen het gewoon in het terminal-venster. Om te aanvaarden, met [tab] naar de <OK>-knop gaan, [enter], en nog eens [tab] naar de <Yes>-knop en [enter>
	$ sudo dpkg-reconfigure ttf-mscorefonts-installer
	- deze stap had normaal vanzelf na "install ttf-mscorefonts-installer" moeten volgen, doen dit nu manueel
	- in tekst-veld op terminal de directory met de font-.exe's tikken of plakken
	- met [tab] naar <OK>-knop
	- pakt nu alle bestanden van die directory uit (en mislukt als 1 daarvan geen font-.exe is !) en installeert de fonts erin

- behandeling van de vervelende pop-up:

Via die popup om installeren vragen, vraagt om root-paswoord en opent dan een terminal met :

	ttf-mscorefonts-installer: processing...
En dan volgen de downloads voor elke .exe apart. Als een download goed loopt, volgt er altijd/meestal toch een Warning:
	ttf-mscorefonts-installer: downloading http://downloads.sourceforge.net/corefonts/andale32.exe
	Get:1 http://downloads.sourceforge.net/corefonts/andale32.exe [198 kB]
	Fetched 198 kB in 1s (160 kB/s)
	W: Can't drop privileges for downloading as file '/var/lib/update-notifier/package-data-downloads/partial/andale32.exe' couldn't be accessed by user '_apt'. - pkgAcquire::Run (13: Permission denied)

Sommigen besluiten hieruit dat gebruiker _apt (de package-beheerder) eigenaar moet worden van de downloadmap:
	0 chown _apt /var/lib/update-notifier/package-data-downloads/partial/
maar dat helpt niets. Bovendien blijkt deze waarschuwing goedaardig te zijn, de download loopt goed af (zoals ook gebeurde, voor dezelfde fonts, bij installatie van PlayOnLinux)

Maar als niet ALLE downloads lukken, mislukt de update van de package en komt de popup weer. De fouten zien eruit als volgt, en na de eerste wordt het proces afgebroken:
	Err:1 http://downloads.sourceforge.net/corefonts/arial32.exe
	  404  Not Found
	E: Failed to fetch https://freefr.dl.sourceforge.net/project/corefonts/the fonts/final/arial32.exe 404  Not Found
	E: Download Failed
   OF
	Err:1 http://downloads.sourceforge.net/corefonts/andale32.exe
	  Protocol "http" not supported or disabled in libcurl
	E: Failed to fetch https://kent.dl.sourceforge.net/project/corefonts/the fonts/final/andale32.exe Protocol "http" not supported or disabled in libcurl
	E: Download Failed
   OF
	Err:1 http://downloads.sourceforge.net/corefonts/andale32.exe
	  The HTTP server sent an invalid Content-Range header
	E: Failed to fetch https://netcologne.dl.sourceforge.net/project/corefonts/the fonts/final/andale32.exe The HTTP server sent an invalid Content-Range header
	E: Download Failed

De update van het package kan ook manueel uitgevoerd worden:
	# /usr/lib/update-notifier/package-data-downloader
dit geeft dezelfde fouten.

OPM: misschien kan het probleem omzeild worden door een alternatieve repository toe te voegen
	https://launchpad.net/ubuntu/+source/msttcorefonts
   OF	(vanop die pagina via de link "Other versions of 'msttcorefonts' in untrusted archives")
	https://launchpad.net/ubuntu/+ppas?name_filter=msttcorefonts

=== map archiveren met tar ===

- niet met thunar, beter met tar op de commandolijn:
	. Thunar's 'create archive' dereferencet symbolic link mappen, i.p.v. de link in te pakken
	. 'Archive Manager' (fileroller) pakt beduidend groter in

- archief maken met naam hoofdmap (ook als dat ./ is)
	$ tar -cJf pad-naar-archief -C pad-naar-moedermap map-in-moedermap/
	- Compressieopties
		. z: gz		snel
		. J: xz/lzma	goed, pakt heel traag in maar snel uit
		. j: bz2		goed, pakt traag in en uit

- archief maken zonder naam hoofdmap
	. OPGELET niet met parameter '-C pad-naar-bestanden', want wildcard '*' wordt voordien al geëxpandeerd naar het commando door de shell, naar alle bestanden en mappen op het uitvoeringspad, i.p.v. pad-naar-bestanden
	$ cd pad-naar-bestanden ; tar -cJf pad-naar-archief  *
	- OPM na uitvoering van dit commando staan we op pad-naar-bestanden

- archief uitpakken (h om uit te pakken in doelmap van symbolische link, met behoud van de link, i.p.v. die link te vervangen door een map met dezelfde naam)
	- OPGELET: altijd eerst "tar --list -f archief"; NIET UITPAKKEN als basispad in archief '/' is, WEL als dat './' of '' is
	$ tar -xhf pad-naar-archief -C doelmap [--anchored --exclude=PATTERN]
	--exclude=PATTERN : moet zoals pad in archief zijn; b.v. typisch is een tar van heel het systeem zonder voorloop-/, dus om b.v. /usr niet uit te pakken : --exclude=usr, NIET --exclude=/usr
	 --anchored : exclude-pattern begint van root van archief (d.w.z. "" of "/"; anders wordt gematched vanaf elk sub-pad

=== 7z commando gebruiken ipv peazip-gui ===

- 7z comprimeert meerdere bestanden, i.p.v. zoals bzip2 en xz een enkel bestand (b.v. een hele tar)

- peazip heeft nukken en werkt ondoorgrondelijk, mijn geinstalleerde versie 6.0.0 gebruikt bovendien een beta van 7z : 7-Zip [32] 15.09 beta

- beste 7z-compressie
	$  7z a -t7z -m0=LZMA2 -mmt=on -mx9 -md=64m -mfb=64 -ms=4g [-mqs] ['-wbasispad'] padnaararchief.7z pad1/ pad2/*
	- -wbasispad : set working directory, stript basispad van pad gecomprimeerde mappen
	- -mqs: vanaf versie 15.12, sorteer per bestandsextensie voor
	- pad1/ : de volledige subtree pad1/ , met prefix 'pad1/'
	- pad2/* : de volledige subtree pad2/ , zonder prefix 'pad2/'
	- ZIE file:///usr/share/doc/p7zip-full/DOCS/MANUAL/switches/method.htm voor -m[parameters]

=== bestanden uit .Trash herstellen ===

- spacefm ondersteunt zelf geen .Trash
	- verwijderen met door Ubuntu geleverde gvfs-trash
	- thunar ondersteunt .Trash fout, herstelt bestanden verwijderd door gvfs-trash niet naar de juiste plaats
	- beheer en herstel met programmas van trash-cli :
		- restore-trash werkt enkel op .Trash-directory van mountpoint voor current directory

- interactief per bestand :
	$ restore-trash
	- presenteert lijst met alle bestanden origineel onder current directory, met verwijdertijdstip:
		>>> vb.
		... (genummerde bestandspaden)
		What file to restore [0..17]:
		<<<
	- Per 1 te restoren door hun volgnr. in te tikken

- alle bestanden herstellen die vernietigd zijn uit current directory en subdirectories:
	$ restore-trash
	>>> vb.
	... (genummerde bestandspaden)
	What file to restore [0..17]:
	<<<
	- aanvaardt maar 1 nummer, dus dat doen we niet met de hand, gewoon [Enter]. "restore-trash" geeft ook geen returncode als er geen verwijderde bestanden zijn onder di directory, dus daarmee kunnen we in een script niets doen. In de plaats daarvan laten we bash een sequence van alle nummers genereren als een soort teller (d.w.z. we gebruiken $i niet, verwijderen altijd nr. 0) :
	$ for i in {0..17} ; do ( echo '0' | restore-trash ) ; done;

=== bootvolgorde beheren ===

- blijvende instellingen in UEFI bios setup ([Esc] of [de]) sectie 'Boot'
	- laat bootbare devices (soms?) pas de 2de keer zien

- tijdelijke boot override in UEFI bios setup ([Esc] of [de]) sectie 'Save & Exit'
	- eerst 'save changes' voor evt. andere wijzigingen in setup
	- 'Boot Override' kiezen met cursor pijltjes
	- enteren op de keuze voor deze boot
	- geldt enkel voor deze boot

- boot menu openen met [F11] tijdens UEFI gedeelte van opstart (direct een paar keer F11 drukken kan geen kwaad)
	- is ook tijdelijk, maar zo blijft ge uit bios setup
	- langer tijd geven voor F11, door UEFI time-out in te stellen vanuit Ubuntu :
	$ sudo efibootmgr -t [seconden]
	- heeft geen effect bij UEFI bios setup/Advanced/Windows configuration/MSI fast boot of .../fast boot

- uefi boot volgorde kan ook ingesteld worden met Ubuntu's efibootmgr

=== boot-verloop ===

- zie /var/log/kern.log, met tijdstampen

- prints the time spent in the kernel before userspace has been reached, the time spent in the initial RAM disk (initrd) before normal system userspace has been reached, and the time normal system userspace took to initialize
	$ systemd-analyze time
	>>>
	Startup finished in 7.291s (firmware) + 6.439s (loader) + 35.389s (kernel) + 5.420s (userspace) = 54.541s
	graphical.target reached after 5.415s in userspace
	<<<

- print a list of all running units, ordered by the time they took to initialize
	$ systemd-analyze blame
	>>>
          3.544s NetworkManager-wait-online.service
           635ms media-sdata-.swapfile.swap
           473ms apt-daily.service
           458ms apt-daily-upgrade.service
	...
             2ms home.mount
             1ms snapd.socket
	<<<
		- OPM : samen 10.125s voor zelfde boot als "systemd-analyze time" hierboven

=== execute-toelating intrekken van directory tree die uit Windows gekopiëerd werd ===

- Blijkbaar krijgen alle bestanden dat van een Windows-pc overkomt (?unzip, kopiëren van NTFS-schijf of via netwerk?) execute-toelating voor all. Is niet alleen gevaarlijk, ook vervelend voor inkleuring van 'ls' opdracht (kleur voor executable heeft voorrang). Die toelating kan ingetrokken met
	0 chmod -R a-x
	-R : recursief
maar dan verliezen ook alle directories die toelating, die daar iets anders betekent: bladeren toegelaten. En dan kan de uitvoerende gebruiker niet meer in de directory om de execute-flag van de bestanden erin in te trekken. Moet daarom met sudo, die blijft overal aan kunnen, en dan kan ineens de owner goed ingesteld worden (want soms kopiëert root zo'n tree, en is dan owner). Na intrekken (-x), terug toelaten voor directories alleen met chmod -X (HOOFDLETTER X)
	#  for i in tree1 tree2 ;  do echo $i ; chown -R dirk:dirk $i ; chmod -R a-x,o-w $i ; chmod -R a+X $i ; done

=== user toevoegen aan groep ===
	$ sudo usermod -aG groepnaam usernaam

=== toevoegen aan opstartmenu grub ===

- De opdracht grub-mkconfig maakt een nieuwe grub.cfg, in stdout
	[-o nieuwegrub.cfg] : naar nieuwegrub.cfg i.p.v. stdout (wordt overschreven)
	- "update-grub" is een alias voor "grub-mkconfig -o /boot/grub/grub.cfg"
	- eerst worden /etc/default/grub en /etc/default/grub.d/*.cfg gesourced
		- *.cfg komt in globbing-volgorde van de shell (d.w.z. gesorteerd op naam)
		- die moeten dus niet executable zijn, maar wel geldige bash syntax bevatten
		- doordat ze met "source" (".") worden uitgevoerd, komen alle variabelen die in die scripts gezet worden, in de shell die grub-mkconfig uitvoert
		- "/etc/default/grub" wordt standaard vervangen bij systeemupgrade (apt-get dist-upgrade), maar omdat die als eerste wordt uitgevoerd (en enkel variabelen zet), is dat gemakkelijk te herroepen/aanvullen door eigen scripts in /etc/default/grub.d te plaatsen
	- dan worden alle executables in /etc/grub.d  uitgevoerd in globbing-volgorde, en hun gezamenlijke stdout vormt de nieuwe grub.cfg
	- /etc/grub.d/40_custom is een simpele template, die alles vanaf lijn 3 naar stdout kopiëert; is gemakkelijk om vaste menu-entries in grub.cfg te krijgen
	- /etc/grub.d/41_custom voegt tenslotte syntax toe om een extra /boot/grub/custom.cfg of .../EFI/ubuntu/custom.cfg toe te voegen aan het grub menu

- menu entry toevoegen aan /etc/grub.d/40_custom (naar de vb. die daar al in staan)
	- vb. zie "_Xubuntu.adoc" sectie "systemrescuecd toegevoegd aan opstartmenu grub 2"
	- eerst de nodige modules laden voor
		- gpt-partitietabel
			insmod part_gpt
		- mbr-partitietabel (soms "ms-dos" genoemd)
			insmod part_msdos
		- ext2/3/4 partities
			insmod ext2
		- FAT (16,32) partities
			insmod fat
	- de schijfnaam waarvan er geboot moet worden, wordt gezocht met grub-opdract search :
		- op bestandsnaam die op de opstartschijf moet staan (pad vanaf root van bestandssysteem)
			search --set=root --file /PAD
		- op label van bestandssysteem (!= label van partitie)
			search --set=root --label LABEL
		- op uuid van bestandsssysteem (zonder {}), b.v.
			search --set=root --fs-uuid 88e332dc-deb9-4c9c-9dfc-e0afe7ad45bd
		- al deze opdrachten zetten dan de schijf- en partitienaam in de variabele root
	- als die opstartschijf een linux is met een eigen grubmenu
		- vb. met typisch pad naar een grub.cfg :
			configfile $root/boot/grub/grub.cfg
	- als die opstartschijf b.v. EFI-opstartbaar is, zonder eigen grubmenu
		- vb. met typisch pad naar een .efi boot image :
			chainloader (${root})/EFI/memtest86/bootx64.efi
			OF
			chainloader /efi/Microsoft/Boot/bootmgfw.efi
	- als die opstartschijf een linux-systeem heeft, rudimentair vb. :
		linux /boot/vmlinuz-VERSIE.efi.signed root=UUID=UUID_VAN_ROOT_PARTITIE ...
		initrd /boot/initrd.img-VERSIE

- de nieuwe 40_custom opnemen in de grubconfiguratie :
	- alle USB-schijven waarvan ge ooit wilt booten, insteken (mounts niet nodig), zodat ze gevonden worden door de 30_os-prober en zo in grub-menu komen
	- nieuwe grub.cfg eerst naar tijdelijke locatie maken, dan pas kopieren naar definieve plaats
		# grub-mkconfig -o /media/ramdisk/grub.cfg
		- dan backup maken van werkende grub.cfg
			# cp /boot/grub/grub.cfg /boot/grub/grub.cfg~
		- nieuwe erover kopieren
			# cp /media/ramdisk/grub.cfg /boot/grub/grub.cfg
		- OPM : update-grub is a stub for running "grub-mkconfig -o /boot/grub/grub.cfg" to generate a grub2 config file

- OPM: goed om te onthouden: grub-commandline heeft geen more, maar na "set pager=1" wordt er toch een soort more uitgevoerd voor elke opdracht

=== grub.cfg maken in chroot ===

- eerst volledige systeem (root, ESP, en zeker /usr en /var als die op aparte partitie staan) mounten in b.v. /mnt

- dan /mnt als nieuwe root gebruiken
	# chroot /mnt
		- wat in /mnt staat, is nu in /
- vervolgens speciale bestandssystemen mounten op (lege) voorziene directories
	# ls /dev /proc /sys
		- moeten nog leeg zijn
	# mount udev -t devtmpfs /dev
	# mount proc -t proc /proc
	# mount sysfs -t sysfs /sys
- reservekopie nemen
	# cp /boot/grub/grub.cfg /boot/grub/grub.cfg~herstel~
- nieuwe grub maken
	# update-grub
	OF
	- eerst nakijken, dan grub.cfg vervangen
		# grub-mkconfig -o-
		# grub-mkconfig -o /tmp/grub.cfg
			- nakijken
		# cp /tmp/grub.cfg /boot/grub/
- uit chroot gaan
	# exit

=== GUI theme ===

- XFCE (Xubuntu) thema configuratie :
	- Settings/Window Manager (Configure window behaviour and shortcuts) :
		- kiest lettertypes en plaats van icons op de titelbalk
		- kiest het xfwm4-thema voor vensterversiering (titelbalk, vensterranden en -hoeken, knop-tekeningen, ...) en hun kleuren
			- de thema's met een ./xfwm4/ subdir
			- "./xfwm4/themerc" bepaalt de kleuren (voor zover die niet in de grafische bestanden in die dirctory vastliggen)
				- kent kleurnamen uit .config/gtk3/gtk.css (@define-color, zie verder)
					- pas effect na uitloggen
		- direct effect
	- Settings/Appearance (customize the look of your desktop) :
		- kiest lettertypes, iconverzamelingen e.a.
		- kiest het thema voor gtk-toepassingen (mousepad, spacefm, geany, ...)
			- de thema's met een ./gtk-2.0/ subdir
				- lijkt ook voor gtk-3 toepassingen te dienen
			- de 3 kleuren links van themanaam zijn "bg_color", "fg_color" en "selected_bg_color" van sleutel gtk-color-scheme uit "./gtk-2.0/gtkrc"
			- bepaalt o.a. de kleuren van menus; o.a. Greybird haalt die (niet die van menubalk zelf) uit "custom menu clr" en "custom highlight clr") van "Theme Configuration", zie hieronder
	- Settings/Theme Configuration (configure GTK theme colours) :
		- zet in ".config/gtk3/gtk.css" secties "select-on" (hightlight), "panel-on" en "menu-on" in of uit block-comment (keuze ON/OFF), en definiëert daar eigen kleuren in; Die kunnen ook gebruikt worden in xfwm4-thema (zie hoger)
		- detailinstellingen zijn mogelijk met .config/gtk3/gtk.css (in Xenial toch, in Bionic niet meer :
			>>> Xubuntu 18.04 Release Notes :
			This release, we decided to remove the GTK Theme Configuration tool. It is no longer possible to override colors in all themes with a single application due to recent developments in GTK. It may return in a later release, but with limited functionality or theme support.
			<<<
		- in Xenial zet dit bovenaan in .config/gtk3/gtk.css een mooie menukleur, in Bionic niet meer
		>>>
			GtkMenuBar.menubar,
			GtkMenuBar.menubar.menuitem {
				background-color: #ffe55e;
				color: #0000ff;
			}
		<<<

- eigen themas in ~/.themes hebben voorrang op gelijkgenaamde themas in /usr/share/themes
	- elk thema is een directory, met in subdirectories themas voor verschillende gui-aspecten :
		- ./xwm4/ en ./gtk-2.0/ : zie hierboven
		- ./gtk-3.0/ : heeft subdir met b.v. kleurvarianten, assets (b.v. grafische elementen), ./apps met gtk.css e.a. bestanden per toepassing, ...
		- ./balou : splash popup van Xubuntu
		- ./xfce-notify-4.0/,  ./gtk-2.0-key : ??

=== boot Ubuntu into the console [i.p.v. GUI] ===

- via grub :
	- Advanced Options ......
	- Ubuntu .... (recovery mode)
	? root : Drop in root shell prompt
	- system is read only at the moment, mount as rw so edits to files can be made
		# mount -o rw,remount /
	OF
	- "e" : edit boot options, op het opstartmenu-item naar keuze
	- als dit een Ubuntu-opstart is :
		- Voeg het volgende toe in de lijn "linux /boot/vmlinuz-... ... quiet splash $vt_handoff" na "quiet splash" : init=/bin/bash
			- wijzigt /boot/grub/grub.cfg NIET
		- F10 om met die opties op te starten; nu wordt NIET systemd geladen om o.a. alle services, zoals X, en de GUI te laden, maar wordt na /etc/fstab te interpreteren (zo goed als) onmiddelijk bash gestart in de terminal
			- als er problemen zijn met mounten, of misschien altijd (in grub.cfg-lijn linux ... staat er immers een "ro"), dan is / read-only gemount. Om wijzigingen kunnen te bewaren:
				# mount -o remount,rw /
				- OPM : doe dit pas als het root filesystem OK is, zodat het niet verder gecorrumpeerd wordt
			- nano e.d. is beschikbaar
			- voor opdrachten zoals reboot en poweroff moet /usr gemount zijn (anders "libip4tc.so niet gevonden"); sysctl-opdrachten werken niet, omdat de init bash is, niet sysctld
			- om evt. door te starten als het probleem opgelost is :
				# exec /sbin/init

- via systemd, is sinds Ubuntu 15.04 het systeem om services te starten en te stoppen :
	>>> https://linux.m2osw.com/boot-command-line-console-ubuntu-1604-and-newer
	- systemd has a list of variables you can tweak using the systemctl command.
		-to know what the current status is:
			$ systemctl list-units --type target --all
			--all : show the inactive targets as well
		- To boot in the console, you have to set that as the default:
			# systemctl set-default multi-user.target
			- prevents the graphical boot and starts using the console instead.
		- To go back to graphical boot, use the graphical target instead:
			# systemctl set-default graphical.target
			- boots to the usual lightdm (or gmd) prompt instead of a console.

		- to start X11 once in a while (I actually work in X11, but log out nightly so that way memory is not as tight and X11 is reset at least daily). Instead of startx (zie b.v. system rescue cd), we now want to run X11 with systemd which will make sure that all the necessary parts get loaded as expected.
			0 startx would start the X11 screen but not Unity; you have to do that manually (setsid unity)
			# systemctl start graphical.target
			- starts X11 and Unity (Xfce voor Xubuntu)
			- won't give you the option of logging out of X11 as you could before with the log out menu. Instead, you have to switch back to multi-users with a similar command:
				# systemctl isolate multi-user.target
				- switches you back to the standard super fast text consoles.
				- will generally take you to TTY 7 or 8 which is likely to be a black screen or have some boot logs, not a login prompt or the console you started from. To fix that problem, you may use the chvt command line option:
					# chvt 1 && systemctl isolate multi-user.target
					- chvt N : change foreground virtual terminal; Ctrl+LeftAlt+FN (with N in the range 1-12) usually has a similar effect.
	<<<

- in console de display (tegenwoordig altijd framebuffer) draaien :
	# echo 3 > /sys/class/graphics/fbcon/rotate
	OF
	# echo 3 > /sys/class/graphics/fbcon/rotate_all
	- 0 : rotate   0°
	- 1 : rotate  90° clockwise
	- 2 : rotate 180° clockwise
	- 3 : rotate 270° clockwise
	
== BACKUP ==

=== backup met squashfs ===

- zie ook .../.backups/_backup.sh

- squashfs maken
	# cd sourcedir ; mksquashfs . archief.squashfs -comp xz -wildcards -e dev/* sys/* proc/* run/* tmp/*
	-comp xz : compressie; compressors available: gzip (default), lzo, xz
	-e /dev/* ... : sluit wel inhoud van /dev uit, maar /dev-map zelf staat in het archief
		- OPGELET : deze optie staat niet in manpage, wel in --help bij SYNOPSIS : "[-e list of exclude dirs/files]"
	[-no-duplicates] : do not perform duplicate checking.
	- om te gebruiken als een soort mountbaar iso- of zip-bestand, waarbij attributen e.d. geen rol spelen :
		-no-xattrs : don't store extended attributes
		-no-exports : don't make the filesystem exportable via NFS
		-always-use-fragments : use fragment blocks for files larger than block size
		[-noD] : data niet comprimeren (b.v. reeds gecomprimeerde media)
		[-b 4096] : kleinere or grotere blocks dan de standaard 128kB, groter geeft betere compressie (behalve natuurlijk bij -noD)
		0 [-nopad] : KAN NIET GEMOUNT WORDEN : do not pad filesystem to a multiple of 4K
		- voorbeeld :
		$  mksquashfs ./~Fotos fotos.squashfs -noD -always-use-fragments -b 4096 -no-recovery
	- aan bestaande squash worden bestanden gewoon toegevoegd :
	 	[-noappend] : do not append to existing filesystem, maar overschrijf het gewoon.
		- dank zij duplicates checking (tenzij -no-duplicates) vragen ongewijzigde bestanden geen extra plaats
		-  dubbels krijgen suffix _1 enz. :
			"Source directory entry bestand.ext already used! - trying bestand.ext_1"
		[-root-becomes NAME] : when appending source files/directories, make the original root become a subdirectory in the new root called NAME, rather than adding the new source items to the original root.
		[-no-recovery] : don't generate a recovery file; anders boodschap zoals
		>>>
			Recovery file "squashfs_recovery_mijnbackup.sqfs_13768" written
			If Mksquashfs aborts abnormally (i.e. power failure), run
			mksquashfs dummy /media/ramdisk/diverse.sqfs -recover squashfs_recovery_mijnbackup.sqfs_13768
			to restore filesystem
		<<<
		[-recover NAME] : recover filesystem data using recovery file NAME
	- OPM mksquashfs bewaart chmod en chown toegangsrechten en xattr, maar GEEN ACL, zoals mask:
		# getfacl ORIGINEEL/media/guest-tHmpt3/
		file: ORIGINEEL/media/guest-tHmpt3/
		owner: root
		group: root
		user::rwx
		user:guest-tHmpt3:r-x
		group::---
		mask::r-x	<<<<<<<<<<<<<<<<<<<
		other::---

		# getfacl ARCHIEF/media/guest-tHmpt3/
		file: ARCHIEF/media/guest-tHmpt3/
		owner: root
		group: root
		user::rwx
		group::r-x
		other::---
	- you can save the ACL by running getfacl -R at the root of the original filesystem and restore them after extracting the files with setfacl --restore.

- squashfs mounten
	# mount -t squashfs -o loop archief.squashfs /mnt

- info van squasbestand :
	$ unsquashfs -s archief.squashfs
	>>>
		Filesystem size 757549.93 Kbytes (739.79 Mbytes)
		...
		Number of inodes 31357
	<<<

- squasfs uitpakken :
	# unsquashfs -f -d /media/ramdisk archief.squashfs
	-f : force overwrite (zonder pakt unsquashfs niet naar bestaande directories uit)
	-d : doeldirectory

=== backup met rsync ===

- zie "~/Documents/_installatie/knowhow Backup/Full system backup with rsync - ArchWiki.mht" (origineel op  https://wiki.archlinux.org/index.php/full_system_backup_with_rsync)
	- best vanaf recovery boot medium, maar
		>>>
		This method will work even while the system is running, but files changed during the transfer may or may not be transferred, which can cause undefined behavior of some programs using the transferred files.
		<<<
	- zie verder op link om te booten vanaf die backup
	# rsync [-n] [--delete] [-l] -aAXxSiv --exclude={"/dev/*","/proc/*", "/sys/*", "/tmp/*", "/run/*", "/mnt/*", "/media/*", "/lost+found"} bron/ doel
	- uitleg paramaters zie sectie "RSYNC"

=== backup met tar ===
- tar maken
	- tar BEWAART GEEN SOCKETS
	# tar -C /mnt --anchored --exclude=./tmp/* exclude=./lost+found/* --exclude=./dev/* --exclude=./sys/* --exclude=./proc/* --exclude=./run/* --acls --warning='no-file-ignored' -capf doel/archief.tar.xz .
	 -C, --directory /mnt : change directory to /mnt
		- OPGELET: bron-wildcards worden door shell in huidige shell geglobbed, dus in dat geval beter vooraf van werkmap veranderen: # cd /mnt ; tar ...
	-c, --create
	-a,  --auto-compress: compressie op basis van doel-extensie
	-p, --preserve-permissions : extract information about file permissions (default for superuser)
	-f, --file : pad naar archiefbestand ( -f- : stdout, is ook default in meeste compiles van tar)
	--warning='no-file-ignored': om goedaardige "socket ignored" niet op stderr te krijgen (en natuurlijk ook andere ignoreds niet)
	--acls : Enable the POSIX ACLs support
	--exclude /dev/* : sluit wel inhoud van /dev uit, maar /dev-map zelf staat in het archief
	--anchored : patterns match file name start (default for exclusion: patterns match after any '/')
	- usr en home apart:  --exclude=./usr/*  --exclude=./home/*
	0 --atime-preserve : tar leest en herstelt noatime van elk bronbestand. Enkel zin op mounts zonder optie -noatime, als ge progs gebuikt die op de atime lettten. Dus niet als bron nu of bij normaal gebruik met -noatime of readonly gemount is of wordt
		- preserve access times on dumped files, either by restoring the times after reading (METHOD='replace'; default) or by not setting the times in the first place (METHOD='system')

- tar mounten
	- zie "archief mounten" (archivemount) in dit bestand
	- werkt niet vlot met grote gecomprimeerde archieven
	- zonder sudo
	$ archivemount -o readonly /archief.tar.xz /mnt
	- unmounten zonder sudo met
	$ fusermount -u /mnt

- tar uitpakken: gewoon openen als archief
	- OPGELET: altijd eerst "tar --list -f archief"; NIET UITPAKKEN als basispad in archief '/' is, WEL als dat './' of '' is
	#tar -xf archief.tar [--anchored --exclude=PATTERN] -C doel
	OF
	# pushd doel; tar -xf archief.tar [--anchored --exclude=PATTERN] ;popd
	OF
	# cd doel; tar -xf archief.tar [--anchored --exclude=PATTERN]
	-C doel : tar zelf zet tijdens zijn werking current directory op 'doel'
	--exclude=PATTERN : moet zoals pad in archief zijn; b.v. typisch is een tar van heel het systeem zonder voorloop-/, dus om b.v. /usr niet uit te pakken : --exclude=usr, NIET --exclude=/usr
	 --anchored : exclude-pattern begint van root van archief (d.w.z. "" of "/"; anders wordt gematched vanaf elk sub-pad
	 
=== backup met fsarchiver ===

- gebruik ik niet meer

- zie "~/Documents/_installatie/knowhow Backup"/_fsarchiver.txt

- fsarchiver maakt backup ofwel van filesystem, ofwel van directory tree. In het eerste geval kan alleen het hele filesystem gerestored worden, en dat heeft dan dezelfde filesystem UUID en LABEL als het origineel. Dat laatste brengt grub in de war bij restore naar 2de opstartschijf, want zowel in /EFI/grub.cfg als in boot/grub/grub.cfg wordt de UUID gebruikt om het bestandssysteem te kiezen vanwaar geboot wordt.

=== nuttig voor backup en herstel ===

- opletten voor boot- en mount-configuratie:
	- zie sectie "uuid van block devices en partities" :
		# blkid
	- /boot["grub"|"/efi/EFI/ubuntu"]/grub.cfg identifiëert boot-partitie met filesystem-UUID, /etc/fstab naar keuze met o.a. filesystem-LABEL of -UUID
	- als filesystem-UUID mee gearchiveerd wordt (WEL fsarchiver savefs, NIET squashfs, tar of cpio), moet hij bij restore naar andere partitie/schijf veranderd worden door b.v.
		# fsarchiver restfs archief.fsa id=0,dest=/dev/partitie,label=mijn_label,uuid=mijn_uuid
	- ZIE OOK volgende:

==== zelf random-uuid genereren ====
	$ uuidgen

==== zelf uuid en label instellen ====

- ext2/3/4)
	# tune2fs -U mijn_uuid /dev/ext#partitie
	EN
	# tune2fs -L mijnlabel /dev/ext#partitie
	OFWEL
	# /sbin/e2label /dev/ext#partitie mijn_label

- ntfs,fat,fat16,fat32 met de hand
	- uuid heet "volume serial number"
	# dd if=/dev/partitie of=EersteNtfsBlok.hex bs=512 count=1
	- ntfs: uuid op offset 0x48-0x4f (8 bytes) in EersteBlok.hex, wijzigen met hex-editor
	- fat/fat16/fat32: uuid op offset 0x43-0x46 (4 bytes) in EersteBlok.hex, wijzigen met hex-editor
	# dd if=EersteBlok.hex of=/dev/partitie bs=512 count=1

- ntfs met tool
	- uuid heet "volume serial number"
	- install the ntfsprogs package
		# ntfslabel --new-serial=x1x2x3x4x5x6x7x8 /dev/ntfspartitie mijn_label
		--new-serial	: 8 bytes, 16 hex digits

- fat/fat16/fat32 met tool
	- uuid heet "volume serial number"
	- install the mtools utility package.
		# mlabel [-n|-N mijn_serial] -i /dev/partitie ::mijn_label
		-n		: Assigns a new (random) serial number to the disk
		-N serial	: Sets the supplied serial number, an 8 digit (4 bytes) hexadecimal number, without spaces

==== vergelijk backups of directory trees ====
- b.v. kandidaten voor herstel vergelijken, met origineel en met elkaar
	OFWEL
	# rsync -naiAX kandidaat1/ kandidaat2/
	- uitleg: zie sectie "RSYNC"
	OFWEL
	- Meld Diff Viewer

==== filesysteem maken in een gewoon bestand ====

- zie sectie "bestand als virtuele schijf voorbereiden en mounten"

=== inhoud van systeemdirectories ===

- zie "https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html"
- zie "https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html"

- /usr is shareable, read-only data: should be shareable between various FHS-compliant hosts and must not be written to (behalve bij installaties). Any information that is host-specific or varies with time is stored elsewhere.

- /tmp directory must be made available for programs that require temporary files.
	- it is recommended that files and directories located in /tmp be deleted whenever the system is booted
	- mag dus gerust tmpfs ramdisk zijn, zeker als er een swapfile of -partitie is: dat laat het systeem zelf bepalen of en wanneer dingen in /tmp naar hard disk verhuizen

- /var/tmp : Temporary files preserved between system reboots
	- it is recommended that deletions occur at a less frequent interval than /tmp

- /var/log bevat (generaties van) logs van allerlei programma's
	- ./syslog wordt blijkbaar door elk programma naar wens bijgevuld
	- andere programma's schrijven hun eigen log, b.v. dpkg houdt een log bij van elke install, remove, upgrade, ...
	- logrotate sluit periodiek logs af, zipt de oude log, en wist zips van nog oudere logs
		- configuratie in etc/logrotate.conf en /etc/logrotate.d
		- laatste rotatiemoment per log in /var/lib/logrotate/status

- grote slokoppen op /var
	/var/cache/apt : cache van recent geinstalleerde packages
	/var/cache/apt-xapian-index : ? ook iets met apt
	/var/lib/apt/lists : index van al het beschikbare in de repositories
	/var/lib/dpkg : idem op dpkg-niveau
	/var/logs : kan serieus opgekuist en beperkt (minder lang bijhouden) worden indien gewenst, maar zolang er schijfruimte genoeg is; minder lang bijhouden heeft in ieder geval geen invloed op aantal schrijfbewerkingen op de schijf
		- zie sectie "journalctl"
	
- /run/user/1000
	- staat in env. variable $XDG_RUNTIME_DIR
	- base directory relative to which user-specific non-essential runtime files and other file objects (such as sockets, named pipes, ...) should be stored. The directory MUST be owned by the user, and he MUST be the only one having read and write access to it. Its Unix access mode MUST be 0700
	- MUST be created when the user first logs in and if the user fully logs out the directory MUST be removed
	- Files in this directory MAY be subjected to periodic clean-up. To ensure that your files are not removed, they should have their access time timestamp modified at least once every 6 hours of monotonic time or the 'sticky' bit should be set on the file
	- Applications should use this directory for communication and synchronization purposes and should not place larger files in it, since it might reside in runtime memory and cannot necessarily be swapped out to disk.
	- in bionic een tmpfs van 1,6GB

- ~/.cache/upstart bevat logs van userprogrammas
	- logrotate sluit periodiek logs af, zipt de oude log, en wist zips van nog oudere logs
		- configuratie ? (er is b.v. geen ~/.config/logrotate.conf)
		- laatste rotatiemoment per log in /home/dirk/.cache/logrotate/status

- /srv : "contains data served by this system", b.v. web- of ftp-server; leeg bij desktopgebuik
